"use strict"; (self.webpackChunkshop = self.webpackChunkshop || []).push([[179], { 112: () => { function se(e) { return "function" == typeof e } function So(e) { const t = e(r => { Error.call(r), r.stack = (new Error).stack }); return t.prototype = Object.create(Error.prototype), t.prototype.constructor = t, t } const Qi = So(e => function (t) { e(this), this.message = t ? `${t.length} errors occurred during unsubscription:\n${t.map((r, o) => `${o + 1}) ${r.toString()}`).join("\n  ")}` : "", this.name = "UnsubscriptionError", this.errors = t }); function Mo(e, n) { if (e) { const t = e.indexOf(n); 0 <= t && e.splice(t, 1) } } class Dt { constructor(n) { this.initialTeardown = n, this.closed = !1, this._parentage = null, this._finalizers = null } unsubscribe() { let n; if (!this.closed) { this.closed = !0; const { _parentage: t } = this; if (t) if (this._parentage = null, Array.isArray(t)) for (const i of t) i.remove(this); else t.remove(this); const { initialTeardown: r } = this; if (se(r)) try { r() } catch (i) { n = i instanceof Qi ? i.errors : [i] } const { _finalizers: o } = this; if (o) { this._finalizers = null; for (const i of o) try { Mf(i) } catch (s) { n = n ?? [], s instanceof Qi ? n = [...n, ...s.errors] : n.push(s) } } if (n) throw new Qi(n) } } add(n) { var t; if (n && n !== this) if (this.closed) Mf(n); else { if (n instanceof Dt) { if (n.closed || n._hasParent(this)) return; n._addParent(this) } (this._finalizers = null !== (t = this._finalizers) && void 0 !== t ? t : []).push(n) } } _hasParent(n) { const { _parentage: t } = this; return t === n || Array.isArray(t) && t.includes(n) } _addParent(n) { const { _parentage: t } = this; this._parentage = Array.isArray(t) ? (t.push(n), t) : t ? [t, n] : n } _removeParent(n) { const { _parentage: t } = this; t === n ? this._parentage = null : Array.isArray(t) && Mo(t, n) } remove(n) { const { _finalizers: t } = this; t && Mo(t, n), n instanceof Dt && n._removeParent(this) } } Dt.EMPTY = (() => { const e = new Dt; return e.closed = !0, e })(); const Ef = Dt.EMPTY; function Sf(e) { return e instanceof Dt || e && "closed" in e && se(e.remove) && se(e.add) && se(e.unsubscribe) } function Mf(e) { se(e) ? e() : e.unsubscribe() } const Yn = { onUnhandledError: null, onStoppedNotification: null, Promise: void 0, useDeprecatedSynchronousErrorHandling: !1, useDeprecatedNextContext: !1 }, Xi = { setTimeout(e, n, ...t) { const { delegate: r } = Xi; return r?.setTimeout ? r.setTimeout(e, n, ...t) : setTimeout(e, n, ...t) }, clearTimeout(e) { const { delegate: n } = Xi; return (n?.clearTimeout || clearTimeout)(e) }, delegate: void 0 }; function If(e) { Xi.setTimeout(() => { const { onUnhandledError: n } = Yn; if (!n) throw e; n(e) }) } function Af() { } const dw = cl("C", void 0, void 0); function cl(e, n, t) { return { kind: e, value: n, error: t } } let Qn = null; function Ji(e) { if (Yn.useDeprecatedSynchronousErrorHandling) { const n = !Qn; if (n && (Qn = { errorThrown: !1, error: null }), e(), n) { const { errorThrown: t, error: r } = Qn; if (Qn = null, t) throw r } } else e() } class dl extends Dt { constructor(n) { super(), this.isStopped = !1, n ? (this.destination = n, Sf(n) && n.add(this)) : this.destination = vw } static create(n, t, r) { return new Io(n, t, r) } next(n) { this.isStopped ? hl(function hw(e) { return cl("N", e, void 0) }(n), this) : this._next(n) } error(n) { this.isStopped ? hl(function fw(e) { return cl("E", void 0, e) }(n), this) : (this.isStopped = !0, this._error(n)) } complete() { this.isStopped ? hl(dw, this) : (this.isStopped = !0, this._complete()) } unsubscribe() { this.closed || (this.isStopped = !0, super.unsubscribe(), this.destination = null) } _next(n) { this.destination.next(n) } _error(n) { try { this.destination.error(n) } finally { this.unsubscribe() } } _complete() { try { this.destination.complete() } finally { this.unsubscribe() } } } const gw = Function.prototype.bind; function fl(e, n) { return gw.call(e, n) } class mw { constructor(n) { this.partialObserver = n } next(n) { const { partialObserver: t } = this; if (t.next) try { t.next(n) } catch (r) { es(r) } } error(n) { const { partialObserver: t } = this; if (t.error) try { t.error(n) } catch (r) { es(r) } else es(n) } complete() { const { partialObserver: n } = this; if (n.complete) try { n.complete() } catch (t) { es(t) } } } class Io extends dl { constructor(n, t, r) { let o; if (super(), se(n) || !n) o = { next: n ?? void 0, error: t ?? void 0, complete: r ?? void 0 }; else { let i; this && Yn.useDeprecatedNextContext ? (i = Object.create(n), i.unsubscribe = () => this.unsubscribe(), o = { next: n.next && fl(n.next, i), error: n.error && fl(n.error, i), complete: n.complete && fl(n.complete, i) }) : o = n } this.destination = new mw(o) } } function es(e) { Yn.useDeprecatedSynchronousErrorHandling ? function pw(e) { Yn.useDeprecatedSynchronousErrorHandling && Qn && (Qn.errorThrown = !0, Qn.error = e) }(e) : If(e) } function hl(e, n) { const { onStoppedNotification: t } = Yn; t && Xi.setTimeout(() => t(e, n)) } const vw = { closed: !0, next: Af, error: function yw(e) { throw e }, complete: Af }, pl = "function" == typeof Symbol && Symbol.observable || "@@observable"; function Xn(e) { return e } function Tf(e) { return 0 === e.length ? Xn : 1 === e.length ? e[0] : function (t) { return e.reduce((r, o) => o(r), t) } } let ve = (() => { class e { constructor(t) { t && (this._subscribe = t) } lift(t) { const r = new e; return r.source = this, r.operator = t, r } subscribe(t, r, o) { const i = function Cw(e) { return e && e instanceof dl || function Dw(e) { return e && se(e.next) && se(e.error) && se(e.complete) }(e) && Sf(e) }(t) ? t : new Io(t, r, o); return Ji(() => { const { operator: s, source: a } = this; i.add(s ? s.call(i, a) : a ? this._subscribe(i) : this._trySubscribe(i)) }), i } _trySubscribe(t) { try { return this._subscribe(t) } catch (r) { t.error(r) } } forEach(t, r) { return new (r = xf(r))((o, i) => { const s = new Io({ next: a => { try { t(a) } catch (l) { i(l), s.unsubscribe() } }, error: i, complete: o }); this.subscribe(s) }) } _subscribe(t) { var r; return null === (r = this.source) || void 0 === r ? void 0 : r.subscribe(t) } [pl]() { return this } pipe(...t) { return Tf(t)(this) } toPromise(t) { return new (t = xf(t))((r, o) => { let i; this.subscribe(s => i = s, s => o(s), () => r(i)) }) } } return e.create = n => new e(n), e })(); function xf(e) { var n; return null !== (n = e ?? Yn.Promise) && void 0 !== n ? n : Promise } const ww = So(e => function () { e(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed" }); let hn = (() => { class e extends ve { constructor() { super(), this.closed = !1, this.currentObservers = null, this.observers = [], this.isStopped = !1, this.hasError = !1, this.thrownError = null } lift(t) { const r = new Pf(this, this); return r.operator = t, r } _throwIfClosed() { if (this.closed) throw new ww } next(t) { Ji(() => { if (this._throwIfClosed(), !this.isStopped) { this.currentObservers || (this.currentObservers = Array.from(this.observers)); for (const r of this.currentObservers) r.next(t) } }) } error(t) { Ji(() => { if (this._throwIfClosed(), !this.isStopped) { this.hasError = this.isStopped = !0, this.thrownError = t; const { observers: r } = this; for (; r.length;)r.shift().error(t) } }) } complete() { Ji(() => { if (this._throwIfClosed(), !this.isStopped) { this.isStopped = !0; const { observers: t } = this; for (; t.length;)t.shift().complete() } }) } unsubscribe() { this.isStopped = this.closed = !0, this.observers = this.currentObservers = null } get observed() { var t; return (null === (t = this.observers) || void 0 === t ? void 0 : t.length) > 0 } _trySubscribe(t) { return this._throwIfClosed(), super._trySubscribe(t) } _subscribe(t) { return this._throwIfClosed(), this._checkFinalizedStatuses(t), this._innerSubscribe(t) } _innerSubscribe(t) { const { hasError: r, isStopped: o, observers: i } = this; return r || o ? Ef : (this.currentObservers = null, i.push(t), new Dt(() => { this.currentObservers = null, Mo(i, t) })) } _checkFinalizedStatuses(t) { const { hasError: r, thrownError: o, isStopped: i } = this; r ? t.error(o) : i && t.complete() } asObservable() { const t = new ve; return t.source = this, t } } return e.create = (n, t) => new Pf(n, t), e })(); class Pf extends hn { constructor(n, t) { super(), this.destination = n, this.source = t } next(n) { var t, r; null === (r = null === (t = this.destination) || void 0 === t ? void 0 : t.next) || void 0 === r || r.call(t, n) } error(n) { var t, r; null === (r = null === (t = this.destination) || void 0 === t ? void 0 : t.error) || void 0 === r || r.call(t, n) } complete() { var n, t; null === (t = null === (n = this.destination) || void 0 === n ? void 0 : n.complete) || void 0 === t || t.call(n) } _subscribe(n) { var t, r; return null !== (r = null === (t = this.source) || void 0 === t ? void 0 : t.subscribe(n)) && void 0 !== r ? r : Ef } } function Rf(e) { return se(e?.lift) } function Oe(e) { return n => { if (Rf(n)) return n.lift(function (t) { try { return e(t, this) } catch (r) { this.error(r) } }); throw new TypeError("Unable to lift unknown Observable type") } } function xe(e, n, t, r, o) { return new bw(e, n, t, r, o) } class bw extends dl { constructor(n, t, r, o, i, s) { super(n), this.onFinalize = i, this.shouldUnsubscribe = s, this._next = t ? function (a) { try { t(a) } catch (l) { n.error(l) } } : super._next, this._error = o ? function (a) { try { o(a) } catch (l) { n.error(l) } finally { this.unsubscribe() } } : super._error, this._complete = r ? function () { try { r() } catch (a) { n.error(a) } finally { this.unsubscribe() } } : super._complete } unsubscribe() { var n; if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) { const { closed: t } = this; super.unsubscribe(), !t && (null === (n = this.onFinalize) || void 0 === n || n.call(this)) } } } function G(e, n) { return Oe((t, r) => { let o = 0; t.subscribe(xe(r, i => { r.next(e.call(n, i, o++)) })) }) } function Jn(e) { return this instanceof Jn ? (this.v = e, this) : new Jn(e) } function Iw(e) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var t, n = e[Symbol.asyncIterator]; return n ? n.call(e) : (e = function Of(e) { var n = "function" == typeof Symbol && Symbol.iterator, t = n && e[n], r = 0; if (t) return t.call(e); if (e && "number" == typeof e.length) return { next: function () { return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e } } }; throw new TypeError(n ? "Object is not iterable." : "Symbol.iterator is not defined.") }(e), t = {}, r("next"), r("throw"), r("return"), t[Symbol.asyncIterator] = function () { return this }, t); function r(i) { t[i] = e[i] && function (s) { return new Promise(function (a, l) { !function o(i, s, a, l) { Promise.resolve(l).then(function (u) { i({ value: u, done: a }) }, s) }(a, l, (s = e[i](s)).done, s.value) }) } } } const kf = e => e && "number" == typeof e.length && "function" != typeof e; function Lf(e) { return se(e?.then) } function Vf(e) { return se(e[pl]) } function jf(e) { return Symbol.asyncIterator && se(e?.[Symbol.asyncIterator]) } function Bf(e) { return new TypeError(`You provided ${null !== e && "object" == typeof e ? "an invalid object" : `'${e}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`) } const $f = function Tw() { return "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator" }(); function Uf(e) { return se(e?.[$f]) } function Hf(e) { return function Mw(e, n, t) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var o, r = t.apply(e, n || []), i = []; return o = {}, s("next"), s("throw"), s("return"), o[Symbol.asyncIterator] = function () { return this }, o; function s(f) { r[f] && (o[f] = function (h) { return new Promise(function (p, g) { i.push([f, h, p, g]) > 1 || a(f, h) }) }) } function a(f, h) { try { !function l(f) { f.value instanceof Jn ? Promise.resolve(f.value.v).then(u, c) : d(i[0][2], f) }(r[f](h)) } catch (p) { d(i[0][3], p) } } function u(f) { a("next", f) } function c(f) { a("throw", f) } function d(f, h) { f(h), i.shift(), i.length && a(i[0][0], i[0][1]) } }(this, arguments, function* () { const t = e.getReader(); try { for (; ;) { const { value: r, done: o } = yield Jn(t.read()); if (o) return yield Jn(void 0); yield yield Jn(r) } } finally { t.releaseLock() } }) } function zf(e) { return se(e?.getReader) } function Ct(e) { if (e instanceof ve) return e; if (null != e) { if (Vf(e)) return function xw(e) { return new ve(n => { const t = e[pl](); if (se(t.subscribe)) return t.subscribe(n); throw new TypeError("Provided object does not correctly implement Symbol.observable") }) }(e); if (kf(e)) return function Pw(e) { return new ve(n => { for (let t = 0; t < e.length && !n.closed; t++)n.next(e[t]); n.complete() }) }(e); if (Lf(e)) return function Rw(e) { return new ve(n => { e.then(t => { n.closed || (n.next(t), n.complete()) }, t => n.error(t)).then(null, If) }) }(e); if (jf(e)) return Gf(e); if (Uf(e)) return function Nw(e) { return new ve(n => { for (const t of e) if (n.next(t), n.closed) return; n.complete() }) }(e); if (zf(e)) return function Fw(e) { return Gf(Hf(e)) }(e) } throw Bf(e) } function Gf(e) { return new ve(n => { (function Ow(e, n) { var t, r, o, i; return function Ew(e, n, t, r) { return new (t || (t = Promise))(function (i, s) { function a(c) { try { u(r.next(c)) } catch (d) { s(d) } } function l(c) { try { u(r.throw(c)) } catch (d) { s(d) } } function u(c) { c.done ? i(c.value) : function o(i) { return i instanceof t ? i : new t(function (s) { s(i) }) }(c.value).then(a, l) } u((r = r.apply(e, n || [])).next()) }) }(this, void 0, void 0, function* () { try { for (t = Iw(e); !(r = yield t.next()).done;)if (n.next(r.value), n.closed) return } catch (s) { o = { error: s } } finally { try { r && !r.done && (i = t.return) && (yield i.call(t)) } finally { if (o) throw o.error } } n.complete() }) })(e, n).catch(t => n.error(t)) }) } function pn(e, n, t, r = 0, o = !1) { const i = n.schedule(function () { t(), o ? e.add(this.schedule(null, r)) : this.unsubscribe() }, r); if (e.add(i), !o) return i } function ke(e, n, t = 1 / 0) { return se(n) ? ke((r, o) => G((i, s) => n(r, i, o, s))(Ct(e(r, o))), t) : ("number" == typeof n && (t = n), Oe((r, o) => function kw(e, n, t, r, o, i, s, a) { const l = []; let u = 0, c = 0, d = !1; const f = () => { d && !l.length && !u && n.complete() }, h = g => u < r ? p(g) : l.push(g), p = g => { i && n.next(g), u++; let m = !1; Ct(t(g, c++)).subscribe(xe(n, D => { o?.(D), i ? h(D) : n.next(D) }, () => { m = !0 }, void 0, () => { if (m) try { for (u--; l.length && u < r;) { const D = l.shift(); s ? pn(n, s, () => p(D)) : p(D) } f() } catch (D) { n.error(D) } })) }; return e.subscribe(xe(n, h, () => { d = !0, f() })), () => { a?.() } }(r, o, e, t))) } function Er(e = 1 / 0) { return ke(Xn, e) } const Ht = new ve(e => e.complete()); function ml(e) { return e[e.length - 1] } function Wf(e) { return se(ml(e)) ? e.pop() : void 0 } function Ao(e) { return function Vw(e) { return e && se(e.schedule) }(ml(e)) ? e.pop() : void 0 } function qf(e, n = 0) { return Oe((t, r) => { t.subscribe(xe(r, o => pn(r, e, () => r.next(o), n), () => pn(r, e, () => r.complete(), n), o => pn(r, e, () => r.error(o), n))) }) } function Kf(e, n = 0) { return Oe((t, r) => { r.add(e.schedule(() => t.subscribe(r), n)) }) } function Zf(e, n) { if (!e) throw new Error("Iterable cannot be null"); return new ve(t => { pn(t, n, () => { const r = e[Symbol.asyncIterator](); pn(t, n, () => { r.next().then(o => { o.done ? t.complete() : t.next(o.value) }) }, 0, !0) }) }) } function Se(e, n) { return n ? function Gw(e, n) { if (null != e) { if (Vf(e)) return function Bw(e, n) { return Ct(e).pipe(Kf(n), qf(n)) }(e, n); if (kf(e)) return function Uw(e, n) { return new ve(t => { let r = 0; return n.schedule(function () { r === e.length ? t.complete() : (t.next(e[r++]), t.closed || this.schedule()) }) }) }(e, n); if (Lf(e)) return function $w(e, n) { return Ct(e).pipe(Kf(n), qf(n)) }(e, n); if (jf(e)) return Zf(e, n); if (Uf(e)) return function Hw(e, n) { return new ve(t => { let r; return pn(t, n, () => { r = e[$f](), pn(t, n, () => { let o, i; try { ({ value: o, done: i } = r.next()) } catch (s) { return void t.error(s) } i ? t.complete() : t.next(o) }, 0, !0) }), () => se(r?.return) && r.return() }) }(e, n); if (zf(e)) return function zw(e, n) { return Zf(Hf(e), n) }(e, n) } throw Bf(e) }(e, n) : Ct(e) } function yl(e, n, ...t) { if (!0 === n) return void e(); if (!1 === n) return; const r = new Io({ next: () => { r.unsubscribe(), e() } }); return Ct(n(...t)).subscribe(r) } function oe(e) { for (let n in e) if (e[n] === oe) return n; throw Error("Could not find renamed property on target object.") } function vl(e, n) { for (const t in n) n.hasOwnProperty(t) && !e.hasOwnProperty(t) && (e[t] = n[t]) } function ae(e) { if ("string" == typeof e) return e; if (Array.isArray(e)) return "[" + e.map(ae).join(", ") + "]"; if (null == e) return "" + e; if (e.overriddenName) return `${e.overriddenName}`; if (e.name) return `${e.name}`; const n = e.toString(); if (null == n) return "" + n; const t = n.indexOf("\n"); return -1 === t ? n : n.substring(0, t) } function _l(e, n) { return null == e || "" === e ? null === n ? "" : n : null == n || "" === n ? e : e + " " + n } const Kw = oe({ __forward_ref__: oe }); function le(e) { return e.__forward_ref__ = le, e.toString = function () { return ae(this()) }, e } function O(e) { return Dl(e) ? e() : e } function Dl(e) { return "function" == typeof e && e.hasOwnProperty(Kw) && e.__forward_ref__ === le } function Cl(e) { return e && !!e.\u0275providers } const Yf = "https://g.co/ng/security#xss"; class b extends Error { constructor(n, t) { super(ts(n, t)), this.code = n } } function ts(e, n) { return `NG0${Math.abs(e)}${n ? ": " + n.trim() : ""}` } function j(e) { return "string" == typeof e ? e : null == e ? "" : String(e) } function ns(e, n) { throw new b(-201, !1) } function wt(e, n) { null == e && function te(e, n, t, r) { throw new Error(`ASSERTION ERROR: ${e}` + (null == r ? "" : ` [Expected=> ${t} ${r} ${n} <=Actual]`)) }(n, e, null, "!=") } function x(e) { return { token: e.token, providedIn: e.providedIn || null, factory: e.factory, value: void 0 } } function ot(e) { return { providers: e.providers || [], imports: e.imports || [] } } function rs(e) { return Qf(e, os) || Qf(e, Jf) } function Qf(e, n) { return e.hasOwnProperty(n) ? e[n] : null } function Xf(e) { return e && (e.hasOwnProperty(wl) || e.hasOwnProperty(rb)) ? e[wl] : null } const os = oe({ \u0275prov: oe }), wl = oe({ \u0275inj: oe }), Jf = oe({ ngInjectableDef: oe }), rb = oe({ ngInjectorDef: oe }); var k = (() => ((k = k || {})[k.Default = 0] = "Default", k[k.Host = 1] = "Host", k[k.Self = 2] = "Self", k[k.SkipSelf = 4] = "SkipSelf", k[k.Optional = 8] = "Optional", k))(); let bl; function bt(e) { const n = bl; return bl = e, n } function eh(e, n, t) { const r = rs(e); return r && "root" == r.providedIn ? void 0 === r.value ? r.value = r.factory() : r.value : t & k.Optional ? null : void 0 !== n ? n : void ns(ae(e)) } const ce = (() => typeof globalThis < "u" && globalThis || typeof global < "u" && global || typeof window < "u" && window || typeof self < "u" && typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && self)(), To = {}, El = "__NG_DI_FLAG__", is = "ngTempTokenPath", ib = "ngTokenPath", sb = /\n/gm, ab = "\u0275", th = "__source"; let xo; function Sr(e) { const n = xo; return xo = e, n } function lb(e, n = k.Default) { if (void 0 === xo) throw new b(-203, !1); return null === xo ? eh(e, void 0, n) : xo.get(e, n & k.Optional ? null : void 0, n) } function T(e, n = k.Default) { return (function ob() { return bl }() || lb)(O(e), n) } function W(e, n = k.Default) { return T(e, ss(n)) } function ss(e) { return typeof e > "u" || "number" == typeof e ? e : 0 | (e.optional && 8) | (e.host && 1) | (e.self && 2) | (e.skipSelf && 4) } function Sl(e) { const n = []; for (let t = 0; t < e.length; t++) { const r = O(e[t]); if (Array.isArray(r)) { if (0 === r.length) throw new b(900, !1); let o, i = k.Default; for (let s = 0; s < r.length; s++) { const a = r[s], l = ub(a); "number" == typeof l ? -1 === l ? o = a.token : i |= l : o = a } n.push(T(o, i)) } else n.push(T(r)) } return n } function Po(e, n) { return e[El] = n, e.prototype[El] = n, e } function ub(e) { return e[El] } function gn(e) { return { toString: e }.toString() } var zt = (() => ((zt = zt || {})[zt.OnPush = 0] = "OnPush", zt[zt.Default = 1] = "Default", zt))(), Gt = (() => { return (e = Gt || (Gt = {}))[e.Emulated = 0] = "Emulated", e[e.None = 2] = "None", e[e.ShadowDom = 3] = "ShadowDom", Gt; var e })(); const mn = {}, J = [], as = oe({ \u0275cmp: oe }), Ml = oe({ \u0275dir: oe }), Il = oe({ \u0275pipe: oe }), rh = oe({ \u0275mod: oe }), yn = oe({ \u0275fac: oe }), Ro = oe({ __NG_ELEMENT_ID__: oe }); let fb = 0; function Wt(e) { return gn(() => { const n = ih(e), t = { ...n, decls: e.decls, vars: e.vars, template: e.template, consts: e.consts || null, ngContentSelectors: e.ngContentSelectors, onPush: e.changeDetection === zt.OnPush, directiveDefs: null, pipeDefs: null, dependencies: n.standalone && e.dependencies || null, getStandaloneInjector: null, data: e.data || {}, encapsulation: e.encapsulation || Gt.Emulated, id: "c" + fb++, styles: e.styles || J, _: null, schemas: e.schemas || null, tView: null }; sh(t); const r = e.dependencies; return t.directiveDefs = ls(r, !1), t.pipeDefs = ls(r, !0), t }) } function pb(e) { return ne(e) || He(e) } function gb(e) { return null !== e } function ft(e) { return gn(() => ({ type: e.type, bootstrap: e.bootstrap || J, declarations: e.declarations || J, imports: e.imports || J, exports: e.exports || J, transitiveCompileScopes: null, schemas: e.schemas || null, id: e.id || null })) } function oh(e, n) { if (null == e) return mn; const t = {}; for (const r in e) if (e.hasOwnProperty(r)) { let o = e[r], i = o; Array.isArray(o) && (i = o[1], o = o[0]), t[o] = r, n && (n[o] = i) } return t } function V(e) { return gn(() => { const n = ih(e); return sh(n), n }) } function Ue(e) { return { type: e.type, name: e.name, factory: null, pure: !1 !== e.pure, standalone: !0 === e.standalone, onDestroy: e.type.prototype.ngOnDestroy || null } } function ne(e) { return e[as] || null } function He(e) { return e[Ml] || null } function it(e) { return e[Il] || null } function ht(e, n) { const t = e[rh] || null; if (!t && !0 === n) throw new Error(`Type ${ae(e)} does not have '\u0275mod' property.`); return t } function ih(e) { const n = {}; return { type: e.type, providersResolver: null, factory: null, hostBindings: e.hostBindings || null, hostVars: e.hostVars || 0, hostAttrs: e.hostAttrs || null, contentQueries: e.contentQueries || null, declaredInputs: n, exportAs: e.exportAs || null, standalone: !0 === e.standalone, selectors: e.selectors || J, viewQuery: e.viewQuery || null, features: e.features || null, setInput: null, findHostDirectiveDefs: null, hostDirectives: null, inputs: oh(e.inputs, n), outputs: oh(e.outputs) } } function sh(e) { e.features?.forEach(n => n(e)) } function ls(e, n) { if (!e) return null; const t = n ? it : pb; return () => ("function" == typeof e ? e() : e).map(r => t(r)).filter(gb) } const vn = 0, I = 1, H = 2, me = 3, Pt = 4, er = 5, ze = 6, Ir = 7, _e = 8, us = 9, cs = 10, q = 11, Al = 12, No = 13, ah = 14, Ar = 15, Ge = 16, Fo = 17, Tr = 18, qt = 19, Oo = 20, lh = 21, de = 22, Tl = 1, uh = 2, ds = 7, fs = 8, xr = 9, Qe = 10; function pt(e) { return Array.isArray(e) && "object" == typeof e[Tl] } function Rt(e) { return Array.isArray(e) && !0 === e[Tl] } function xl(e) { return 0 != (4 & e.flags) } function ko(e) { return e.componentOffset > -1 } function hs(e) { return 1 == (1 & e.flags) } function Nt(e) { return !!e.template } function yb(e) { return 0 != (256 & e[H]) } function tr(e, n) { return e.hasOwnProperty(yn) ? e[yn] : null } class Db { constructor(n, t, r) { this.previousValue = n, this.currentValue = t, this.firstChange = r } isFirstChange() { return this.firstChange } } function Et() { return fh } function fh(e) { return e.type.prototype.ngOnChanges && (e.setInput = wb), Cb } function Cb() { const e = ph(this), n = e?.current; if (n) { const t = e.previous; if (t === mn) e.previous = n; else for (let r in n) t[r] = n[r]; e.current = null, this.ngOnChanges(n) } } function wb(e, n, t, r) { const o = this.declaredInputs[t], i = ph(e) || function bb(e, n) { return e[hh] = n }(e, { previous: mn, current: null }), s = i.current || (i.current = {}), a = i.previous, l = a[o]; s[o] = new Db(l && l.currentValue, n, a === mn), e[r] = n } Et.ngInherit = !0; const hh = "__ngSimpleChanges__"; function ph(e) { return e[hh] || null } const St = function (e, n, t) { }; function Le(e) { for (; Array.isArray(e);)e = e[vn]; return e } function ps(e, n) { return Le(n[e]) } function gt(e, n) { return Le(n[e.index]) } function yh(e, n) { return e.data[n] } function Pr(e, n) { return e[n] } function mt(e, n) { const t = n[e]; return pt(t) ? t : t[vn] } function gs(e) { return 64 == (64 & e[H]) } function On(e, n) { return null == n ? null : e[n] } function vh(e) { e[Tr] = 0 } function Rl(e, n) { e[er] += n; let t = e, r = e[me]; for (; null !== r && (1 === n && 1 === t[er] || -1 === n && 0 === t[er]);)r[er] += n, t = r, r = r[me] } const B = { lFrame: Ah(null), bindingsEnabled: !0 }; function Dh() { return B.bindingsEnabled } function C() { return B.lFrame.lView } function X() { return B.lFrame.tView } function Kt(e) { return B.lFrame.contextLView = e, e[_e] } function Zt(e) { return B.lFrame.contextLView = null, e } function Ve() { let e = Ch(); for (; null !== e && 64 === e.type;)e = e.parent; return e } function Ch() { return B.lFrame.currentTNode } function Yt(e, n) { const t = B.lFrame; t.currentTNode = e, t.isParent = n } function Nl() { return B.lFrame.isParent } function Xe() { const e = B.lFrame; let n = e.bindingRootIndex; return -1 === n && (n = e.bindingRootIndex = e.tView.bindingStartIndex), n } function _n() { return B.lFrame.bindingIndex } function Rr() { return B.lFrame.bindingIndex++ } function Dn(e) { const n = B.lFrame, t = n.bindingIndex; return n.bindingIndex = n.bindingIndex + e, t } function kb(e, n) { const t = B.lFrame; t.bindingIndex = t.bindingRootIndex = e, Ol(n) } function Ol(e) { B.lFrame.currentDirectiveIndex = e } function Sh() { return B.lFrame.currentQueryIndex } function Ll(e) { B.lFrame.currentQueryIndex = e } function Vb(e) { const n = e[I]; return 2 === n.type ? n.declTNode : 1 === n.type ? e[ze] : null } function Mh(e, n, t) { if (t & k.SkipSelf) { let o = n, i = e; for (; !(o = o.parent, null !== o || t & k.Host || (o = Vb(i), null === o || (i = i[Ar], 10 & o.type)));); if (null === o) return !1; n = o, e = i } const r = B.lFrame = Ih(); return r.currentTNode = n, r.lView = e, !0 } function Vl(e) { const n = Ih(), t = e[I]; B.lFrame = n, n.currentTNode = t.firstChild, n.lView = e, n.tView = t, n.contextLView = e, n.bindingIndex = t.bindingStartIndex, n.inI18n = !1 } function Ih() { const e = B.lFrame, n = null === e ? null : e.child; return null === n ? Ah(e) : n } function Ah(e) { const n = { currentTNode: null, isParent: !0, lView: null, tView: null, selectedIndex: -1, contextLView: null, elementDepthCount: 0, currentNamespace: null, currentDirectiveIndex: -1, bindingRootIndex: -1, bindingIndex: -1, currentQueryIndex: 0, parent: e, child: null, inI18n: !1 }; return null !== e && (e.child = n), n } function Th() { const e = B.lFrame; return B.lFrame = e.parent, e.currentTNode = null, e.lView = null, e } const xh = Th; function jl() { const e = Th(); e.isParent = !0, e.tView = null, e.selectedIndex = -1, e.contextLView = null, e.elementDepthCount = 0, e.currentDirectiveIndex = -1, e.currentNamespace = null, e.bindingRootIndex = -1, e.bindingIndex = -1, e.currentQueryIndex = 0 } function Je() { return B.lFrame.selectedIndex } function nr(e) { B.lFrame.selectedIndex = e } function he() { const e = B.lFrame; return yh(e.tView, e.selectedIndex) } function ms(e, n) { for (let t = n.directiveStart, r = n.directiveEnd; t < r; t++) { const i = e.data[t].type.prototype, { ngAfterContentInit: s, ngAfterContentChecked: a, ngAfterViewInit: l, ngAfterViewChecked: u, ngOnDestroy: c } = i; s && (e.contentHooks || (e.contentHooks = [])).push(-t, s), a && ((e.contentHooks || (e.contentHooks = [])).push(t, a), (e.contentCheckHooks || (e.contentCheckHooks = [])).push(t, a)), l && (e.viewHooks || (e.viewHooks = [])).push(-t, l), u && ((e.viewHooks || (e.viewHooks = [])).push(t, u), (e.viewCheckHooks || (e.viewCheckHooks = [])).push(t, u)), null != c && (e.destroyHooks || (e.destroyHooks = [])).push(t, c) } } function ys(e, n, t) { Ph(e, n, 3, t) } function vs(e, n, t, r) { (3 & e[H]) === t && Ph(e, n, t, r) } function Bl(e, n) { let t = e[H]; (3 & t) === n && (t &= 2047, t += 1, e[H] = t) } function Ph(e, n, t, r) { const i = r ?? -1, s = n.length - 1; let a = 0; for (let l = void 0 !== r ? 65535 & e[Tr] : 0; l < s; l++)if ("number" == typeof n[l + 1]) { if (a = n[l], null != r && a >= r) break } else n[l] < 0 && (e[Tr] += 65536), (a < i || -1 == i) && (qb(e, t, n, l), e[Tr] = (4294901760 & e[Tr]) + l + 2), l++ } function qb(e, n, t, r) { const o = t[r] < 0, i = t[r + 1], a = e[o ? -t[r] : t[r]]; if (o) { if (e[H] >> 11 < e[Tr] >> 16 && (3 & e[H]) === n) { e[H] += 2048, St(4, a, i); try { i.call(a) } finally { St(5, a, i) } } } else { St(4, a, i); try { i.call(a) } finally { St(5, a, i) } } } const Nr = -1; class Vo { constructor(n, t, r) { this.factory = n, this.resolving = !1, this.canSeeViewProviders = t, this.injectImpl = r } } function Ul(e, n, t) { let r = 0; for (; r < t.length;) { const o = t[r]; if ("number" == typeof o) { if (0 !== o) break; r++; const i = t[r++], s = t[r++], a = t[r++]; e.setAttribute(n, s, a, i) } else { const i = o, s = t[++r]; Nh(i) ? e.setProperty(n, i, s) : e.setAttribute(n, i, s), r++ } } return r } function Rh(e) { return 3 === e || 4 === e || 6 === e } function Nh(e) { return 64 === e.charCodeAt(0) } function jo(e, n) { if (null !== n && 0 !== n.length) if (null === e || 0 === e.length) e = n.slice(); else { let t = -1; for (let r = 0; r < n.length; r++) { const o = n[r]; "number" == typeof o ? t = o : 0 === t || Fh(e, t, o, null, -1 === t || 2 === t ? n[++r] : null) } } return e } function Fh(e, n, t, r, o) { let i = 0, s = e.length; if (-1 === n) s = -1; else for (; i < e.length;) { const a = e[i++]; if ("number" == typeof a) { if (a === n) { s = -1; break } if (a > n) { s = i - 1; break } } } for (; i < e.length;) { const a = e[i]; if ("number" == typeof a) break; if (a === t) { if (null === r) return void (null !== o && (e[i + 1] = o)); if (r === e[i + 1]) return void (e[i + 2] = o) } i++, null !== r && i++, null !== o && i++ } -1 !== s && (e.splice(s, 0, n), i = s + 1), e.splice(i++, 0, t), null !== r && e.splice(i++, 0, r), null !== o && e.splice(i++, 0, o) } function Oh(e) { return e !== Nr } function _s(e) { return 32767 & e } function Ds(e, n) { let t = function Qb(e) { return e >> 16 }(e), r = n; for (; t > 0;)r = r[Ar], t--; return r } let Hl = !0; function Cs(e) { const n = Hl; return Hl = e, n } const kh = 255, Lh = 5; let Xb = 0; const Qt = {}; function ws(e, n) { const t = Vh(e, n); if (-1 !== t) return t; const r = n[I]; r.firstCreatePass && (e.injectorIndex = n.length, zl(r.data, e), zl(n, null), zl(r.blueprint, null)); const o = Gl(e, n), i = e.injectorIndex; if (Oh(o)) { const s = _s(o), a = Ds(o, n), l = a[I].data; for (let u = 0; u < 8; u++)n[i + u] = a[s + u] | l[s + u] } return n[i + 8] = o, i } function zl(e, n) { e.push(0, 0, 0, 0, 0, 0, 0, 0, n) } function Vh(e, n) { return -1 === e.injectorIndex || e.parent && e.parent.injectorIndex === e.injectorIndex || null === n[e.injectorIndex + 8] ? -1 : e.injectorIndex } function Gl(e, n) { if (e.parent && -1 !== e.parent.injectorIndex) return e.parent.injectorIndex; let t = 0, r = null, o = n; for (; null !== o;) { if (r = Gh(o), null === r) return Nr; if (t++, o = o[Ar], -1 !== r.injectorIndex) return r.injectorIndex | t << 16 } return Nr } function Wl(e, n, t) { !function Jb(e, n, t) { let r; "string" == typeof t ? r = t.charCodeAt(0) || 0 : t.hasOwnProperty(Ro) && (r = t[Ro]), null == r && (r = t[Ro] = Xb++); const o = r & kh; n.data[e + (o >> Lh)] |= 1 << o }(e, n, t) } function jh(e, n, t) { if (t & k.Optional || void 0 !== e) return e; ns() } function Bh(e, n, t, r) { if (t & k.Optional && void 0 === r && (r = null), !(t & (k.Self | k.Host))) { const o = e[us], i = bt(void 0); try { return o ? o.get(n, r, t & k.Optional) : eh(n, r, t & k.Optional) } finally { bt(i) } } return jh(r, 0, t) } function $h(e, n, t, r = k.Default, o) { if (null !== e) { if (1024 & n[H]) { const s = function oE(e, n, t, r, o) { let i = e, s = n; for (; null !== i && null !== s && 1024 & s[H] && !(256 & s[H]);) { const a = Uh(i, s, t, r | k.Self, Qt); if (a !== Qt) return a; let l = i.parent; if (!l) { const u = s[lh]; if (u) { const c = u.get(t, Qt, r); if (c !== Qt) return c } l = Gh(s), s = s[Ar] } i = l } return o }(e, n, t, r, Qt); if (s !== Qt) return s } const i = Uh(e, n, t, r, Qt); if (i !== Qt) return i } return Bh(n, t, r, o) } function Uh(e, n, t, r, o) { const i = function nE(e) { if ("string" == typeof e) return e.charCodeAt(0) || 0; const n = e.hasOwnProperty(Ro) ? e[Ro] : void 0; return "number" == typeof n ? n >= 0 ? n & kh : rE : n }(t); if ("function" == typeof i) { if (!Mh(n, e, r)) return r & k.Host ? jh(o, 0, r) : Bh(n, t, r, o); try { const s = i(r); if (null != s || r & k.Optional) return s; ns() } finally { xh() } } else if ("number" == typeof i) { let s = null, a = Vh(e, n), l = Nr, u = r & k.Host ? n[Ge][ze] : null; for ((-1 === a || r & k.SkipSelf) && (l = -1 === a ? Gl(e, n) : n[a + 8], l !== Nr && zh(r, !1) ? (s = n[I], a = _s(l), n = Ds(l, n)) : a = -1); -1 !== a;) { const c = n[I]; if (Hh(i, a, c.data)) { const d = tE(a, n, t, s, r, u); if (d !== Qt) return d } l = n[a + 8], l !== Nr && zh(r, n[I].data[a + 8] === u) && Hh(i, a, n) ? (s = c, a = _s(l), n = Ds(l, n)) : a = -1 } } return o } function tE(e, n, t, r, o, i) { const s = n[I], a = s.data[e + 8], c = bs(a, s, t, null == r ? ko(a) && Hl : r != s && 0 != (3 & a.type), o & k.Host && i === a); return null !== c ? rr(n, s, c, a) : Qt } function bs(e, n, t, r, o) { const i = e.providerIndexes, s = n.data, a = 1048575 & i, l = e.directiveStart, c = i >> 20, f = o ? a + c : e.directiveEnd; for (let h = r ? a : a + c; h < f; h++) { const p = s[h]; if (h < l && t === p || h >= l && p.type === t) return h } if (o) { const h = s[l]; if (h && Nt(h) && h.type === t) return l } return null } function rr(e, n, t, r) { let o = e[t]; const i = n.data; if (function Kb(e) { return e instanceof Vo }(o)) { const s = o; s.resolving && function Zw(e, n) { const t = n ? `. Dependency path: ${n.join(" > ")} > ${e}` : ""; throw new b(-200, `Circular dependency in DI detected for ${e}${t}`) }(function ee(e) { return "function" == typeof e ? e.name || e.toString() : "object" == typeof e && null != e && "function" == typeof e.type ? e.type.name || e.type.toString() : j(e) }(i[t])); const a = Cs(s.canSeeViewProviders); s.resolving = !0; const l = s.injectImpl ? bt(s.injectImpl) : null; Mh(e, r, k.Default); try { o = e[t] = s.factory(void 0, i, e, r), n.firstCreatePass && t >= r.directiveStart && function Wb(e, n, t) { const { ngOnChanges: r, ngOnInit: o, ngDoCheck: i } = n.type.prototype; if (r) { const s = fh(n); (t.preOrderHooks || (t.preOrderHooks = [])).push(e, s), (t.preOrderCheckHooks || (t.preOrderCheckHooks = [])).push(e, s) } o && (t.preOrderHooks || (t.preOrderHooks = [])).push(0 - e, o), i && ((t.preOrderHooks || (t.preOrderHooks = [])).push(e, i), (t.preOrderCheckHooks || (t.preOrderCheckHooks = [])).push(e, i)) }(t, i[t], n) } finally { null !== l && bt(l), Cs(a), s.resolving = !1, xh() } } return o } function Hh(e, n, t) { return !!(t[n + (e >> Lh)] & 1 << e) } function zh(e, n) { return !(e & k.Self || e & k.Host && n) } class Fr { constructor(n, t) { this._tNode = n, this._lView = t } get(n, t, r) { return $h(this._tNode, this._lView, n, ss(r), t) } } function rE() { return new Fr(Ve(), C()) } function je(e) { return gn(() => { const n = e.prototype.constructor, t = n[yn] || ql(n), r = Object.prototype; let o = Object.getPrototypeOf(e.prototype).constructor; for (; o && o !== r;) { const i = o[yn] || ql(o); if (i && i !== t) return i; o = Object.getPrototypeOf(o) } return i => new i }) } function ql(e) { return Dl(e) ? () => { const n = ql(O(e)); return n && n() } : tr(e) } function Gh(e) { const n = e[I], t = n.type; return 2 === t ? n.declTNode : 1 === t ? e[ze] : null } const kr = "__parameters__"; function Vr(e, n, t) { return gn(() => { const r = function Kl(e) { return function (...t) { if (e) { const r = e(...t); for (const o in r) this[o] = r[o] } } }(n); function o(...i) { if (this instanceof o) return r.apply(this, i), this; const s = new o(...i); return a.annotation = s, a; function a(l, u, c) { const d = l.hasOwnProperty(kr) ? l[kr] : Object.defineProperty(l, kr, { value: [] })[kr]; for (; d.length <= c;)d.push(null); return (d[c] = d[c] || []).push(s), l } } return t && (o.prototype = Object.create(t.prototype)), o.prototype.ngMetadataName = e, o.annotationCls = o, o }) } class A { constructor(n, t) { this._desc = n, this.ngMetadataName = "InjectionToken", this.\u0275prov = void 0, "number" == typeof t ? this.__NG_ELEMENT_ID__ = t : void 0 !== t && (this.\u0275prov = x({ token: this, providedIn: t.providedIn || "root", factory: t.factory })) } get multi() { return this } toString() { return `InjectionToken ${this._desc}` } } function or(e, n) { e.forEach(t => Array.isArray(t) ? or(t, n) : n(t)) } function qh(e, n, t) { n >= e.length ? e.push(t) : e.splice(n, 0, t) } function Ss(e, n) { return n >= e.length - 1 ? e.pop() : e.splice(n, 1)[0] } function yt(e, n, t) { let r = jr(e, n); return r >= 0 ? e[1 | r] = t : (r = ~r, function lE(e, n, t, r) { let o = e.length; if (o == n) e.push(t, r); else if (1 === o) e.push(r, e[0]), e[0] = t; else { for (o--, e.push(e[o - 1], e[o]); o > n;)e[o] = e[o - 2], o--; e[n] = t, e[n + 1] = r } }(e, r, n, t)), r } function Yl(e, n) { const t = jr(e, n); if (t >= 0) return e[1 | t] } function jr(e, n) { return function Kh(e, n, t) { let r = 0, o = e.length >> t; for (; o !== r;) { const i = r + (o - r >> 1), s = e[i << t]; if (n === s) return i << t; s > n ? o = i : r = i + 1 } return ~(o << t) }(e, n, 1) } const Ho = Po(Vr("Optional"), 8), zo = Po(Vr("SkipSelf"), 4); var st = (() => ((st = st || {})[st.Important = 1] = "Important", st[st.DashCase = 2] = "DashCase", st))(); const nu = new Map; let xE = 0; const ou = "__ngContext__"; function We(e, n) { pt(n) ? (e[ou] = n[Oo], function RE(e) { nu.set(e[Oo], e) }(n)) : e[ou] = n } let iu; function su(e, n) { return iu(e, n) } function Ko(e) { const n = e[me]; return Rt(n) ? n[me] : n } function au(e) { return pp(e[No]) } function lu(e) { return pp(e[Pt]) } function pp(e) { for (; null !== e && !Rt(e);)e = e[Pt]; return e } function $r(e, n, t, r, o) { if (null != r) { let i, s = !1; Rt(r) ? i = r : pt(r) && (s = !0, r = r[vn]); const a = Le(r); 0 === e && null !== t ? null == o ? Dp(n, t, a) : ir(n, t, a, o || null, !0) : 1 === e && null !== t ? ir(n, t, a, o || null, !0) : 2 === e ? function gu(e, n, t) { const r = Ts(e, n); r && function XE(e, n, t, r) { e.removeChild(n, t, r) }(e, r, n, t) }(n, a, s) : 3 === e && n.destroyNode(a), null != i && function t0(e, n, t, r, o) { const i = t[ds]; i !== Le(t) && $r(n, e, r, i, o); for (let a = Qe; a < t.length; a++) { const l = t[a]; Zo(l[I], l, e, n, r, i) } }(n, e, i, t, o) } } function cu(e, n, t) { return e.createElement(n, t) } function mp(e, n) { const t = e[xr], r = t.indexOf(n), o = n[me]; 512 & n[H] && (n[H] &= -513, Rl(o, -1)), t.splice(r, 1) } function du(e, n) { if (e.length <= Qe) return; const t = Qe + n, r = e[t]; if (r) { const o = r[Fo]; null !== o && o !== e && mp(o, r), n > 0 && (e[t - 1][Pt] = r[Pt]); const i = Ss(e, Qe + n); !function zE(e, n) { Zo(e, n, n[q], 2, null, null), n[vn] = null, n[ze] = null }(r[I], r); const s = i[qt]; null !== s && s.detachView(i[I]), r[me] = null, r[Pt] = null, r[H] &= -65 } return r } function yp(e, n) { if (!(128 & n[H])) { const t = n[q]; t.destroyNode && Zo(e, n, t, 3, null, null), function qE(e) { let n = e[No]; if (!n) return fu(e[I], e); for (; n;) { let t = null; if (pt(n)) t = n[No]; else { const r = n[Qe]; r && (t = r) } if (!t) { for (; n && !n[Pt] && n !== e;)pt(n) && fu(n[I], n), n = n[me]; null === n && (n = e), pt(n) && fu(n[I], n), t = n && n[Pt] } n = t } }(n) } } function fu(e, n) { if (!(128 & n[H])) { n[H] &= -65, n[H] |= 128, function QE(e, n) { let t; if (null != e && null != (t = e.destroyHooks)) for (let r = 0; r < t.length; r += 2) { const o = n[t[r]]; if (!(o instanceof Vo)) { const i = t[r + 1]; if (Array.isArray(i)) for (let s = 0; s < i.length; s += 2) { const a = o[i[s]], l = i[s + 1]; St(4, a, l); try { l.call(a) } finally { St(5, a, l) } } else { St(4, o, i); try { i.call(o) } finally { St(5, o, i) } } } } }(e, n), function YE(e, n) { const t = e.cleanup, r = n[Ir]; let o = -1; if (null !== t) for (let i = 0; i < t.length - 1; i += 2)if ("string" == typeof t[i]) { const s = t[i + 3]; s >= 0 ? r[o = s]() : r[o = -s].unsubscribe(), i += 2 } else { const s = r[o = t[i + 1]]; t[i].call(s) } if (null !== r) { for (let i = o + 1; i < r.length; i++)(0, r[i])(); n[Ir] = null } }(e, n), 1 === n[I].type && n[q].destroy(); const t = n[Fo]; if (null !== t && Rt(n[me])) { t !== n[me] && mp(t, n); const r = n[qt]; null !== r && r.detachView(e) } !function NE(e) { nu.delete(e[Oo]) }(n) } } function vp(e, n, t) { return function _p(e, n, t) { let r = n; for (; null !== r && 40 & r.type;)r = (n = r).parent; if (null === r) return t[vn]; { const { componentOffset: o } = r; if (o > -1) { const { encapsulation: i } = e.data[r.directiveStart + o]; if (i === Gt.None || i === Gt.Emulated) return null } return gt(r, t) } }(e, n.parent, t) } function ir(e, n, t, r, o) { e.insertBefore(n, t, r, o) } function Dp(e, n, t) { e.appendChild(n, t) } function Cp(e, n, t, r, o) { null !== r ? ir(e, n, t, r, o) : Dp(e, n, t) } function Ts(e, n) { return e.parentNode(n) } let hu, vu, Ns, Ep = function bp(e, n, t) { return 40 & e.type ? gt(e, t) : null }; function xs(e, n, t, r) { const o = vp(e, r, n), i = n[q], a = function wp(e, n, t) { return Ep(e, n, t) }(r.parent || n[ze], r, n); if (null != o) if (Array.isArray(t)) for (let l = 0; l < t.length; l++)Cp(i, o, t[l], a, !1); else Cp(i, o, t, a, !1); void 0 !== hu && hu(i, r, n, t, o) } function Ps(e, n) { if (null !== n) { const t = n.type; if (3 & t) return gt(n, e); if (4 & t) return pu(-1, e[n.index]); if (8 & t) { const r = n.child; if (null !== r) return Ps(e, r); { const o = e[n.index]; return Rt(o) ? pu(-1, o) : Le(o) } } if (32 & t) return su(n, e)() || Le(e[n.index]); { const r = Mp(e, n); return null !== r ? Array.isArray(r) ? r[0] : Ps(Ko(e[Ge]), r) : Ps(e, n.next) } } return null } function Mp(e, n) { return null !== n ? e[Ge][ze].projection[n.projection] : null } function pu(e, n) { const t = Qe + e + 1; if (t < n.length) { const r = n[t], o = r[I].firstChild; if (null !== o) return Ps(r, o) } return n[ds] } function mu(e, n, t, r, o, i, s) { for (; null != t;) { const a = r[t.index], l = t.type; if (s && 0 === n && (a && We(Le(a), r), t.flags |= 2), 32 != (32 & t.flags)) if (8 & l) mu(e, n, t.child, r, o, i, !1), $r(n, e, o, a, i); else if (32 & l) { const u = su(t, r); let c; for (; c = u();)$r(n, e, o, c, i); $r(n, e, o, a, i) } else 16 & l ? Ip(e, n, r, t, o, i) : $r(n, e, o, a, i); t = s ? t.projectionNext : t.next } } function Zo(e, n, t, r, o, i) { mu(t, r, e.firstChild, n, o, i, !1) } function Ip(e, n, t, r, o, i) { const s = t[Ge], l = s[ze].projection[r.projection]; if (Array.isArray(l)) for (let u = 0; u < l.length; u++)$r(n, e, o, l[u], i); else mu(e, n, l, s[me], o, i, !0) } function Ap(e, n, t) { "" === t ? e.removeAttribute(n, "class") : e.setAttribute(n, "class", t) } function Tp(e, n, t) { const { mergedAttrs: r, classes: o, styles: i } = t; null !== r && Ul(e, n, r), null !== o && Ap(e, n, o), null !== i && function r0(e, n, t) { e.setAttribute(n, "style", t) }(e, n, i) } function Np(e) { return function _u() { if (void 0 === Ns && (Ns = null, ce.trustedTypes)) try { Ns = ce.trustedTypes.createPolicy("angular#unsafe-bypass", { createHTML: e => e, createScript: e => e, createScriptURL: e => e }) } catch { } return Ns }()?.createScriptURL(e) || e } class Fp { constructor(n) { this.changingThisBreaksApplicationSecurity = n } toString() { return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see ${Yf})` } } function kn(e) { return e instanceof Fp ? e.changingThisBreaksApplicationSecurity : e } function Yo(e, n) { const t = function p0(e) { return e instanceof Fp && e.getTypeName() || null }(e); if (null != t && t !== n) { if ("ResourceURL" === t && "URL" === n) return !0; throw new Error(`Required a safe ${n}, got a ${t} (see ${Yf})`) } return t === n } const v0 = /^(?:(?:https?|mailto|data|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi; var Me = (() => ((Me = Me || {})[Me.NONE = 0] = "NONE", Me[Me.HTML = 1] = "HTML", Me[Me.STYLE = 2] = "STYLE", Me[Me.SCRIPT = 3] = "SCRIPT", Me[Me.URL = 4] = "URL", Me[Me.RESOURCE_URL = 5] = "RESOURCE_URL", Me))(); function Hr(e) { const n = Xo(); return n ? n.sanitize(Me.URL, e) || "" : Yo(e, "URL") ? kn(e) : function Du(e) { return (e = String(e)).match(v0) ? e : "unsafe:" + e }(j(e)) } function $p(e) { const n = Xo(); if (n) return Np(n.sanitize(Me.RESOURCE_URL, e) || ""); if (Yo(e, "ResourceURL")) return Np(kn(e)); throw new b(904, !1) } function Xo() { const e = C(); return e && e[Al] } const Os = new A("ENVIRONMENT_INITIALIZER"), Hp = new A("INJECTOR", -1), zp = new A("INJECTOR_DEF_TYPES"); class Gp { get(n, t = To) { if (t === To) { const r = new Error(`NullInjectorError: No provider for ${ae(n)}!`); throw r.name = "NullInjectorError", r } return t } } function R0(...e) { return { \u0275providers: Wp(0, e), \u0275fromNgModule: !0 } } function Wp(e, ...n) { const t = [], r = new Set; let o; return or(n, i => { const s = i; Eu(s, t, [], r) && (o || (o = []), o.push(s)) }), void 0 !== o && qp(o, t), t } function qp(e, n) { for (let t = 0; t < e.length; t++) { const { providers: o } = e[t]; Su(o, i => { n.push(i) }) } } function Eu(e, n, t, r) { if (!(e = O(e))) return !1; let o = null, i = Xf(e); const s = !i && ne(e); if (i || s) { if (s && !s.standalone) return !1; o = e } else { const l = e.ngModule; if (i = Xf(l), !i) return !1; o = l } const a = r.has(o); if (s) { if (a) return !1; if (r.add(o), s.dependencies) { const l = "function" == typeof s.dependencies ? s.dependencies() : s.dependencies; for (const u of l) Eu(u, n, t, r) } } else { if (!i) return !1; { if (null != i.imports && !a) { let u; r.add(o); try { or(i.imports, c => { Eu(c, n, t, r) && (u || (u = []), u.push(c)) }) } finally { } void 0 !== u && qp(u, n) } if (!a) { const u = tr(o) || (() => new o); n.push({ provide: o, useFactory: u, deps: J }, { provide: zp, useValue: o, multi: !0 }, { provide: Os, useValue: () => T(o), multi: !0 }) } const l = i.providers; null == l || a || Su(l, c => { n.push(c) }) } } return o !== e && void 0 !== e.providers } function Su(e, n) { for (let t of e) Cl(t) && (t = t.\u0275providers), Array.isArray(t) ? Su(t, n) : n(t) } const N0 = oe({ provide: String, useValue: oe }); function Mu(e) { return null !== e && "object" == typeof e && N0 in e } function sr(e) { return "function" == typeof e } const Iu = new A("Set Injector scope."), ks = {}, O0 = {}; let Au; function Ls() { return void 0 === Au && (Au = new Gp), Au } class Xt { } class Yp extends Xt { get destroyed() { return this._destroyed } constructor(n, t, r, o) { super(), this.parent = t, this.source = r, this.scopes = o, this.records = new Map, this._ngOnDestroyHooks = new Set, this._onDestroyHooks = [], this._destroyed = !1, xu(n, s => this.processProvider(s)), this.records.set(Hp, zr(void 0, this)), o.has("environment") && this.records.set(Xt, zr(void 0, this)); const i = this.records.get(Iu); null != i && "string" == typeof i.value && this.scopes.add(i.value), this.injectorDefTypes = new Set(this.get(zp.multi, J, k.Self)) } destroy() { this.assertNotDestroyed(), this._destroyed = !0; try { for (const n of this._ngOnDestroyHooks) n.ngOnDestroy(); for (const n of this._onDestroyHooks) n() } finally { this.records.clear(), this._ngOnDestroyHooks.clear(), this.injectorDefTypes.clear(), this._onDestroyHooks.length = 0 } } onDestroy(n) { this._onDestroyHooks.push(n) } runInContext(n) { this.assertNotDestroyed(); const t = Sr(this), r = bt(void 0); try { return n() } finally { Sr(t), bt(r) } } get(n, t = To, r = k.Default) { this.assertNotDestroyed(), r = ss(r); const o = Sr(this), i = bt(void 0); try { if (!(r & k.SkipSelf)) { let a = this.records.get(n); if (void 0 === a) { const l = function B0(e) { return "function" == typeof e || "object" == typeof e && e instanceof A }(n) && rs(n); a = l && this.injectableDefInScope(l) ? zr(Tu(n), ks) : null, this.records.set(n, a) } if (null != a) return this.hydrate(n, a) } return (r & k.Self ? Ls() : this.parent).get(n, t = r & k.Optional && t === To ? null : t) } catch (s) { if ("NullInjectorError" === s.name) { if ((s[is] = s[is] || []).unshift(ae(n)), o) throw s; return function cb(e, n, t, r) { const o = e[is]; throw n[th] && o.unshift(n[th]), e.message = function db(e, n, t, r = null) { e = e && "\n" === e.charAt(0) && e.charAt(1) == ab ? e.slice(2) : e; let o = ae(n); if (Array.isArray(n)) o = n.map(ae).join(" -> "); else if ("object" == typeof n) { let i = []; for (let s in n) if (n.hasOwnProperty(s)) { let a = n[s]; i.push(s + ":" + ("string" == typeof a ? JSON.stringify(a) : ae(a))) } o = `{${i.join(", ")}}` } return `${t}${r ? "(" + r + ")" : ""}[${o}]: ${e.replace(sb, "\n  ")}` }("\n" + e.message, o, t, r), e[ib] = o, e[is] = null, e }(s, n, "R3InjectorError", this.source) } throw s } finally { bt(i), Sr(o) } } resolveInjectorInitializers() { const n = Sr(this), t = bt(void 0); try { const r = this.get(Os.multi, J, k.Self); for (const o of r) o() } finally { Sr(n), bt(t) } } toString() { const n = [], t = this.records; for (const r of t.keys()) n.push(ae(r)); return `R3Injector[${n.join(", ")}]` } assertNotDestroyed() { if (this._destroyed) throw new b(205, !1) } processProvider(n) { let t = sr(n = O(n)) ? n : O(n && n.provide); const r = function L0(e) { return Mu(e) ? zr(void 0, e.useValue) : zr(Qp(e), ks) }(n); if (sr(n) || !0 !== n.multi) this.records.get(t); else { let o = this.records.get(t); o || (o = zr(void 0, ks, !0), o.factory = () => Sl(o.multi), this.records.set(t, o)), t = n, o.multi.push(n) } this.records.set(t, r) } hydrate(n, t) { return t.value === ks && (t.value = O0, t.value = t.factory()), "object" == typeof t.value && t.value && function j0(e) { return null !== e && "object" == typeof e && "function" == typeof e.ngOnDestroy }(t.value) && this._ngOnDestroyHooks.add(t.value), t.value } injectableDefInScope(n) { if (!n.providedIn) return !1; const t = O(n.providedIn); return "string" == typeof t ? "any" === t || this.scopes.has(t) : this.injectorDefTypes.has(t) } } function Tu(e) { const n = rs(e), t = null !== n ? n.factory : tr(e); if (null !== t) return t; if (e instanceof A) throw new b(204, !1); if (e instanceof Function) return function k0(e) { const n = e.length; if (n > 0) throw function Uo(e, n) { const t = []; for (let r = 0; r < e; r++)t.push(n); return t }(n, "?"), new b(204, !1); const t = function tb(e) { const n = e && (e[os] || e[Jf]); return n ? (function nb(e) { if (e.hasOwnProperty("name")) return e.name; ("" + e).match(/^function\s*([^\s(]+)/) }(e), n) : null }(e); return null !== t ? () => t.factory(e) : () => new e }(e); throw new b(204, !1) } function Qp(e, n, t) { let r; if (sr(e)) { const o = O(e); return tr(o) || Tu(o) } if (Mu(e)) r = () => O(e.useValue); else if (function Zp(e) { return !(!e || !e.useFactory) }(e)) r = () => e.useFactory(...Sl(e.deps || [])); else if (function Kp(e) { return !(!e || !e.useExisting) }(e)) r = () => T(O(e.useExisting)); else { const o = O(e && (e.useClass || e.provide)); if (!function V0(e) { return !!e.deps }(e)) return tr(o) || Tu(o); r = () => new o(...Sl(e.deps)) } return r } function zr(e, n, t = !1) { return { factory: e, value: n, multi: t ? [] : void 0 } } function xu(e, n) { for (const t of e) Array.isArray(t) ? xu(t, n) : t && Cl(t) ? xu(t.\u0275providers, n) : n(t) } class $0 { } class Xp { } class H0 { resolveComponentFactory(n) { throw function U0(e) { const n = Error(`No component factory found for ${ae(e)}. Did you add it to @NgModule.entryComponents?`); return n.ngComponent = e, n }(n) } } let Jo = (() => { class e { } return e.NULL = new H0, e })(); function z0() { return Gr(Ve(), C()) } function Gr(e, n) { return new lt(gt(e, n)) } let lt = (() => { class e { constructor(t) { this.nativeElement = t } } return e.__NG_ELEMENT_ID__ = z0, e })(); function G0(e) { return e instanceof lt ? e.nativeElement : e } class eg { } let wn = (() => { class e { } return e.__NG_ELEMENT_ID__ = () => function W0() { const e = C(), t = mt(Ve().index, e); return (pt(t) ? t : e)[q] }(), e })(), q0 = (() => { class e { } return e.\u0275prov = x({ token: e, providedIn: "root", factory: () => null }), e })(); class ei { constructor(n) { this.full = n, this.major = n.split(".")[0], this.minor = n.split(".")[1], this.patch = n.split(".").slice(2).join(".") } } const K0 = new ei("15.2.5"), Pu = {}, Ru = "ngOriginalError"; function Nu(e) { return e[Ru] } class Wr { constructor() { this._console = console } handleError(n) { const t = this._findOriginalError(n); this._console.error("ERROR", n), t && this._console.error("ORIGINAL ERROR", t) } _findOriginalError(n) { let t = n && Nu(n); for (; t && Nu(t);)t = Nu(t); return t || null } } function bn(e) { return e instanceof Function ? e() : e } function ng(e, n, t) { let r = e.length; for (; ;) { const o = e.indexOf(n, t); if (-1 === o) return o; if (0 === o || e.charCodeAt(o - 1) <= 32) { const i = n.length; if (o + i === r || e.charCodeAt(o + i) <= 32) return o } t = o + 1 } } const rg = "ng-template"; function iS(e, n, t) { let r = 0, o = !0; for (; r < e.length;) { let i = e[r++]; if ("string" == typeof i && o) { const s = e[r++]; if (t && "class" === i && -1 !== ng(s.toLowerCase(), n, 0)) return !0 } else { if (1 === i) { for (; r < e.length && "string" == typeof (i = e[r++]);)if (i.toLowerCase() === n) return !0; return !1 } "number" == typeof i && (o = !1) } } return !1 } function og(e) { return 4 === e.type && e.value !== rg } function sS(e, n, t) { return n === (4 !== e.type || t ? e.value : rg) } function aS(e, n, t) { let r = 4; const o = e.attrs || [], i = function cS(e) { for (let n = 0; n < e.length; n++)if (Rh(e[n])) return n; return e.length }(o); let s = !1; for (let a = 0; a < n.length; a++) { const l = n[a]; if ("number" != typeof l) { if (!s) if (4 & r) { if (r = 2 | 1 & r, "" !== l && !sS(e, l, t) || "" === l && 1 === n.length) { if (Ft(r)) return !1; s = !0 } } else { const u = 8 & r ? l : n[++a]; if (8 & r && null !== e.attrs) { if (!iS(e.attrs, u, t)) { if (Ft(r)) return !1; s = !0 } continue } const d = lS(8 & r ? "class" : l, o, og(e), t); if (-1 === d) { if (Ft(r)) return !1; s = !0; continue } if ("" !== u) { let f; f = d > i ? "" : o[d + 1].toLowerCase(); const h = 8 & r ? f : null; if (h && -1 !== ng(h, u, 0) || 2 & r && u !== f) { if (Ft(r)) return !1; s = !0 } } } } else { if (!s && !Ft(r) && !Ft(l)) return !1; if (s && Ft(l)) continue; s = !1, r = l | 1 & r } } return Ft(r) || s } function Ft(e) { return 0 == (1 & e) } function lS(e, n, t, r) { if (null === n) return -1; let o = 0; if (r || !t) { let i = !1; for (; o < n.length;) { const s = n[o]; if (s === e) return o; if (3 === s || 6 === s) i = !0; else { if (1 === s || 2 === s) { let a = n[++o]; for (; "string" == typeof a;)a = n[++o]; continue } if (4 === s) break; if (0 === s) { o += 4; continue } } o += i ? 1 : 2 } return -1 } return function dS(e, n) { let t = e.indexOf(4); if (t > -1) for (t++; t < e.length;) { const r = e[t]; if ("number" == typeof r) return -1; if (r === n) return t; t++ } return -1 }(n, e) } function ig(e, n, t = !1) { for (let r = 0; r < n.length; r++)if (aS(e, n[r], t)) return !0; return !1 } function sg(e, n) { return e ? ":not(" + n.trim() + ")" : n } function hS(e) { let n = e[0], t = 1, r = 2, o = "", i = !1; for (; t < e.length;) { let s = e[t]; if ("string" == typeof s) if (2 & r) { const a = e[++t]; o += "[" + s + (a.length > 0 ? '="' + a + '"' : "") + "]" } else 8 & r ? o += "." + s : 4 & r && (o += " " + s); else "" !== o && !Ft(s) && (n += sg(i, o), o = ""), r = s, i = i || !Ft(r); t++ } return "" !== o && (n += sg(i, o)), n } const $ = {}; function P(e) { ag(X(), C(), Je() + e, !1) } function ag(e, n, t, r) { if (!r) if (3 == (3 & n[H])) { const i = e.preOrderCheckHooks; null !== i && ys(n, i, t) } else { const i = e.preOrderHooks; null !== i && vs(n, i, 0, t) } nr(t) } function dg(e, n = null, t = null, r) { const o = fg(e, n, t, r); return o.resolveInjectorInitializers(), o } function fg(e, n = null, t = null, r, o = new Set) { const i = [t || J, R0(e)]; return r = r || ("object" == typeof e ? void 0 : ae(e)), new Yp(i, n || Ls(), r || null, o) } let Jt = (() => { class e { static create(t, r) { if (Array.isArray(t)) return dg({ name: "" }, r, t, ""); { const o = t.name ?? ""; return dg({ name: o }, t.parent, t.providers, o) } } } return e.THROW_IF_NOT_FOUND = To, e.NULL = new Gp, e.\u0275prov = x({ token: e, providedIn: "any", factory: () => T(Hp) }), e.__NG_ELEMENT_ID__ = -1, e })(); function y(e, n = k.Default) { const t = C(); return null === t ? T(e, n) : $h(Ve(), t, O(e), n) } function Dg(e, n) { const t = e.contentQueries; if (null !== t) for (let r = 0; r < t.length; r += 2) { const i = t[r + 1]; if (-1 !== i) { const s = e.data[i]; Ll(t[r]), s.contentQueries(2, n[i], i) } } } function js(e, n, t, r, o, i, s, a, l, u, c) { const d = n.blueprint.slice(); return d[vn] = o, d[H] = 76 | r, (null !== c || e && 1024 & e[H]) && (d[H] |= 1024), vh(d), d[me] = d[Ar] = e, d[_e] = t, d[cs] = s || e && e[cs], d[q] = a || e && e[q], d[Al] = l || e && e[Al] || null, d[us] = u || e && e[us] || null, d[ze] = i, d[Oo] = function PE() { return xE++ }(), d[lh] = c, d[Ge] = 2 == n.type ? e[Ge] : d, d } function Zr(e, n, t, r, o) { let i = e.data[n]; if (null === i) i = function Vu(e, n, t, r, o) { const i = Ch(), s = Nl(), l = e.data[n] = function jS(e, n, t, r, o, i) { return { type: t, index: r, insertBeforeIndex: null, injectorIndex: n ? n.injectorIndex : -1, directiveStart: -1, directiveEnd: -1, directiveStylingLast: -1, componentOffset: -1, propertyBindings: null, flags: 0, providerIndexes: 0, value: o, attrs: i, mergedAttrs: null, localNames: null, initialInputs: void 0, inputs: null, outputs: null, tView: null, next: null, prev: null, projectionNext: null, child: null, parent: n, projection: null, styles: null, stylesWithoutHost: null, residualStyles: void 0, classes: null, classesWithoutHost: null, residualClasses: void 0, classBindings: 0, styleBindings: 0 } }(0, s ? i : i && i.parent, t, n, r, o); return null === e.firstChild && (e.firstChild = l), null !== i && (s ? null == i.child && null !== l.parent && (i.child = l) : null === i.next && (i.next = l, l.prev = i)), l }(e, n, t, r, o), function Ob() { return B.lFrame.inI18n }() && (i.flags |= 32); else if (64 & i.type) { i.type = t, i.value = r, i.attrs = o; const s = function Lo() { const e = B.lFrame, n = e.currentTNode; return e.isParent ? n : n.parent }(); i.injectorIndex = null === s ? -1 : s.injectorIndex } return Yt(i, !0), i } function ti(e, n, t, r) { if (0 === t) return -1; const o = n.length; for (let i = 0; i < t; i++)n.push(r), e.blueprint.push(r), e.data.push(null); return o } function ju(e, n, t) { Vl(n); try { const r = e.viewQuery; null !== r && Zu(1, r, t); const o = e.template; null !== o && Cg(e, n, o, 1, t), e.firstCreatePass && (e.firstCreatePass = !1), e.staticContentQueries && Dg(e, n), e.staticViewQueries && Zu(2, e.viewQuery, t); const i = e.components; null !== i && function kS(e, n) { for (let t = 0; t < n.length; t++)oM(e, n[t]) }(n, i) } catch (r) { throw e.firstCreatePass && (e.incompleteFirstPass = !0, e.firstCreatePass = !1), r } finally { n[H] &= -5, jl() } } function Bs(e, n, t, r) { const o = n[H]; if (128 != (128 & o)) { Vl(n); try { vh(n), function bh(e) { return B.lFrame.bindingIndex = e }(e.bindingStartIndex), null !== t && Cg(e, n, t, 2, r); const s = 3 == (3 & o); if (s) { const u = e.preOrderCheckHooks; null !== u && ys(n, u, null) } else { const u = e.preOrderHooks; null !== u && vs(n, u, 0, null), Bl(n, 0) } if (function nM(e) { for (let n = au(e); null !== n; n = lu(n)) { if (!n[uh]) continue; const t = n[xr]; for (let r = 0; r < t.length; r++) { const o = t[r]; 512 & o[H] || Rl(o[me], 1), o[H] |= 512 } } }(n), function tM(e) { for (let n = au(e); null !== n; n = lu(n))for (let t = Qe; t < n.length; t++) { const r = n[t], o = r[I]; gs(r) && Bs(o, r, o.template, r[_e]) } }(n), null !== e.contentQueries && Dg(e, n), s) { const u = e.contentCheckHooks; null !== u && ys(n, u) } else { const u = e.contentHooks; null !== u && vs(n, u, 1), Bl(n, 1) } !function FS(e, n) { const t = e.hostBindingOpCodes; if (null !== t) try { for (let r = 0; r < t.length; r++) { const o = t[r]; if (o < 0) nr(~o); else { const i = o, s = t[++r], a = t[++r]; kb(s, i), a(2, n[i]) } } } finally { nr(-1) } }(e, n); const a = e.components; null !== a && function OS(e, n) { for (let t = 0; t < n.length; t++)rM(e, n[t]) }(n, a); const l = e.viewQuery; if (null !== l && Zu(2, l, r), s) { const u = e.viewCheckHooks; null !== u && ys(n, u) } else { const u = e.viewHooks; null !== u && vs(n, u, 2), Bl(n, 2) } !0 === e.firstUpdatePass && (e.firstUpdatePass = !1), n[H] &= -41, 512 & n[H] && (n[H] &= -513, Rl(n[me], -1)) } finally { jl() } } } function Cg(e, n, t, r, o) { const i = Je(), s = 2 & r; try { nr(-1), s && n.length > de && ag(e, n, de, !1), St(s ? 2 : 0, o), t(r, o) } finally { nr(i), St(s ? 3 : 1, o) } } function Bu(e, n, t) { if (xl(n)) { const o = n.directiveEnd; for (let i = n.directiveStart; i < o; i++) { const s = e.data[i]; s.contentQueries && s.contentQueries(1, t[i], i) } } } function $u(e, n, t) { Dh() && (function GS(e, n, t, r) { const o = t.directiveStart, i = t.directiveEnd; ko(t) && function XS(e, n, t) { const r = gt(n, e), o = wg(t), i = e[cs], s = $s(e, js(e, o, null, t.onPush ? 32 : 16, r, n, i, i.createRenderer(r, t), null, null, null)); e[n.index] = s }(n, t, e.data[o + t.componentOffset]), e.firstCreatePass || ws(t, n), We(r, n); const s = t.initialInputs; for (let a = o; a < i; a++) { const l = e.data[a], u = rr(n, e, a, t); We(u, n), null !== s && JS(0, a - o, u, l, 0, s), Nt(l) && (mt(t.index, n)[_e] = rr(n, e, a, t)) } }(e, n, t, gt(t, n)), 64 == (64 & t.flags) && Ag(e, n, t)) } function Uu(e, n, t = gt) { const r = n.localNames; if (null !== r) { let o = n.index + 1; for (let i = 0; i < r.length; i += 2) { const s = r[i + 1], a = -1 === s ? t(n, e) : e[s]; e[o++] = a } } } function wg(e) { const n = e.tView; return null === n || n.incompleteFirstPass ? e.tView = Hu(1, null, e.template, e.decls, e.vars, e.directiveDefs, e.pipeDefs, e.viewQuery, e.schemas, e.consts) : n } function Hu(e, n, t, r, o, i, s, a, l, u) { const c = de + r, d = c + o, f = function LS(e, n) { const t = []; for (let r = 0; r < n; r++)t.push(r < e ? null : $); return t }(c, d), h = "function" == typeof u ? u() : u; return f[I] = { type: e, blueprint: f, template: t, queries: null, viewQuery: a, declTNode: n, data: f.slice().fill(null, c), bindingStartIndex: c, expandoStartIndex: d, hostBindingOpCodes: null, firstCreatePass: !0, firstUpdatePass: !0, staticViewQueries: !1, staticContentQueries: !1, preOrderHooks: null, preOrderCheckHooks: null, contentHooks: null, contentCheckHooks: null, viewHooks: null, viewCheckHooks: null, destroyHooks: null, cleanup: null, contentQueries: null, components: null, directiveRegistry: "function" == typeof i ? i() : i, pipeRegistry: "function" == typeof s ? s() : s, firstChild: null, schemas: l, consts: h, incompleteFirstPass: !1 } } function bg(e, n, t, r) { const o = xg(n); null === t ? o.push(r) : (o.push(t), e.firstCreatePass && Pg(e).push(r, o.length - 1)) } function Eg(e, n, t, r) { for (let o in e) if (e.hasOwnProperty(o)) { t = null === t ? {} : t; const i = e[o]; null === r ? Sg(t, n, o, i) : r.hasOwnProperty(o) && Sg(t, n, r[o], i) } return t } function Sg(e, n, t, r) { e.hasOwnProperty(t) ? e[t].push(n, r) : e[t] = [n, r] } function Mg(e, n) { const t = mt(n, e); 16 & t[H] || (t[H] |= 32) } function zu(e, n, t, r) { if (Dh()) { const o = null === r ? null : { "": -1 }, i = function qS(e, n) { const t = e.directiveRegistry; let r = null, o = null; if (t) for (let i = 0; i < t.length; i++) { const s = t[i]; if (ig(n, s.selectors, !1)) if (r || (r = []), Nt(s)) if (null !== s.findHostDirectiveDefs) { const a = []; o = o || new Map, s.findHostDirectiveDefs(s, a, o), r.unshift(...a, s), Gu(e, n, a.length) } else r.unshift(s), Gu(e, n, 0); else o = o || new Map, s.findHostDirectiveDefs?.(s, r, o), r.push(s) } return null === r ? null : [r, o] }(e, t); let s, a; null === i ? s = a = null : [s, a] = i, null !== s && Ig(e, n, t, s, o, a), o && function KS(e, n, t) { if (n) { const r = e.localNames = []; for (let o = 0; o < n.length; o += 2) { const i = t[n[o + 1]]; if (null == i) throw new b(-301, !1); r.push(n[o], i) } } }(t, r, o) } t.mergedAttrs = jo(t.mergedAttrs, t.attrs) } function Ig(e, n, t, r, o, i) { for (let u = 0; u < r.length; u++)Wl(ws(t, n), e, r[u].type); !function YS(e, n, t) { e.flags |= 1, e.directiveStart = n, e.directiveEnd = n + t, e.providerIndexes = n }(t, e.data.length, r.length); for (let u = 0; u < r.length; u++) { const c = r[u]; c.providersResolver && c.providersResolver(c) } let s = !1, a = !1, l = ti(e, n, r.length, null); for (let u = 0; u < r.length; u++) { const c = r[u]; t.mergedAttrs = jo(t.mergedAttrs, c.hostAttrs), QS(e, t, n, l, c), ZS(l, c, o), null !== c.contentQueries && (t.flags |= 4), (null !== c.hostBindings || null !== c.hostAttrs || 0 !== c.hostVars) && (t.flags |= 64); const d = c.type.prototype; !s && (d.ngOnChanges || d.ngOnInit || d.ngDoCheck) && ((e.preOrderHooks || (e.preOrderHooks = [])).push(t.index), s = !0), !a && (d.ngOnChanges || d.ngDoCheck) && ((e.preOrderCheckHooks || (e.preOrderCheckHooks = [])).push(t.index), a = !0), l++ } !function BS(e, n, t) { const o = n.directiveEnd, i = e.data, s = n.attrs, a = []; let l = null, u = null; for (let c = n.directiveStart; c < o; c++) { const d = i[c], f = t ? t.get(d) : null, p = f ? f.outputs : null; l = Eg(d.inputs, c, l, f ? f.inputs : null), u = Eg(d.outputs, c, u, p); const g = null === l || null === s || og(n) ? null : eM(l, c, s); a.push(g) } null !== l && (l.hasOwnProperty("class") && (n.flags |= 8), l.hasOwnProperty("style") && (n.flags |= 16)), n.initialInputs = a, n.inputs = l, n.outputs = u }(e, t, i) } function Ag(e, n, t) { const r = t.directiveStart, o = t.directiveEnd, i = t.index, s = function Lb() { return B.lFrame.currentDirectiveIndex }(); try { nr(i); for (let a = r; a < o; a++) { const l = e.data[a], u = n[a]; Ol(a), (null !== l.hostBindings || 0 !== l.hostVars || null !== l.hostAttrs) && WS(l, u) } } finally { nr(-1), Ol(s) } } function WS(e, n) { null !== e.hostBindings && e.hostBindings(1, n) } function Gu(e, n, t) { n.componentOffset = t, (e.components || (e.components = [])).push(n.index) } function ZS(e, n, t) { if (t) { if (n.exportAs) for (let r = 0; r < n.exportAs.length; r++)t[n.exportAs[r]] = e; Nt(n) && (t[""] = e) } } function QS(e, n, t, r, o) { e.data[r] = o; const i = o.factory || (o.factory = tr(o.type)), s = new Vo(i, Nt(o), y); e.blueprint[r] = s, t[r] = s, function HS(e, n, t, r, o) { const i = o.hostBindings; if (i) { let s = e.hostBindingOpCodes; null === s && (s = e.hostBindingOpCodes = []); const a = ~n.index; (function zS(e) { let n = e.length; for (; n > 0;) { const t = e[--n]; if ("number" == typeof t && t < 0) return t } return 0 })(s) != a && s.push(a), s.push(t, r, i) } }(e, n, r, ti(e, t, o.hostVars, $), o) } function en(e, n, t, r, o, i) { const s = gt(e, n); !function Wu(e, n, t, r, o, i, s) { if (null == i) e.removeAttribute(n, o, t); else { const a = null == s ? j(i) : s(i, r || "", o); e.setAttribute(n, o, a, t) } }(n[q], s, i, e.value, t, r, o) } function JS(e, n, t, r, o, i) { const s = i[n]; if (null !== s) { const a = r.setInput; for (let l = 0; l < s.length;) { const u = s[l++], c = s[l++], d = s[l++]; null !== a ? r.setInput(t, d, u, c) : t[c] = d } } } function eM(e, n, t) { let r = null, o = 0; for (; o < t.length;) { const i = t[o]; if (0 !== i) if (5 !== i) { if ("number" == typeof i) break; if (e.hasOwnProperty(i)) { null === r && (r = []); const s = e[i]; for (let a = 0; a < s.length; a += 2)if (s[a] === n) { r.push(i, s[a + 1], t[o + 1]); break } } o += 2 } else o += 2; else o += 4 } return r } function Tg(e, n, t, r) { return [e, !0, !1, n, null, 0, r, t, null, null] } function rM(e, n) { const t = mt(n, e); if (gs(t)) { const r = t[I]; 48 & t[H] ? Bs(r, t, r.template, t[_e]) : t[er] > 0 && qu(t) } } function qu(e) { for (let r = au(e); null !== r; r = lu(r))for (let o = Qe; o < r.length; o++) { const i = r[o]; if (gs(i)) if (512 & i[H]) { const s = i[I]; Bs(s, i, s.template, i[_e]) } else i[er] > 0 && qu(i) } const t = e[I].components; if (null !== t) for (let r = 0; r < t.length; r++) { const o = mt(t[r], e); gs(o) && o[er] > 0 && qu(o) } } function oM(e, n) { const t = mt(n, e), r = t[I]; (function iM(e, n) { for (let t = n.length; t < e.blueprint.length; t++)n.push(e.blueprint[t]) })(r, t), ju(r, t, t[_e]) } function $s(e, n) { return e[No] ? e[ah][Pt] = n : e[No] = n, e[ah] = n, n } function Ku(e) { for (; e;) { e[H] |= 32; const n = Ko(e); if (yb(e) && !n) return e; e = n } return null } function Us(e, n, t, r = !0) { const o = n[cs]; o.begin && o.begin(); try { Bs(e, n, e.template, t) } catch (s) { throw r && Ng(n, s), s } finally { o.end && o.end() } } function Zu(e, n, t) { Ll(0), n(e, t) } function xg(e) { return e[Ir] || (e[Ir] = []) } function Pg(e) { return e.cleanup || (e.cleanup = []) } function Ng(e, n) { const t = e[us], r = t ? t.get(Wr, null) : null; r && r.handleError(n) } function Yu(e, n, t, r, o) { for (let i = 0; i < t.length;) { const s = t[i++], a = t[i++], l = n[s], u = e.data[s]; null !== u.setInput ? u.setInput(l, o, r, a) : l[a] = o } } function En(e, n, t) { const r = ps(n, e); !function gp(e, n, t) { e.setValue(n, t) }(e[q], r, t) } function Hs(e, n, t) { let r = t ? e.styles : null, o = t ? e.classes : null, i = 0; if (null !== n) for (let s = 0; s < n.length; s++) { const a = n[s]; "number" == typeof a ? i = a : 1 == i ? o = _l(o, a) : 2 == i && (r = _l(r, a + ": " + n[++s] + ";")) } t ? e.styles = r : e.stylesWithoutHost = r, t ? e.classes = o : e.classesWithoutHost = o } function zs(e, n, t, r, o = !1) { for (; null !== t;) { const i = n[t.index]; if (null !== i && r.push(Le(i)), Rt(i)) for (let a = Qe; a < i.length; a++) { const l = i[a], u = l[I].firstChild; null !== u && zs(l[I], l, u, r) } const s = t.type; if (8 & s) zs(e, n, t.child, r); else if (32 & s) { const a = su(t, n); let l; for (; l = a();)r.push(l) } else if (16 & s) { const a = Mp(n, t); if (Array.isArray(a)) r.push(...a); else { const l = Ko(n[Ge]); zs(l[I], l, a, r, !0) } } t = o ? t.projectionNext : t.next } return r } class ni { get rootNodes() { const n = this._lView, t = n[I]; return zs(t, n, t.firstChild, []) } constructor(n, t) { this._lView = n, this._cdRefInjectingView = t, this._appRef = null, this._attachedToViewContainer = !1 } get context() { return this._lView[_e] } set context(n) { this._lView[_e] = n } get destroyed() { return 128 == (128 & this._lView[H]) } destroy() { if (this._appRef) this._appRef.detachView(this); else if (this._attachedToViewContainer) { const n = this._lView[me]; if (Rt(n)) { const t = n[fs], r = t ? t.indexOf(this) : -1; r > -1 && (du(n, r), Ss(t, r)) } this._attachedToViewContainer = !1 } yp(this._lView[I], this._lView) } onDestroy(n) { bg(this._lView[I], this._lView, null, n) } markForCheck() { Ku(this._cdRefInjectingView || this._lView) } detach() { this._lView[H] &= -65 } reattach() { this._lView[H] |= 64 } detectChanges() { Us(this._lView[I], this._lView, this.context) } checkNoChanges() { } attachToViewContainerRef() { if (this._appRef) throw new b(902, !1); this._attachedToViewContainer = !0 } detachFromAppRef() { this._appRef = null, function WE(e, n) { Zo(e, n, n[q], 2, null, null) }(this._lView[I], this._lView) } attachToAppRef(n) { if (this._attachedToViewContainer) throw new b(902, !1); this._appRef = n } } class sM extends ni { constructor(n) { super(n), this._view = n } detectChanges() { const n = this._view; Us(n[I], n, n[_e], !1) } checkNoChanges() { } get context() { return null } } class Fg extends Jo { constructor(n) { super(), this.ngModule = n } resolveComponentFactory(n) { const t = ne(n); return new ri(t, this.ngModule) } } function Og(e) { const n = []; for (let t in e) e.hasOwnProperty(t) && n.push({ propName: e[t], templateName: t }); return n } class lM { constructor(n, t) { this.injector = n, this.parentInjector = t } get(n, t, r) { r = ss(r); const o = this.injector.get(n, Pu, r); return o !== Pu || t === Pu ? o : this.parentInjector.get(n, t, r) } } class ri extends Xp { get inputs() { return Og(this.componentDef.inputs) } get outputs() { return Og(this.componentDef.outputs) } constructor(n, t) { super(), this.componentDef = n, this.ngModule = t, this.componentType = n.type, this.selector = function pS(e) { return e.map(hS).join(",") }(n.selectors), this.ngContentSelectors = n.ngContentSelectors ? n.ngContentSelectors : [], this.isBoundToModule = !!t } create(n, t, r, o) { let i = (o = o || this.ngModule) instanceof Xt ? o : o?.injector; i && null !== this.componentDef.getStandaloneInjector && (i = this.componentDef.getStandaloneInjector(i) || i); const s = i ? new lM(n, i) : n, a = s.get(eg, null); if (null === a) throw new b(407, !1); const l = s.get(q0, null), u = a.createRenderer(null, this.componentDef), c = this.componentDef.selectors[0][0] || "div", d = r ? function VS(e, n, t) { return e.selectRootElement(n, t === Gt.ShadowDom) }(u, r, this.componentDef.encapsulation) : cu(u, c, function aM(e) { const n = e.toLowerCase(); return "svg" === n ? "svg" : "math" === n ? "math" : null }(c)), f = this.componentDef.onPush ? 288 : 272, h = Hu(0, null, null, 1, 0, null, null, null, null, null), p = js(null, h, null, f, null, null, a, u, l, s, null); let g, m; Vl(p); try { const D = this.componentDef; let S, _ = null; D.findHostDirectiveDefs ? (S = [], _ = new Map, D.findHostDirectiveDefs(D, S, _), S.push(D)) : S = [D]; const F = function cM(e, n) { const t = e[I], r = de; return e[r] = n, Zr(t, r, 2, "#host", null) }(p, d), ie = function dM(e, n, t, r, o, i, s, a) { const l = o[I]; !function fM(e, n, t, r) { for (const o of e) n.mergedAttrs = jo(n.mergedAttrs, o.hostAttrs); null !== n.mergedAttrs && (Hs(n, n.mergedAttrs, !0), null !== t && Tp(r, t, n)) }(r, e, n, s); const u = i.createRenderer(n, t), c = js(o, wg(t), null, t.onPush ? 32 : 16, o[e.index], e, i, u, a || null, null, null); return l.firstCreatePass && Gu(l, e, r.length - 1), $s(o, c), o[e.index] = c }(F, d, D, S, p, a, u); m = yh(h, de), d && function pM(e, n, t, r) { if (r) Ul(e, t, ["ng-version", K0.full]); else { const { attrs: o, classes: i } = function gS(e) { const n = [], t = []; let r = 1, o = 2; for (; r < e.length;) { let i = e[r]; if ("string" == typeof i) 2 === o ? "" !== i && n.push(i, e[++r]) : 8 === o && t.push(i); else { if (!Ft(o)) break; o = i } r++ } return { attrs: n, classes: t } }(n.selectors[0]); o && Ul(e, t, o), i && i.length > 0 && Ap(e, t, i.join(" ")) } }(u, D, d, r), void 0 !== t && function gM(e, n, t) { const r = e.projection = []; for (let o = 0; o < n.length; o++) { const i = t[o]; r.push(null != i ? Array.from(i) : null) } }(m, this.ngContentSelectors, t), g = function hM(e, n, t, r, o, i) { const s = Ve(), a = o[I], l = gt(s, o); Ig(a, o, s, t, null, r); for (let c = 0; c < t.length; c++)We(rr(o, a, s.directiveStart + c, s), o); Ag(a, o, s), l && We(l, o); const u = rr(o, a, s.directiveStart + s.componentOffset, s); if (e[_e] = o[_e] = u, null !== i) for (const c of i) c(u, n); return Bu(a, s, e), u }(ie, D, S, _, p, [mM]), ju(h, p, null) } finally { jl() } return new uM(this.componentType, g, Gr(m, p), p, m) } } class uM extends $0 { constructor(n, t, r, o, i) { super(), this.location = r, this._rootLView = o, this._tNode = i, this.instance = t, this.hostView = this.changeDetectorRef = new sM(o), this.componentType = n } setInput(n, t) { const r = this._tNode.inputs; let o; if (null !== r && (o = r[n])) { const i = this._rootLView; Yu(i[I], i, o, n, t), Mg(i, this._tNode.index) } } get injector() { return new Fr(this._tNode, this._rootLView) } destroy() { this.hostView.destroy() } onDestroy(n) { this.hostView.onDestroy(n) } } function mM() { const e = Ve(); ms(C()[I], e) } function re(e) { let n = function kg(e) { return Object.getPrototypeOf(e.prototype).constructor }(e.type), t = !0; const r = [e]; for (; n;) { let o; if (Nt(e)) o = n.\u0275cmp || n.\u0275dir; else { if (n.\u0275cmp) throw new b(903, !1); o = n.\u0275dir } if (o) { if (t) { r.push(o); const s = e; s.inputs = Qu(e.inputs), s.declaredInputs = Qu(e.declaredInputs), s.outputs = Qu(e.outputs); const a = o.hostBindings; a && DM(e, a); const l = o.viewQuery, u = o.contentQueries; if (l && vM(e, l), u && _M(e, u), vl(e.inputs, o.inputs), vl(e.declaredInputs, o.declaredInputs), vl(e.outputs, o.outputs), Nt(o) && o.data.animation) { const c = e.data; c.animation = (c.animation || []).concat(o.data.animation) } } const i = o.features; if (i) for (let s = 0; s < i.length; s++) { const a = i[s]; a && a.ngInherit && a(e), a === re && (t = !1) } } n = Object.getPrototypeOf(n) } !function yM(e) { let n = 0, t = null; for (let r = e.length - 1; r >= 0; r--) { const o = e[r]; o.hostVars = n += o.hostVars, o.hostAttrs = jo(o.hostAttrs, t = jo(t, o.hostAttrs)) } }(r) } function Qu(e) { return e === mn ? {} : e === J ? [] : e } function vM(e, n) { const t = e.viewQuery; e.viewQuery = t ? (r, o) => { n(r, o), t(r, o) } : n } function _M(e, n) { const t = e.contentQueries; e.contentQueries = t ? (r, o, i) => { n(r, o, i), t(r, o, i) } : n } function DM(e, n) { const t = e.hostBindings; e.hostBindings = t ? (r, o) => { n(r, o), t(r, o) } : n } function Gs(e) { return !!Xu(e) && (Array.isArray(e) || !(e instanceof Map) && Symbol.iterator in e) } function Xu(e) { return null !== e && ("function" == typeof e || "object" == typeof e) } function tn(e, n, t) { return e[n] = t } function qe(e, n, t) { return !Object.is(e[n], t) && (e[n] = t, !0) } function ar(e, n, t, r) { const o = qe(e, n, t); return qe(e, n + 1, r) || o } function nn(e, n, t, r) { const o = C(); return qe(o, Rr(), n) && (X(), en(he(), o, e, n, t, r)), nn } function Jr(e, n, t, r, o, i, s, a) { const u = function Ws(e, n, t, r, o) { const i = ar(e, n, t, r); return qe(e, n + 2, o) || i }(e, _n(), t, o, s); return Dn(3), u ? n + j(t) + r + j(o) + i + j(s) + a : $ } function ut(e, n, t, r, o, i, s, a) { const l = C(), u = X(), c = e + de, d = u.firstCreatePass ? function xM(e, n, t, r, o, i, s, a, l) { const u = n.consts, c = Zr(n, e, 4, s || null, On(u, a)); zu(n, t, c, On(u, l)), ms(n, c); const d = c.tView = Hu(2, c, r, o, i, n.directiveRegistry, n.pipeRegistry, null, n.schemas, u); return null !== n.queries && (n.queries.template(n, c), d.queries = n.queries.embeddedTView(c)), c }(c, u, l, n, t, r, o, i, s) : u.data[c]; Yt(d, !1); const f = l[q].createComment(""); xs(u, l, f, d), We(f, l), $s(l, l[c] = Tg(f, l, f, d)), hs(d) && $u(u, l, d), null != s && Uu(l, d, a) } function Q(e, n, t) { const r = C(); return qe(r, Rr(), n) && function vt(e, n, t, r, o, i, s, a) { const l = gt(n, t); let c, u = n.inputs; !a && null != u && (c = u[r]) ? (Yu(e, t, c, r, o), ko(n) && Mg(t, n.index)) : 3 & n.type && (r = function $S(e) { return "class" === e ? "className" : "for" === e ? "htmlFor" : "formaction" === e ? "formAction" : "innerHtml" === e ? "innerHTML" : "readonly" === e ? "readOnly" : "tabindex" === e ? "tabIndex" : e }(r), o = null != s ? s(o, n.value || "", r) : o, i.setProperty(l, r, o)) }(X(), he(), r, e, n, r[q], t, !1), Q } function Ju(e, n, t, r, o) { const s = o ? "class" : "style"; Yu(e, t, n.inputs[s], s, r) } function v(e, n, t, r) { const o = C(), i = X(), s = de + e, a = o[q], l = i.firstCreatePass ? function NM(e, n, t, r, o, i) { const s = n.consts, l = Zr(n, e, 2, r, On(s, o)); return zu(n, t, l, On(s, i)), null !== l.attrs && Hs(l, l.attrs, !1), null !== l.mergedAttrs && Hs(l, l.mergedAttrs, !0), null !== n.queries && n.queries.elementStart(n, l), l }(s, i, o, n, t, r) : i.data[s], u = o[s] = cu(a, n, function Gb() { return B.lFrame.currentNamespace }()), c = hs(l); return Yt(l, !0), Tp(a, u, l), 32 != (32 & l.flags) && xs(i, o, u, l), 0 === function Tb() { return B.lFrame.elementDepthCount }() && We(u, o), function xb() { B.lFrame.elementDepthCount++ }(), c && ($u(i, o, l), Bu(i, l, o)), null !== r && Uu(o, l), v } function w() { let e = Ve(); Nl() ? function Fl() { B.lFrame.isParent = !1 }() : (e = e.parent, Yt(e, !1)); const n = e; !function Pb() { B.lFrame.elementDepthCount-- }(); const t = X(); return t.firstCreatePass && (ms(t, e), xl(e) && t.queries.elementEnd(e)), null != n.classesWithoutHost && function Zb(e) { return 0 != (8 & e.flags) }(n) && Ju(t, n, C(), n.classesWithoutHost, !0), null != n.stylesWithoutHost && function Yb(e) { return 0 != (16 & e.flags) }(n) && Ju(t, n, C(), n.stylesWithoutHost, !1), w } function Ke(e, n, t, r) { return v(e, n, t, r), w(), Ke } function lr() { return C() } function ii(e) { return !!e && "function" == typeof e.then } const nc = function Yg(e) { return !!e && "function" == typeof e.subscribe }; function Z(e, n, t, r) { const o = C(), i = X(), s = Ve(); return function Xg(e, n, t, r, o, i, s) { const a = hs(r), u = e.firstCreatePass && Pg(e), c = n[_e], d = xg(n); let f = !0; if (3 & r.type || s) { const g = gt(r, n), m = s ? s(g) : g, D = d.length, S = s ? F => s(Le(F[r.index])) : r.index; let _ = null; if (!s && a && (_ = function OM(e, n, t, r) { const o = e.cleanup; if (null != o) for (let i = 0; i < o.length - 1; i += 2) { const s = o[i]; if (s === t && o[i + 1] === r) { const a = n[Ir], l = o[i + 2]; return a.length > l ? a[l] : null } "string" == typeof s && (i += 2) } return null }(e, n, o, r.index)), null !== _) (_.__ngLastListenerFn__ || _).__ngNextListenerFn__ = i, _.__ngLastListenerFn__ = i, f = !1; else { i = em(r, n, c, i, !1); const F = t.listen(m, o, i); d.push(i, F), u && u.push(o, S, D, D + 1) } } else i = em(r, n, c, i, !1); const h = r.outputs; let p; if (f && null !== h && (p = h[o])) { const g = p.length; if (g) for (let m = 0; m < g; m += 2) { const ie = n[p[m]][p[m + 1]].subscribe(i), Ee = d.length; d.push(i, ie), u && u.push(o, r.index, Ee, -(Ee + 1)) } } }(i, o, o[q], s, e, n, r), Z } function Jg(e, n, t, r) { try { return St(6, n, t), !1 !== t(r) } catch (o) { return Ng(e, o), !1 } finally { St(7, n, t) } } function em(e, n, t, r, o) { return function i(s) { if (s === Function) return r; Ku(e.componentOffset > -1 ? mt(e.index, n) : n); let l = Jg(n, t, r, s), u = i.__ngNextListenerFn__; for (; u;)l = Jg(n, t, u, s) && l, u = u.__ngNextListenerFn__; return o && !1 === l && (s.preventDefault(), s.returnValue = !1), l } } function Ot(e = 1) { return function jb(e) { return (B.lFrame.contextLView = function Bb(e, n) { for (; e > 0;)n = n[Ar], e--; return n }(e, B.lFrame.contextLView))[_e] }(e) } function qs(e, n) { return e << 17 | n << 2 } function Ln(e) { return e >> 17 & 32767 } function oc(e) { return 2 | e } function ur(e) { return (131068 & e) >> 2 } function ic(e, n) { return -131069 & e | n << 2 } function sc(e) { return 1 | e } function cm(e, n, t, r, o) { const i = e[t + 1], s = null === n; let a = r ? Ln(i) : ur(i), l = !1; for (; 0 !== a && (!1 === l || s);) { const c = e[a + 1]; zM(e[a], n) && (l = !0, e[a + 1] = r ? sc(c) : oc(c)), a = r ? Ln(c) : ur(c) } l && (e[t + 1] = r ? oc(i) : sc(i)) } function zM(e, n) { return null === e || null == n || (Array.isArray(e) ? e[1] : e) === n || !(!Array.isArray(e) || "string" != typeof n) && jr(e, n) >= 0 } function Ks(e, n) { return function kt(e, n, t, r) { const o = C(), i = X(), s = Dn(2); i.firstUpdatePass && function _m(e, n, t, r) { const o = e.data; if (null === o[t + 1]) { const i = o[Je()], s = function vm(e, n) { return n >= e.expandoStartIndex }(e, t); (function bm(e, n) { return 0 != (e.flags & (n ? 8 : 16)) })(i, r) && null === n && !s && (n = !1), n = function JM(e, n, t, r) { const o = function kl(e) { const n = B.lFrame.currentDirectiveIndex; return -1 === n ? null : e[n] }(e); let i = r ? n.residualClasses : n.residualStyles; if (null === o) 0 === (r ? n.classBindings : n.styleBindings) && (t = si(t = ac(null, e, n, t, r), n.attrs, r), i = null); else { const s = n.directiveStylingLast; if (-1 === s || e[s] !== o) if (t = ac(o, e, n, t, r), null === i) { let l = function eI(e, n, t) { const r = t ? n.classBindings : n.styleBindings; if (0 !== ur(r)) return e[Ln(r)] }(e, n, r); void 0 !== l && Array.isArray(l) && (l = ac(null, e, n, l[1], r), l = si(l, n.attrs, r), function tI(e, n, t, r) { e[Ln(t ? n.classBindings : n.styleBindings)] = r }(e, n, r, l)) } else i = function nI(e, n, t) { let r; const o = n.directiveEnd; for (let i = 1 + n.directiveStylingLast; i < o; i++)r = si(r, e[i].hostAttrs, t); return si(r, n.attrs, t) }(e, n, r) } return void 0 !== i && (r ? n.residualClasses = i : n.residualStyles = i), t }(o, i, n, r), function UM(e, n, t, r, o, i) { let s = i ? n.classBindings : n.styleBindings, a = Ln(s), l = ur(s); e[r] = t; let c, u = !1; if (Array.isArray(t) ? (c = t[1], (null === c || jr(t, c) > 0) && (u = !0)) : c = t, o) if (0 !== l) { const f = Ln(e[a + 1]); e[r + 1] = qs(f, a), 0 !== f && (e[f + 1] = ic(e[f + 1], r)), e[a + 1] = function BM(e, n) { return 131071 & e | n << 17 }(e[a + 1], r) } else e[r + 1] = qs(a, 0), 0 !== a && (e[a + 1] = ic(e[a + 1], r)), a = r; else e[r + 1] = qs(l, 0), 0 === a ? a = r : e[l + 1] = ic(e[l + 1], r), l = r; u && (e[r + 1] = oc(e[r + 1])), cm(e, c, r, !0), cm(e, c, r, !1), function HM(e, n, t, r, o) { const i = o ? e.residualClasses : e.residualStyles; null != i && "string" == typeof n && jr(i, n) >= 0 && (t[r + 1] = sc(t[r + 1])) }(n, c, e, r, i), s = qs(a, l), i ? n.classBindings = s : n.styleBindings = s }(o, i, n, t, s, r) } }(i, e, s, r), n !== $ && qe(o, s, n) && function Cm(e, n, t, r, o, i, s, a) { if (!(3 & n.type)) return; const l = e.data, u = l[a + 1], c = function $M(e) { return 1 == (1 & e) }(u) ? wm(l, n, t, o, ur(u), s) : void 0; Zs(c) || (Zs(i) || function jM(e) { return 2 == (2 & e) }(u) && (i = wm(l, null, t, o, a, s)), function n0(e, n, t, r, o) { if (n) o ? e.addClass(t, r) : e.removeClass(t, r); else { let i = -1 === r.indexOf("-") ? void 0 : st.DashCase; null == o ? e.removeStyle(t, r, i) : ("string" == typeof o && o.endsWith("!important") && (o = o.slice(0, -10), i |= st.Important), e.setStyle(t, r, o, i)) } }(r, s, ps(Je(), t), o, i)) }(i, i.data[Je()], o, o[q], e, o[s + 1] = function iI(e, n) { return null == e || "" === e || ("string" == typeof n ? e += n : "object" == typeof e && (e = ae(kn(e)))), e }(n, t), r, s) }(e, n, null, !0), Ks } function ac(e, n, t, r, o) { let i = null; const s = t.directiveEnd; let a = t.directiveStylingLast; for (-1 === a ? a = t.directiveStart : a++; a < s && (i = n[a], r = si(r, i.hostAttrs, o), i !== e);)a++; return null !== e && (t.directiveStylingLast = a), r } function si(e, n, t) { const r = t ? 1 : 2; let o = -1; if (null !== n) for (let i = 0; i < n.length; i++) { const s = n[i]; "number" == typeof s ? o = s : o === r && (Array.isArray(e) || (e = void 0 === e ? [] : ["", e]), yt(e, s, !!t || n[++i])) } return void 0 === e ? null : e } function wm(e, n, t, r, o, i) { const s = null === n; let a; for (; o > 0;) { const l = e[o], u = Array.isArray(l), c = u ? l[1] : l, d = null === c; let f = t[o + 1]; f === $ && (f = d ? J : void 0); let h = d ? Yl(f, r) : c === r ? f : void 0; if (u && !Zs(h) && (h = Yl(l, r)), Zs(h) && (a = h, s)) return a; const p = e[o + 1]; o = s ? Ln(p) : ur(p) } if (null !== n) { let l = i ? n.residualClasses : n.residualStyles; null != l && (a = Yl(l, r)) } return a } function Zs(e) { return void 0 !== e } function E(e, n = "") { const t = C(), r = X(), o = e + de, i = r.firstCreatePass ? Zr(r, o, 1, n, null) : r.data[o], s = t[o] = function uu(e, n) { return e.createText(n) }(t[q], n); xs(r, t, s, i), Yt(i, !1) } function Be(e) { return sn("", e, ""), Be } function sn(e, n, t) { const r = C(), o = function Qr(e, n, t, r) { return qe(e, Rr(), t) ? n + j(t) + r : $ }(r, e, n, t); return o !== $ && En(r, Je(), o), sn } function lc(e, n, t, r, o) { const i = C(), s = function Xr(e, n, t, r, o, i) { const a = ar(e, _n(), t, o); return Dn(2), a ? n + j(t) + r + j(o) + i : $ }(i, e, n, t, r, o); return s !== $ && En(i, Je(), s), lc } function uc(e, n, t, r, o, i, s) { const a = C(), l = Jr(a, e, n, t, r, o, i, s); return l !== $ && En(a, Je(), l), uc } const cr = void 0; var SI = ["en", [["a", "p"], ["AM", "PM"], cr], [["AM", "PM"], cr, cr], [["S", "M", "T", "W", "T", "F", "S"], ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]], cr, [["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]], cr, [["B", "A"], ["BC", "AD"], ["Before Christ", "Anno Domini"]], 0, [6, 0], ["M/d/yy", "MMM d, y", "MMMM d, y", "EEEE, MMMM d, y"], ["h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz"], ["{1}, {0}", cr, "{1} 'at' {0}", cr], [".", ",", ";", "%", "+", "-", "E", "\xd7", "\u2030", "\u221e", "NaN", ":"], ["#,##0.###", "#,##0%", "\xa4#,##0.00", "#E0"], "USD", "$", "US Dollar", {}, "ltr", function EI(e) { const t = Math.floor(Math.abs(e)), r = e.toString().replace(/^[^.]*\.?/, "").length; return 1 === t && 0 === r ? 1 : 5 }]; let so = {}; function et(e) { const n = function MI(e) { return e.toLowerCase().replace(/_/g, "-") }(e); let t = Um(n); if (t) return t; const r = n.split("-")[0]; if (t = Um(r), t) return t; if ("en" === r) return SI; throw new b(701, !1) } function Um(e) { return e in so || (so[e] = ce.ng && ce.ng.common && ce.ng.common.locales && ce.ng.common.locales[e]), so[e] } var M = (() => ((M = M || {})[M.LocaleId = 0] = "LocaleId", M[M.DayPeriodsFormat = 1] = "DayPeriodsFormat", M[M.DayPeriodsStandalone = 2] = "DayPeriodsStandalone", M[M.DaysFormat = 3] = "DaysFormat", M[M.DaysStandalone = 4] = "DaysStandalone", M[M.MonthsFormat = 5] = "MonthsFormat", M[M.MonthsStandalone = 6] = "MonthsStandalone", M[M.Eras = 7] = "Eras", M[M.FirstDayOfWeek = 8] = "FirstDayOfWeek", M[M.WeekendRange = 9] = "WeekendRange", M[M.DateFormat = 10] = "DateFormat", M[M.TimeFormat = 11] = "TimeFormat", M[M.DateTimeFormat = 12] = "DateTimeFormat", M[M.NumberSymbols = 13] = "NumberSymbols", M[M.NumberFormats = 14] = "NumberFormats", M[M.CurrencyCode = 15] = "CurrencyCode", M[M.CurrencySymbol = 16] = "CurrencySymbol", M[M.CurrencyName = 17] = "CurrencyName", M[M.Currencies = 18] = "Currencies", M[M.Directionality = 19] = "Directionality", M[M.PluralCase = 20] = "PluralCase", M[M.ExtraData = 21] = "ExtraData", M))(); const ao = "en-US"; let Hm = ao; function fc(e, n, t, r, o) { if (e = O(e), Array.isArray(e)) for (let i = 0; i < e.length; i++)fc(e[i], n, t, r, o); else { const i = X(), s = C(); let a = sr(e) ? e : O(e.provide), l = Qp(e); const u = Ve(), c = 1048575 & u.providerIndexes, d = u.directiveStart, f = u.providerIndexes >> 20; if (sr(e) || !e.multi) { const h = new Vo(l, o, y), p = pc(a, n, o ? c : c + f, d); -1 === p ? (Wl(ws(u, s), i, a), hc(i, e, n.length), n.push(a), u.directiveStart++, u.directiveEnd++, o && (u.providerIndexes += 1048576), t.push(h), s.push(h)) : (t[p] = h, s[p] = h) } else { const h = pc(a, n, c + f, d), p = pc(a, n, c, c + f), m = p >= 0 && t[p]; if (o && !m || !o && !(h >= 0 && t[h])) { Wl(ws(u, s), i, a); const D = function bA(e, n, t, r, o) { const i = new Vo(e, t, y); return i.multi = [], i.index = n, i.componentProviders = 0, py(i, o, r && !t), i }(o ? wA : CA, t.length, o, r, l); !o && m && (t[p].providerFactory = D), hc(i, e, n.length, 0), n.push(a), u.directiveStart++, u.directiveEnd++, o && (u.providerIndexes += 1048576), t.push(D), s.push(D) } else hc(i, e, h > -1 ? h : p, py(t[o ? p : h], l, !o && r)); !o && r && m && t[p].componentProviders++ } } } function hc(e, n, t, r) { const o = sr(n), i = function F0(e) { return !!e.useClass }(n); if (o || i) { const l = (i ? O(n.useClass) : n).prototype.ngOnDestroy; if (l) { const u = e.destroyHooks || (e.destroyHooks = []); if (!o && n.multi) { const c = u.indexOf(t); -1 === c ? u.push(t, [r, l]) : u[c + 1].push(r, l) } else u.push(t, l) } } } function py(e, n, t) { return t && e.componentProviders++, e.multi.push(n) - 1 } function pc(e, n, t, r) { for (let o = t; o < r; o++)if (n[o] === e) return o; return -1 } function CA(e, n, t, r) { return gc(this.multi, []) } function wA(e, n, t, r) { const o = this.multi; let i; if (this.providerFactory) { const s = this.providerFactory.componentProviders, a = rr(t, t[I], this.providerFactory.index, r); i = a.slice(0, s), gc(o, i); for (let l = s; l < a.length; l++)i.push(a[l]) } else i = [], gc(o, i); return i } function gc(e, n) { for (let t = 0; t < e.length; t++)n.push((0, e[t])()); return n } function fe(e, n = []) { return t => { t.providersResolver = (r, o) => function DA(e, n, t) { const r = X(); if (r.firstCreatePass) { const o = Nt(e); fc(t, r.data, r.blueprint, o, !0), fc(n, r.data, r.blueprint, o, !1) } }(r, o ? o(e) : e, n) } } class lo { } class gy { } class my extends lo { constructor(n, t) { super(), this._parent = t, this._bootstrapComponents = [], this.destroyCbs = [], this.componentFactoryResolver = new Fg(this); const r = ht(n); this._bootstrapComponents = bn(r.bootstrap), this._r3Injector = fg(n, t, [{ provide: lo, useValue: this }, { provide: Jo, useValue: this.componentFactoryResolver }], ae(n), new Set(["environment"])), this._r3Injector.resolveInjectorInitializers(), this.instance = this._r3Injector.get(n) } get injector() { return this._r3Injector } destroy() { const n = this._r3Injector; !n.destroyed && n.destroy(), this.destroyCbs.forEach(t => t()), this.destroyCbs = null } onDestroy(n) { this.destroyCbs.push(n) } } class mc extends gy { constructor(n) { super(), this.moduleType = n } create(n) { return new my(this.moduleType, n) } } class SA extends lo { constructor(n, t, r) { super(), this.componentFactoryResolver = new Fg(this), this.instance = null; const o = new Yp([...n, { provide: lo, useValue: this }, { provide: Jo, useValue: this.componentFactoryResolver }], t || Ls(), r, new Set(["environment"])); this.injector = o, o.resolveInjectorInitializers() } destroy() { this.injector.destroy() } onDestroy(n) { this.injector.onDestroy(n) } } function ea(e, n, t = null) { return new SA(e, n, t).injector } let MA = (() => { class e { constructor(t) { this._injector = t, this.cachedInjectors = new Map } getOrCreateStandaloneInjector(t) { if (!t.standalone) return null; if (!this.cachedInjectors.has(t.id)) { const r = Wp(0, t.type), o = r.length > 0 ? ea([r], this._injector, `Standalone[${t.type.name}]`) : null; this.cachedInjectors.set(t.id, o) } return this.cachedInjectors.get(t.id) } ngOnDestroy() { try { for (const t of this.cachedInjectors.values()) null !== t && t.destroy() } finally { this.cachedInjectors.clear() } } } return e.\u0275prov = x({ token: e, providedIn: "environment", factory: () => new e(T(Xt)) }), e })(); function yy(e) { e.getStandaloneInjector = n => n.get(MA).getOrCreateStandaloneInjector(e) } function fi(e, n) { const t = e[n]; return t === $ ? void 0 : t } function Sy(e, n, t, r, o, i) { const s = n + t; return qe(e, s, o) ? tn(e, s + 1, i ? r.call(i, o) : r(o)) : fi(e, s + 1) } function dr(e, n) { const t = X(); let r; const o = e + de; t.firstCreatePass ? (r = function zA(e, n) { if (n) for (let t = n.length - 1; t >= 0; t--) { const r = n[t]; if (e === r.name) return r } }(n, t.pipeRegistry), t.data[o] = r, r.onDestroy && (t.destroyHooks || (t.destroyHooks = [])).push(o, r.onDestroy)) : r = t.data[o]; const i = r.factory || (r.factory = tr(r.type)), s = bt(y); try { const a = Cs(!1), l = i(); return Cs(a), function PM(e, n, t, r) { t >= e.data.length && (e.data[t] = null, e.blueprint[t] = null), n[t] = r }(t, C(), o, l), l } finally { bt(s) } } function hi(e, n, t) { const r = e + de, o = C(), i = Pr(o, r); return pi(o, r) ? Sy(o, Xe(), n, i.transform, t, i) : i.transform(t) } function vc(e, n, t, r) { const o = e + de, i = C(), s = Pr(i, o); return pi(i, o) ? function My(e, n, t, r, o, i, s) { const a = n + t; return ar(e, a, o, i) ? tn(e, a + 2, s ? r.call(s, o, i) : r(o, i)) : fi(e, a + 2) }(i, Xe(), n, s.transform, t, r, s) : s.transform(t, r) } function pi(e, n) { return e[I].data[n].pure } function _c(e) { return n => { setTimeout(e, void 0, n) } } const pe = class KA extends hn { constructor(n = !1) { super(), this.__isAsync = n } emit(n) { super.next(n) } subscribe(n, t, r) { let o = n, i = t || (() => null), s = r; if (n && "object" == typeof n) { const l = n; o = l.next?.bind(l), i = l.error?.bind(l), s = l.complete?.bind(l) } this.__isAsync && (i = _c(i), o && (o = _c(o)), s && (s = _c(s))); const a = super.subscribe({ next: o, error: i, complete: s }); return n instanceof Dt && n.add(a), a } }; function ZA() { return this._results[Symbol.iterator]() } class Dc { get changes() { return this._changes || (this._changes = new pe) } constructor(n = !1) { this._emitDistinctChangesOnly = n, this.dirty = !0, this._results = [], this._changesDetected = !1, this._changes = null, this.length = 0, this.first = void 0, this.last = void 0; const t = Dc.prototype; t[Symbol.iterator] || (t[Symbol.iterator] = ZA) } get(n) { return this._results[n] } map(n) { return this._results.map(n) } filter(n) { return this._results.filter(n) } find(n) { return this._results.find(n) } reduce(n, t) { return this._results.reduce(n, t) } forEach(n) { this._results.forEach(n) } some(n) { return this._results.some(n) } toArray() { return this._results.slice() } toString() { return this._results.toString() } reset(n, t) { const r = this; r.dirty = !1; const o = function Mt(e) { return e.flat(Number.POSITIVE_INFINITY) }(n); (this._changesDetected = !function sE(e, n, t) { if (e.length !== n.length) return !1; for (let r = 0; r < e.length; r++) { let o = e[r], i = n[r]; if (t && (o = t(o), i = t(i)), i !== o) return !1 } return !0 }(r._results, o, t)) && (r._results = o, r.length = o.length, r.last = o[this.length - 1], r.first = o[0]) } notifyOnChanges() { this._changes && (this._changesDetected || !this._emitDistinctChangesOnly) && this._changes.emit(this) } setDirty() { this.dirty = !0 } destroy() { this.changes.complete(), this.changes.unsubscribe() } } let Sn = (() => { class e { } return e.__NG_ELEMENT_ID__ = XA, e })(); const YA = Sn, QA = class extends YA { constructor(n, t, r) { super(), this._declarationLView = n, this._declarationTContainer = t, this.elementRef = r } createEmbeddedView(n, t) { const r = this._declarationTContainer.tView, o = js(this._declarationLView, r, n, 16, null, r.declTNode, null, null, null, null, t || null); o[Fo] = this._declarationLView[this._declarationTContainer.index]; const s = this._declarationLView[qt]; return null !== s && (o[qt] = s.createEmbeddedView(r)), ju(r, o, n), new ni(o) } }; function XA() { return ta(Ve(), C()) } function ta(e, n) { return 4 & e.type ? new QA(n, e, Gr(e, n)) : null } let Vt = (() => { class e { } return e.__NG_ELEMENT_ID__ = JA, e })(); function JA() { return Ry(Ve(), C()) } const eT = Vt, xy = class extends eT { constructor(n, t, r) { super(), this._lContainer = n, this._hostTNode = t, this._hostLView = r } get element() { return Gr(this._hostTNode, this._hostLView) } get injector() { return new Fr(this._hostTNode, this._hostLView) } get parentInjector() { const n = Gl(this._hostTNode, this._hostLView); if (Oh(n)) { const t = Ds(n, this._hostLView), r = _s(n); return new Fr(t[I].data[r + 8], t) } return new Fr(null, this._hostLView) } clear() { for (; this.length > 0;)this.remove(this.length - 1) } get(n) { const t = Py(this._lContainer); return null !== t && t[n] || null } get length() { return this._lContainer.length - Qe } createEmbeddedView(n, t, r) { let o, i; "number" == typeof r ? o = r : null != r && (o = r.index, i = r.injector); const s = n.createEmbeddedView(t || {}, i); return this.insert(s, o), s } createComponent(n, t, r, o, i) { const s = n && !function $o(e) { return "function" == typeof e }(n); let a; if (s) a = t; else { const d = t || {}; a = d.index, r = d.injector, o = d.projectableNodes, i = d.environmentInjector || d.ngModuleRef } const l = s ? n : new ri(ne(n)), u = r || this.parentInjector; if (!i && null == l.ngModule) { const f = (s ? u : this.parentInjector).get(Xt, null); f && (i = f) } const c = l.create(u, o, void 0, i); return this.insert(c.hostView, a), c } insert(n, t) { const r = n._lView, o = r[I]; if (function Ab(e) { return Rt(e[me]) }(r)) { const c = this.indexOf(n); if (-1 !== c) this.detach(c); else { const d = r[me], f = new xy(d, d[ze], d[me]); f.detach(f.indexOf(n)) } } const i = this._adjustIndex(t), s = this._lContainer; !function KE(e, n, t, r) { const o = Qe + r, i = t.length; r > 0 && (t[o - 1][Pt] = n), r < i - Qe ? (n[Pt] = t[o], qh(t, Qe + r, n)) : (t.push(n), n[Pt] = null), n[me] = t; const s = n[Fo]; null !== s && t !== s && function ZE(e, n) { const t = e[xr]; n[Ge] !== n[me][me][Ge] && (e[uh] = !0), null === t ? e[xr] = [n] : t.push(n) }(s, n); const a = n[qt]; null !== a && a.insertView(e), n[H] |= 64 }(o, r, s, i); const a = pu(i, s), l = r[q], u = Ts(l, s[ds]); return null !== u && function GE(e, n, t, r, o, i) { r[vn] = o, r[ze] = n, Zo(e, r, t, 1, o, i) }(o, s[ze], l, r, u, a), n.attachToViewContainerRef(), qh(Cc(s), i, n), n } move(n, t) { return this.insert(n, t) } indexOf(n) { const t = Py(this._lContainer); return null !== t ? t.indexOf(n) : -1 } remove(n) { const t = this._adjustIndex(n, -1), r = du(this._lContainer, t); r && (Ss(Cc(this._lContainer), t), yp(r[I], r)) } detach(n) { const t = this._adjustIndex(n, -1), r = du(this._lContainer, t); return r && null != Ss(Cc(this._lContainer), t) ? new ni(r) : null } _adjustIndex(n, t = 0) { return n ?? this.length + t } }; function Py(e) { return e[fs] } function Cc(e) { return e[fs] || (e[fs] = []) } function Ry(e, n) { let t; const r = n[e.index]; if (Rt(r)) t = r; else { let o; if (8 & e.type) o = Le(r); else { const i = n[q]; o = i.createComment(""); const s = gt(e, n); ir(i, Ts(i, s), o, function JE(e, n) { return e.nextSibling(n) }(i, s), !1) } n[e.index] = t = Tg(r, n, o, e), $s(n, t) } return new xy(t, e, n) } class wc { constructor(n) { this.queryList = n, this.matches = null } clone() { return new wc(this.queryList) } setDirty() { this.queryList.setDirty() } } class bc { constructor(n = []) { this.queries = n } createEmbeddedView(n) { const t = n.queries; if (null !== t) { const r = null !== n.contentQueries ? n.contentQueries[0] : t.length, o = []; for (let i = 0; i < r; i++) { const s = t.getByIndex(i); o.push(this.queries[s.indexInDeclarationView].clone()) } return new bc(o) } return null } insertView(n) { this.dirtyQueriesWithMatches(n) } detachView(n) { this.dirtyQueriesWithMatches(n) } dirtyQueriesWithMatches(n) { for (let t = 0; t < this.queries.length; t++)null !== By(n, t).matches && this.queries[t].setDirty() } } class Ny { constructor(n, t, r = null) { this.predicate = n, this.flags = t, this.read = r } } class Ec { constructor(n = []) { this.queries = n } elementStart(n, t) { for (let r = 0; r < this.queries.length; r++)this.queries[r].elementStart(n, t) } elementEnd(n) { for (let t = 0; t < this.queries.length; t++)this.queries[t].elementEnd(n) } embeddedTView(n) { let t = null; for (let r = 0; r < this.length; r++) { const o = null !== t ? t.length : 0, i = this.getByIndex(r).embeddedTView(n, o); i && (i.indexInDeclarationView = r, null !== t ? t.push(i) : t = [i]) } return null !== t ? new Ec(t) : null } template(n, t) { for (let r = 0; r < this.queries.length; r++)this.queries[r].template(n, t) } getByIndex(n) { return this.queries[n] } get length() { return this.queries.length } track(n) { this.queries.push(n) } } class Sc { constructor(n, t = -1) { this.metadata = n, this.matches = null, this.indexInDeclarationView = -1, this.crossesNgTemplate = !1, this._appliesToNextNode = !0, this._declarationNodeIndex = t } elementStart(n, t) { this.isApplyingToNode(t) && this.matchTNode(n, t) } elementEnd(n) { this._declarationNodeIndex === n.index && (this._appliesToNextNode = !1) } template(n, t) { this.elementStart(n, t) } embeddedTView(n, t) { return this.isApplyingToNode(n) ? (this.crossesNgTemplate = !0, this.addMatch(-n.index, t), new Sc(this.metadata)) : null } isApplyingToNode(n) { if (this._appliesToNextNode && 1 != (1 & this.metadata.flags)) { const t = this._declarationNodeIndex; let r = n.parent; for (; null !== r && 8 & r.type && r.index !== t;)r = r.parent; return t === (null !== r ? r.index : -1) } return this._appliesToNextNode } matchTNode(n, t) { const r = this.metadata.predicate; if (Array.isArray(r)) for (let o = 0; o < r.length; o++) { const i = r[o]; this.matchTNodeWithReadOption(n, t, tT(t, i)), this.matchTNodeWithReadOption(n, t, bs(t, n, i, !1, !1)) } else r === Sn ? 4 & t.type && this.matchTNodeWithReadOption(n, t, -1) : this.matchTNodeWithReadOption(n, t, bs(t, n, r, !1, !1)) } matchTNodeWithReadOption(n, t, r) { if (null !== r) { const o = this.metadata.read; if (null !== o) if (o === lt || o === Vt || o === Sn && 4 & t.type) this.addMatch(t.index, -2); else { const i = bs(t, n, o, !1, !1); null !== i && this.addMatch(t.index, i) } else this.addMatch(t.index, r) } } addMatch(n, t) { null === this.matches ? this.matches = [n, t] : this.matches.push(n, t) } } function tT(e, n) { const t = e.localNames; if (null !== t) for (let r = 0; r < t.length; r += 2)if (t[r] === n) return t[r + 1]; return null } function rT(e, n, t, r) { return -1 === t ? function nT(e, n) { return 11 & e.type ? Gr(e, n) : 4 & e.type ? ta(e, n) : null }(n, e) : -2 === t ? function oT(e, n, t) { return t === lt ? Gr(n, e) : t === Sn ? ta(n, e) : t === Vt ? Ry(n, e) : void 0 }(e, n, r) : rr(e, e[I], t, n) } function Fy(e, n, t, r) { const o = n[qt].queries[r]; if (null === o.matches) { const i = e.data, s = t.matches, a = []; for (let l = 0; l < s.length; l += 2) { const u = s[l]; a.push(u < 0 ? null : rT(n, i[u], s[l + 1], t.metadata.read)) } o.matches = a } return o.matches } function Mc(e, n, t, r) { const o = e.queries.getByIndex(t), i = o.matches; if (null !== i) { const s = Fy(e, n, o, t); for (let a = 0; a < i.length; a += 2) { const l = i[a]; if (l > 0) r.push(s[a / 2]); else { const u = i[a + 1], c = n[-l]; for (let d = Qe; d < c.length; d++) { const f = c[d]; f[Fo] === f[me] && Mc(f[I], f, u, r) } if (null !== c[xr]) { const d = c[xr]; for (let f = 0; f < d.length; f++) { const h = d[f]; Mc(h[I], h, u, r) } } } } } return r } function Oy(e) { const n = C(), t = X(), r = Sh(); Ll(r + 1); const o = By(t, r); if (e.dirty && function Ib(e) { return 4 == (4 & e[H]) }(n) === (2 == (2 & o.metadata.flags))) { if (null === o.matches) e.reset([]); else { const i = o.crossesNgTemplate ? Mc(t, n, r, []) : Fy(t, n, o, r); e.reset(i, G0), e.notifyOnChanges() } return !0 } return !1 } function ky(e, n, t, r) { const o = X(); if (o.firstCreatePass) { const i = Ve(); (function jy(e, n, t) { null === e.queries && (e.queries = new Ec), e.queries.track(new Sc(n, t)) })(o, new Ny(n, t, r), i.index), function aT(e, n) { const t = e.contentQueries || (e.contentQueries = []); n !== (t.length ? t[t.length - 1] : -1) && t.push(e.queries.length - 1, n) }(o, e), 2 == (2 & t) && (o.staticContentQueries = !0) } !function Vy(e, n, t) { const r = new Dc(4 == (4 & t)); bg(e, n, r, r.destroy), null === n[qt] && (n[qt] = new bc), n[qt].queries.push(new wc(r)) }(o, C(), t) } function By(e, n) { return e.queries.getByIndex(n) } function ra(...e) { } const oa = new A("Application Initializer"); let ia = (() => { class e { constructor(t) { this.appInits = t, this.resolve = ra, this.reject = ra, this.initialized = !1, this.done = !1, this.donePromise = new Promise((r, o) => { this.resolve = r, this.reject = o }) } runInitializers() { if (this.initialized) return; const t = [], r = () => { this.done = !0, this.resolve() }; if (this.appInits) for (let o = 0; o < this.appInits.length; o++) { const i = this.appInits[o](); if (ii(i)) t.push(i); else if (nc(i)) { const s = new Promise((a, l) => { i.subscribe({ complete: a, error: l }) }); t.push(s) } } Promise.all(t).then(() => { r() }).catch(o => { this.reject(o) }), 0 === t.length && r(), this.initialized = !0 } } return e.\u0275fac = function (t) { return new (t || e)(T(oa, 8)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); const mi = new A("AppId", { providedIn: "root", factory: function ov() { return `${Rc()}${Rc()}${Rc()}` } }); function Rc() { return String.fromCharCode(97 + Math.floor(25 * Math.random())) } const iv = new A("Platform Initializer"), Nc = new A("Platform ID", { providedIn: "platform", factory: () => "unknown" }); let AT = (() => { class e { log(t) { console.log(t) } warn(t) { console.warn(t) } } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "platform" }), e })(); const Mn = new A("LocaleId", { providedIn: "root", factory: () => W(Mn, k.Optional | k.SkipSelf) || function TT() { return typeof $localize < "u" && $localize.locale || ao }() }), xT = new A("DefaultCurrencyCode", { providedIn: "root", factory: () => "USD" }); class PT { constructor(n, t) { this.ngModuleFactory = n, this.componentFactories = t } } let sv = (() => { class e { compileModuleSync(t) { return new mc(t) } compileModuleAsync(t) { return Promise.resolve(this.compileModuleSync(t)) } compileModuleAndAllComponentsSync(t) { const r = this.compileModuleSync(t), i = bn(ht(t).declarations).reduce((s, a) => { const l = ne(a); return l && s.push(new ri(l)), s }, []); return new PT(r, i) } compileModuleAndAllComponentsAsync(t) { return Promise.resolve(this.compileModuleAndAllComponentsSync(t)) } clearCache() { } clearCacheFor(t) { } getModuleId(t) { } } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); const FT = (() => Promise.resolve(0))(); function Fc(e) { typeof Zone > "u" ? FT.then(() => { e && e.apply(null, null) }) : Zone.current.scheduleMicroTask("scheduleMicrotask", e) } class De { constructor({ enableLongStackTrace: n = !1, shouldCoalesceEventChangeDetection: t = !1, shouldCoalesceRunChangeDetection: r = !1 }) { if (this.hasPendingMacrotasks = !1, this.hasPendingMicrotasks = !1, this.isStable = !0, this.onUnstable = new pe(!1), this.onMicrotaskEmpty = new pe(!1), this.onStable = new pe(!1), this.onError = new pe(!1), typeof Zone > "u") throw new b(908, !1); Zone.assertZonePatched(); const o = this; o._nesting = 0, o._outer = o._inner = Zone.current, Zone.TaskTrackingZoneSpec && (o._inner = o._inner.fork(new Zone.TaskTrackingZoneSpec)), n && Zone.longStackTraceZoneSpec && (o._inner = o._inner.fork(Zone.longStackTraceZoneSpec)), o.shouldCoalesceEventChangeDetection = !r && t, o.shouldCoalesceRunChangeDetection = r, o.lastRequestAnimationFrameId = -1, o.nativeRequestAnimationFrame = function OT() { let e = ce.requestAnimationFrame, n = ce.cancelAnimationFrame; if (typeof Zone < "u" && e && n) { const t = e[Zone.__symbol__("OriginalDelegate")]; t && (e = t); const r = n[Zone.__symbol__("OriginalDelegate")]; r && (n = r) } return { nativeRequestAnimationFrame: e, nativeCancelAnimationFrame: n } }().nativeRequestAnimationFrame, function VT(e) { const n = () => { !function LT(e) { e.isCheckStableRunning || -1 !== e.lastRequestAnimationFrameId || (e.lastRequestAnimationFrameId = e.nativeRequestAnimationFrame.call(ce, () => { e.fakeTopEventTask || (e.fakeTopEventTask = Zone.root.scheduleEventTask("fakeTopEventTask", () => { e.lastRequestAnimationFrameId = -1, kc(e), e.isCheckStableRunning = !0, Oc(e), e.isCheckStableRunning = !1 }, void 0, () => { }, () => { })), e.fakeTopEventTask.invoke() }), kc(e)) }(e) }; e._inner = e._inner.fork({ name: "angular", properties: { isAngularZone: !0 }, onInvokeTask: (t, r, o, i, s, a) => { try { return uv(e), t.invokeTask(o, i, s, a) } finally { (e.shouldCoalesceEventChangeDetection && "eventTask" === i.type || e.shouldCoalesceRunChangeDetection) && n(), cv(e) } }, onInvoke: (t, r, o, i, s, a, l) => { try { return uv(e), t.invoke(o, i, s, a, l) } finally { e.shouldCoalesceRunChangeDetection && n(), cv(e) } }, onHasTask: (t, r, o, i) => { t.hasTask(o, i), r === o && ("microTask" == i.change ? (e._hasPendingMicrotasks = i.microTask, kc(e), Oc(e)) : "macroTask" == i.change && (e.hasPendingMacrotasks = i.macroTask)) }, onHandleError: (t, r, o, i) => (t.handleError(o, i), e.runOutsideAngular(() => e.onError.emit(i)), !1) }) }(o) } static isInAngularZone() { return typeof Zone < "u" && !0 === Zone.current.get("isAngularZone") } static assertInAngularZone() { if (!De.isInAngularZone()) throw new b(909, !1) } static assertNotInAngularZone() { if (De.isInAngularZone()) throw new b(909, !1) } run(n, t, r) { return this._inner.run(n, t, r) } runTask(n, t, r, o) { const i = this._inner, s = i.scheduleEventTask("NgZoneEvent: " + o, n, kT, ra, ra); try { return i.runTask(s, t, r) } finally { i.cancelTask(s) } } runGuarded(n, t, r) { return this._inner.runGuarded(n, t, r) } runOutsideAngular(n) { return this._outer.run(n) } } const kT = {}; function Oc(e) { if (0 == e._nesting && !e.hasPendingMicrotasks && !e.isStable) try { e._nesting++, e.onMicrotaskEmpty.emit(null) } finally { if (e._nesting--, !e.hasPendingMicrotasks) try { e.runOutsideAngular(() => e.onStable.emit(null)) } finally { e.isStable = !0 } } } function kc(e) { e.hasPendingMicrotasks = !!(e._hasPendingMicrotasks || (e.shouldCoalesceEventChangeDetection || e.shouldCoalesceRunChangeDetection) && -1 !== e.lastRequestAnimationFrameId) } function uv(e) { e._nesting++, e.isStable && (e.isStable = !1, e.onUnstable.emit(null)) } function cv(e) { e._nesting--, Oc(e) } class jT { constructor() { this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, this.onUnstable = new pe, this.onMicrotaskEmpty = new pe, this.onStable = new pe, this.onError = new pe } run(n, t, r) { return n.apply(t, r) } runGuarded(n, t, r) { return n.apply(t, r) } runOutsideAngular(n) { return n() } runTask(n, t, r, o) { return n.apply(t, r) } } const dv = new A(""), sa = new A(""); let jc, Lc = (() => { class e { constructor(t, r, o) { this._ngZone = t, this.registry = r, this._pendingCount = 0, this._isZoneStable = !0, this._didWork = !1, this._callbacks = [], this.taskTrackingZone = null, jc || (function BT(e) { jc = e }(o), o.addToWindow(r)), this._watchAngularEvents(), t.run(() => { this.taskTrackingZone = typeof Zone > "u" ? null : Zone.current.get("TaskTrackingZone") }) } _watchAngularEvents() { this._ngZone.onUnstable.subscribe({ next: () => { this._didWork = !0, this._isZoneStable = !1 } }), this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.subscribe({ next: () => { De.assertNotInAngularZone(), Fc(() => { this._isZoneStable = !0, this._runCallbacksIfReady() }) } }) }) } increasePendingRequestCount() { return this._pendingCount += 1, this._didWork = !0, this._pendingCount } decreasePendingRequestCount() { if (this._pendingCount -= 1, this._pendingCount < 0) throw new Error("pending async requests below zero"); return this._runCallbacksIfReady(), this._pendingCount } isStable() { return this._isZoneStable && 0 === this._pendingCount && !this._ngZone.hasPendingMacrotasks } _runCallbacksIfReady() { if (this.isStable()) Fc(() => { for (; 0 !== this._callbacks.length;) { let t = this._callbacks.pop(); clearTimeout(t.timeoutId), t.doneCb(this._didWork) } this._didWork = !1 }); else { let t = this.getPendingTasks(); this._callbacks = this._callbacks.filter(r => !r.updateCb || !r.updateCb(t) || (clearTimeout(r.timeoutId), !1)), this._didWork = !0 } } getPendingTasks() { return this.taskTrackingZone ? this.taskTrackingZone.macroTasks.map(t => ({ source: t.source, creationLocation: t.creationLocation, data: t.data })) : [] } addCallback(t, r, o) { let i = -1; r && r > 0 && (i = setTimeout(() => { this._callbacks = this._callbacks.filter(s => s.timeoutId !== i), t(this._didWork, this.getPendingTasks()) }, r)), this._callbacks.push({ doneCb: t, timeoutId: i, updateCb: o }) } whenStable(t, r, o) { if (o && !this.taskTrackingZone) throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?'); this.addCallback(t, r, o), this._runCallbacksIfReady() } getPendingRequestCount() { return this._pendingCount } registerApplication(t) { this.registry.registerApplication(t, this) } unregisterApplication(t) { this.registry.unregisterApplication(t) } findProviders(t, r, o) { return [] } } return e.\u0275fac = function (t) { return new (t || e)(T(De), T(Vc), T(sa)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac }), e })(), Vc = (() => { class e { constructor() { this._applications = new Map } registerApplication(t, r) { this._applications.set(t, r) } unregisterApplication(t) { this._applications.delete(t) } unregisterAllApplications() { this._applications.clear() } getTestability(t) { return this._applications.get(t) || null } getAllTestabilities() { return Array.from(this._applications.values()) } getAllRootElements() { return Array.from(this._applications.keys()) } findTestabilityInTree(t, r = !0) { return jc?.findTestabilityInTree(this, t, r) ?? null } } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "platform" }), e })(); const In = !1; let Vn = null; const fv = new A("AllowMultipleToken"), Bc = new A("PlatformDestroyListeners"), hv = new A("appBootstrapListener"); class pv { constructor(n, t) { this.name = n, this.token = t } } function mv(e, n, t = []) { const r = `Platform: ${n}`, o = new A(r); return (i = []) => { let s = $c(); if (!s || s.injector.get(fv, !1)) { const a = [...t, ...i, { provide: o, useValue: !0 }]; e ? e(a) : function HT(e) { if (Vn && !Vn.get(fv, !1)) throw new b(400, !1); Vn = e; const n = e.get(vv); (function gv(e) { const n = e.get(iv, null); n && n.forEach(t => t()) })(e) }(function yv(e = [], n) { return Jt.create({ name: n, providers: [{ provide: Iu, useValue: "platform" }, { provide: Bc, useValue: new Set([() => Vn = null]) }, ...e] }) }(a, r)) } return function GT(e) { const n = $c(); if (!n) throw new b(401, !1); return n }() } } function $c() { return Vn?.get(vv) ?? null } let vv = (() => { class e { constructor(t) { this._injector = t, this._modules = [], this._destroyListeners = [], this._destroyed = !1 } bootstrapModuleFactory(t, r) { const o = function Dv(e, n) { let t; return t = "noop" === e ? new jT : ("zone.js" === e ? void 0 : e) || new De(n), t }(r?.ngZone, function _v(e) { return { enableLongStackTrace: !1, shouldCoalesceEventChangeDetection: !(!e || !e.ngZoneEventCoalescing) || !1, shouldCoalesceRunChangeDetection: !(!e || !e.ngZoneRunCoalescing) || !1 } }(r)), i = [{ provide: De, useValue: o }]; return o.run(() => { const s = Jt.create({ providers: i, parent: this.injector, name: t.moduleType.name }), a = t.create(s), l = a.injector.get(Wr, null); if (!l) throw new b(402, !1); return o.runOutsideAngular(() => { const u = o.onError.subscribe({ next: c => { l.handleError(c) } }); a.onDestroy(() => { la(this._modules, a), u.unsubscribe() }) }), function Cv(e, n, t) { try { const r = t(); return ii(r) ? r.catch(o => { throw n.runOutsideAngular(() => e.handleError(o)), o }) : r } catch (r) { throw n.runOutsideAngular(() => e.handleError(r)), r } }(l, o, () => { const u = a.injector.get(ia); return u.runInitializers(), u.donePromise.then(() => (function zm(e) { wt(e, "Expected localeId to be defined"), "string" == typeof e && (Hm = e.toLowerCase().replace(/_/g, "-")) }(a.injector.get(Mn, ao) || ao), this._moduleDoBootstrap(a), a)) }) }) } bootstrapModule(t, r = []) { const o = wv({}, r); return function $T(e, n, t) { const r = new mc(t); return Promise.resolve(r) }(0, 0, t).then(i => this.bootstrapModuleFactory(i, o)) } _moduleDoBootstrap(t) { const r = t.injector.get(aa); if (t._bootstrapComponents.length > 0) t._bootstrapComponents.forEach(o => r.bootstrap(o)); else { if (!t.instance.ngDoBootstrap) throw new b(-403, !1); t.instance.ngDoBootstrap(r) } this._modules.push(t) } onDestroy(t) { this._destroyListeners.push(t) } get injector() { return this._injector } destroy() { if (this._destroyed) throw new b(404, !1); this._modules.slice().forEach(r => r.destroy()), this._destroyListeners.forEach(r => r()); const t = this._injector.get(Bc, null); t && (t.forEach(r => r()), t.clear()), this._destroyed = !0 } get destroyed() { return this._destroyed } } return e.\u0275fac = function (t) { return new (t || e)(T(Jt)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "platform" }), e })(); function wv(e, n) { return Array.isArray(n) ? n.reduce(wv, e) : { ...e, ...n } } let aa = (() => { class e { get destroyed() { return this._destroyed } get injector() { return this._injector } constructor(t, r, o) { this._zone = t, this._injector = r, this._exceptionHandler = o, this._bootstrapListeners = [], this._views = [], this._runningTick = !1, this._stable = !0, this._destroyed = !1, this._destroyListeners = [], this.componentTypes = [], this.components = [], this._onMicrotaskEmptySubscription = this._zone.onMicrotaskEmpty.subscribe({ next: () => { this._zone.run(() => { this.tick() }) } }); const i = new ve(a => { this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks, this._zone.runOutsideAngular(() => { a.next(this._stable), a.complete() }) }), s = new ve(a => { let l; this._zone.runOutsideAngular(() => { l = this._zone.onStable.subscribe(() => { De.assertNotInAngularZone(), Fc(() => { !this._stable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks && (this._stable = !0, a.next(!0)) }) }) }); const u = this._zone.onUnstable.subscribe(() => { De.assertInAngularZone(), this._stable && (this._stable = !1, this._zone.runOutsideAngular(() => { a.next(!1) })) }); return () => { l.unsubscribe(), u.unsubscribe() } }); this.isStable = function Ww(...e) { const n = Ao(e), t = function jw(e, n) { return "number" == typeof ml(e) ? e.pop() : n }(e, 1 / 0), r = e; return r.length ? 1 === r.length ? Ct(r[0]) : Er(t)(Se(r, n)) : Ht }(i, s.pipe(function qw(e = {}) { const { connector: n = (() => new hn), resetOnError: t = !0, resetOnComplete: r = !0, resetOnRefCountZero: o = !0 } = e; return i => { let s, a, l, u = 0, c = !1, d = !1; const f = () => { a?.unsubscribe(), a = void 0 }, h = () => { f(), s = l = void 0, c = d = !1 }, p = () => { const g = s; h(), g?.unsubscribe() }; return Oe((g, m) => { u++, !d && !c && f(); const D = l = l ?? n(); m.add(() => { u--, 0 === u && !d && !c && (a = yl(p, o)) }), D.subscribe(m), !s && u > 0 && (s = new Io({ next: S => D.next(S), error: S => { d = !0, f(), a = yl(h, t, S), D.error(S) }, complete: () => { c = !0, f(), a = yl(h, r), D.complete() } }), Ct(g).subscribe(s)) })(i) } }())) } bootstrap(t, r) { const o = t instanceof Xp; if (!this._injector.get(ia).done) { !o && function Mr(e) { const n = ne(e) || He(e) || it(e); return null !== n && n.standalone }(t); throw new b(405, In) } let s; s = o ? t : this._injector.get(Jo).resolveComponentFactory(t), this.componentTypes.push(s.componentType); const a = function UT(e) { return e.isBoundToModule }(s) ? void 0 : this._injector.get(lo), u = s.create(Jt.NULL, [], r || s.selector, a), c = u.location.nativeElement, d = u.injector.get(dv, null); return d?.registerApplication(c), u.onDestroy(() => { this.detachView(u.hostView), la(this.components, u), d?.unregisterApplication(c) }), this._loadComponent(u), u } tick() { if (this._runningTick) throw new b(101, !1); try { this._runningTick = !0; for (let t of this._views) t.detectChanges() } catch (t) { this._zone.runOutsideAngular(() => this._exceptionHandler.handleError(t)) } finally { this._runningTick = !1 } } attachView(t) { const r = t; this._views.push(r), r.attachToAppRef(this) } detachView(t) { const r = t; la(this._views, r), r.detachFromAppRef() } _loadComponent(t) { this.attachView(t.hostView), this.tick(), this.components.push(t); const r = this._injector.get(hv, []); r.push(...this._bootstrapListeners), r.forEach(o => o(t)) } ngOnDestroy() { if (!this._destroyed) try { this._destroyListeners.forEach(t => t()), this._views.slice().forEach(t => t.destroy()), this._onMicrotaskEmptySubscription.unsubscribe() } finally { this._destroyed = !0, this._views = [], this._bootstrapListeners = [], this._destroyListeners = [] } } onDestroy(t) { return this._destroyListeners.push(t), () => la(this._destroyListeners, t) } destroy() { if (this._destroyed) throw new b(406, !1); const t = this._injector; t.destroy && !t.destroyed && t.destroy() } get viewCount() { return this._views.length } warnIfDestroyed() { } } return e.\u0275fac = function (t) { return new (t || e)(T(De), T(Xt), T(Wr)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); function la(e, n) { const t = e.indexOf(n); t > -1 && e.splice(t, 1) } let ua = (() => { class e { } return e.__NG_ELEMENT_ID__ = qT, e })(); function qT(e) { return function KT(e, n, t) { if (ko(e) && !t) { const r = mt(e.index, n); return new ni(r, r) } return 47 & e.type ? new ni(n[Ge], n) : null }(Ve(), C(), 16 == (16 & e)) } class Iv { constructor() { } supports(n) { return Gs(n) } create(n) { return new e1(n) } } const JT = (e, n) => n; class e1 { constructor(n) { this.length = 0, this._linkedRecords = null, this._unlinkedRecords = null, this._previousItHead = null, this._itHead = null, this._itTail = null, this._additionsHead = null, this._additionsTail = null, this._movesHead = null, this._movesTail = null, this._removalsHead = null, this._removalsTail = null, this._identityChangesHead = null, this._identityChangesTail = null, this._trackByFn = n || JT } forEachItem(n) { let t; for (t = this._itHead; null !== t; t = t._next)n(t) } forEachOperation(n) { let t = this._itHead, r = this._removalsHead, o = 0, i = null; for (; t || r;) { const s = !r || t && t.currentIndex < Tv(r, o, i) ? t : r, a = Tv(s, o, i), l = s.currentIndex; if (s === r) o--, r = r._nextRemoved; else if (t = t._next, null == s.previousIndex) o++; else { i || (i = []); const u = a - o, c = l - o; if (u != c) { for (let f = 0; f < u; f++) { const h = f < i.length ? i[f] : i[f] = 0, p = h + f; c <= p && p < u && (i[f] = h + 1) } i[s.previousIndex] = c - u } } a !== l && n(s, a, l) } } forEachPreviousItem(n) { let t; for (t = this._previousItHead; null !== t; t = t._nextPrevious)n(t) } forEachAddedItem(n) { let t; for (t = this._additionsHead; null !== t; t = t._nextAdded)n(t) } forEachMovedItem(n) { let t; for (t = this._movesHead; null !== t; t = t._nextMoved)n(t) } forEachRemovedItem(n) { let t; for (t = this._removalsHead; null !== t; t = t._nextRemoved)n(t) } forEachIdentityChange(n) { let t; for (t = this._identityChangesHead; null !== t; t = t._nextIdentityChange)n(t) } diff(n) { if (null == n && (n = []), !Gs(n)) throw new b(900, !1); return this.check(n) ? this : null } onDestroy() { } check(n) { this._reset(); let o, i, s, t = this._itHead, r = !1; if (Array.isArray(n)) { this.length = n.length; for (let a = 0; a < this.length; a++)i = n[a], s = this._trackByFn(a, i), null !== t && Object.is(t.trackById, s) ? (r && (t = this._verifyReinsertion(t, i, s, a)), Object.is(t.item, i) || this._addIdentityChange(t, i)) : (t = this._mismatch(t, i, s, a), r = !0), t = t._next } else o = 0, function IM(e, n) { if (Array.isArray(e)) for (let t = 0; t < e.length; t++)n(e[t]); else { const t = e[Symbol.iterator](); let r; for (; !(r = t.next()).done;)n(r.value) } }(n, a => { s = this._trackByFn(o, a), null !== t && Object.is(t.trackById, s) ? (r && (t = this._verifyReinsertion(t, a, s, o)), Object.is(t.item, a) || this._addIdentityChange(t, a)) : (t = this._mismatch(t, a, s, o), r = !0), t = t._next, o++ }), this.length = o; return this._truncate(t), this.collection = n, this.isDirty } get isDirty() { return null !== this._additionsHead || null !== this._movesHead || null !== this._removalsHead || null !== this._identityChangesHead } _reset() { if (this.isDirty) { let n; for (n = this._previousItHead = this._itHead; null !== n; n = n._next)n._nextPrevious = n._next; for (n = this._additionsHead; null !== n; n = n._nextAdded)n.previousIndex = n.currentIndex; for (this._additionsHead = this._additionsTail = null, n = this._movesHead; null !== n; n = n._nextMoved)n.previousIndex = n.currentIndex; this._movesHead = this._movesTail = null, this._removalsHead = this._removalsTail = null, this._identityChangesHead = this._identityChangesTail = null } } _mismatch(n, t, r, o) { let i; return null === n ? i = this._itTail : (i = n._prev, this._remove(n)), null !== (n = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(r, null)) ? (Object.is(n.item, t) || this._addIdentityChange(n, t), this._reinsertAfter(n, i, o)) : null !== (n = null === this._linkedRecords ? null : this._linkedRecords.get(r, o)) ? (Object.is(n.item, t) || this._addIdentityChange(n, t), this._moveAfter(n, i, o)) : n = this._addAfter(new t1(t, r), i, o), n } _verifyReinsertion(n, t, r, o) { let i = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(r, null); return null !== i ? n = this._reinsertAfter(i, n._prev, o) : n.currentIndex != o && (n.currentIndex = o, this._addToMoves(n, o)), n } _truncate(n) { for (; null !== n;) { const t = n._next; this._addToRemovals(this._unlink(n)), n = t } null !== this._unlinkedRecords && this._unlinkedRecords.clear(), null !== this._additionsTail && (this._additionsTail._nextAdded = null), null !== this._movesTail && (this._movesTail._nextMoved = null), null !== this._itTail && (this._itTail._next = null), null !== this._removalsTail && (this._removalsTail._nextRemoved = null), null !== this._identityChangesTail && (this._identityChangesTail._nextIdentityChange = null) } _reinsertAfter(n, t, r) { null !== this._unlinkedRecords && this._unlinkedRecords.remove(n); const o = n._prevRemoved, i = n._nextRemoved; return null === o ? this._removalsHead = i : o._nextRemoved = i, null === i ? this._removalsTail = o : i._prevRemoved = o, this._insertAfter(n, t, r), this._addToMoves(n, r), n } _moveAfter(n, t, r) { return this._unlink(n), this._insertAfter(n, t, r), this._addToMoves(n, r), n } _addAfter(n, t, r) { return this._insertAfter(n, t, r), this._additionsTail = null === this._additionsTail ? this._additionsHead = n : this._additionsTail._nextAdded = n, n } _insertAfter(n, t, r) { const o = null === t ? this._itHead : t._next; return n._next = o, n._prev = t, null === o ? this._itTail = n : o._prev = n, null === t ? this._itHead = n : t._next = n, null === this._linkedRecords && (this._linkedRecords = new Av), this._linkedRecords.put(n), n.currentIndex = r, n } _remove(n) { return this._addToRemovals(this._unlink(n)) } _unlink(n) { null !== this._linkedRecords && this._linkedRecords.remove(n); const t = n._prev, r = n._next; return null === t ? this._itHead = r : t._next = r, null === r ? this._itTail = t : r._prev = t, n } _addToMoves(n, t) { return n.previousIndex === t || (this._movesTail = null === this._movesTail ? this._movesHead = n : this._movesTail._nextMoved = n), n } _addToRemovals(n) { return null === this._unlinkedRecords && (this._unlinkedRecords = new Av), this._unlinkedRecords.put(n), n.currentIndex = null, n._nextRemoved = null, null === this._removalsTail ? (this._removalsTail = this._removalsHead = n, n._prevRemoved = null) : (n._prevRemoved = this._removalsTail, this._removalsTail = this._removalsTail._nextRemoved = n), n } _addIdentityChange(n, t) { return n.item = t, this._identityChangesTail = null === this._identityChangesTail ? this._identityChangesHead = n : this._identityChangesTail._nextIdentityChange = n, n } } class t1 { constructor(n, t) { this.item = n, this.trackById = t, this.currentIndex = null, this.previousIndex = null, this._nextPrevious = null, this._prev = null, this._next = null, this._prevDup = null, this._nextDup = null, this._prevRemoved = null, this._nextRemoved = null, this._nextAdded = null, this._nextMoved = null, this._nextIdentityChange = null } } class n1 { constructor() { this._head = null, this._tail = null } add(n) { null === this._head ? (this._head = this._tail = n, n._nextDup = null, n._prevDup = null) : (this._tail._nextDup = n, n._prevDup = this._tail, n._nextDup = null, this._tail = n) } get(n, t) { let r; for (r = this._head; null !== r; r = r._nextDup)if ((null === t || t <= r.currentIndex) && Object.is(r.trackById, n)) return r; return null } remove(n) { const t = n._prevDup, r = n._nextDup; return null === t ? this._head = r : t._nextDup = r, null === r ? this._tail = t : r._prevDup = t, null === this._head } } class Av { constructor() { this.map = new Map } put(n) { const t = n.trackById; let r = this.map.get(t); r || (r = new n1, this.map.set(t, r)), r.add(n) } get(n, t) { const o = this.map.get(n); return o ? o.get(n, t) : null } remove(n) { const t = n.trackById; return this.map.get(t).remove(n) && this.map.delete(t), n } get isEmpty() { return 0 === this.map.size } clear() { this.map.clear() } } function Tv(e, n, t) { const r = e.previousIndex; if (null === r) return r; let o = 0; return t && r < t.length && (o = t[r]), r + n + o } class xv { constructor() { } supports(n) { return n instanceof Map || Xu(n) } create() { return new r1 } } class r1 { constructor() { this._records = new Map, this._mapHead = null, this._appendAfter = null, this._previousMapHead = null, this._changesHead = null, this._changesTail = null, this._additionsHead = null, this._additionsTail = null, this._removalsHead = null, this._removalsTail = null } get isDirty() { return null !== this._additionsHead || null !== this._changesHead || null !== this._removalsHead } forEachItem(n) { let t; for (t = this._mapHead; null !== t; t = t._next)n(t) } forEachPreviousItem(n) { let t; for (t = this._previousMapHead; null !== t; t = t._nextPrevious)n(t) } forEachChangedItem(n) { let t; for (t = this._changesHead; null !== t; t = t._nextChanged)n(t) } forEachAddedItem(n) { let t; for (t = this._additionsHead; null !== t; t = t._nextAdded)n(t) } forEachRemovedItem(n) { let t; for (t = this._removalsHead; null !== t; t = t._nextRemoved)n(t) } diff(n) { if (n) { if (!(n instanceof Map || Xu(n))) throw new b(900, !1) } else n = new Map; return this.check(n) ? this : null } onDestroy() { } check(n) { this._reset(); let t = this._mapHead; if (this._appendAfter = null, this._forEach(n, (r, o) => { if (t && t.key === o) this._maybeAddToChanges(t, r), this._appendAfter = t, t = t._next; else { const i = this._getOrCreateRecordForKey(o, r); t = this._insertBeforeOrAppend(t, i) } }), t) { t._prev && (t._prev._next = null), this._removalsHead = t; for (let r = t; null !== r; r = r._nextRemoved)r === this._mapHead && (this._mapHead = null), this._records.delete(r.key), r._nextRemoved = r._next, r.previousValue = r.currentValue, r.currentValue = null, r._prev = null, r._next = null } return this._changesTail && (this._changesTail._nextChanged = null), this._additionsTail && (this._additionsTail._nextAdded = null), this.isDirty } _insertBeforeOrAppend(n, t) { if (n) { const r = n._prev; return t._next = n, t._prev = r, n._prev = t, r && (r._next = t), n === this._mapHead && (this._mapHead = t), this._appendAfter = n, n } return this._appendAfter ? (this._appendAfter._next = t, t._prev = this._appendAfter) : this._mapHead = t, this._appendAfter = t, null } _getOrCreateRecordForKey(n, t) { if (this._records.has(n)) { const o = this._records.get(n); this._maybeAddToChanges(o, t); const i = o._prev, s = o._next; return i && (i._next = s), s && (s._prev = i), o._next = null, o._prev = null, o } const r = new o1(n); return this._records.set(n, r), r.currentValue = t, this._addToAdditions(r), r } _reset() { if (this.isDirty) { let n; for (this._previousMapHead = this._mapHead, n = this._previousMapHead; null !== n; n = n._next)n._nextPrevious = n._next; for (n = this._changesHead; null !== n; n = n._nextChanged)n.previousValue = n.currentValue; for (n = this._additionsHead; null != n; n = n._nextAdded)n.previousValue = n.currentValue; this._changesHead = this._changesTail = null, this._additionsHead = this._additionsTail = null, this._removalsHead = null } } _maybeAddToChanges(n, t) { Object.is(t, n.currentValue) || (n.previousValue = n.currentValue, n.currentValue = t, this._addToChanges(n)) } _addToAdditions(n) { null === this._additionsHead ? this._additionsHead = this._additionsTail = n : (this._additionsTail._nextAdded = n, this._additionsTail = n) } _addToChanges(n) { null === this._changesHead ? this._changesHead = this._changesTail = n : (this._changesTail._nextChanged = n, this._changesTail = n) } _forEach(n, t) { n instanceof Map ? n.forEach(t) : Object.keys(n).forEach(r => t(n[r], r)) } } class o1 { constructor(n) { this.key = n, this.previousValue = null, this.currentValue = null, this._nextPrevious = null, this._next = null, this._prev = null, this._nextAdded = null, this._nextRemoved = null, this._nextChanged = null } } function Pv() { return new fa([new Iv]) } let fa = (() => { class e { constructor(t) { this.factories = t } static create(t, r) { if (null != r) { const o = r.factories.slice(); t = t.concat(o) } return new e(t) } static extend(t) { return { provide: e, useFactory: r => e.create(t, r || Pv()), deps: [[e, new zo, new Ho]] } } find(t) { const r = this.factories.find(o => o.supports(t)); if (null != r) return r; throw new b(901, !1) } } return e.\u0275prov = x({ token: e, providedIn: "root", factory: Pv }), e })(); function Rv() { return new yi([new xv]) } let yi = (() => { class e { constructor(t) { this.factories = t } static create(t, r) { if (r) { const o = r.factories.slice(); t = t.concat(o) } return new e(t) } static extend(t) { return { provide: e, useFactory: r => e.create(t, r || Rv()), deps: [[e, new zo, new Ho]] } } find(t) { const r = this.factories.find(o => o.supports(t)); if (r) return r; throw new b(901, !1) } } return e.\u0275prov = x({ token: e, providedIn: "root", factory: Rv }), e })(); const a1 = mv(null, "core", []); let l1 = (() => { class e { constructor(t) { } } return e.\u0275fac = function (t) { return new (t || e)(T(aa)) }, e.\u0275mod = ft({ type: e }), e.\u0275inj = ot({}), e })(); function fo(e) { return "boolean" == typeof e ? e : null != e && "false" !== e } let Wc = null; function An() { return Wc } class d1 { } const nt = new A("DocumentToken"); let qc = (() => { class e { historyGo(t) { throw new Error("Not implemented") } } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275prov = x({ token: e, factory: function () { return function f1() { return T(Nv) }() }, providedIn: "platform" }), e })(); const h1 = new A("Location Initialized"); let Nv = (() => { class e extends qc { constructor(t) { super(), this._doc = t, this._location = window.location, this._history = window.history } getBaseHrefFromDOM() { return An().getBaseHref(this._doc) } onPopState(t) { const r = An().getGlobalEventTarget(this._doc, "window"); return r.addEventListener("popstate", t, !1), () => r.removeEventListener("popstate", t) } onHashChange(t) { const r = An().getGlobalEventTarget(this._doc, "window"); return r.addEventListener("hashchange", t, !1), () => r.removeEventListener("hashchange", t) } get href() { return this._location.href } get protocol() { return this._location.protocol } get hostname() { return this._location.hostname } get port() { return this._location.port } get pathname() { return this._location.pathname } get search() { return this._location.search } get hash() { return this._location.hash } set pathname(t) { this._location.pathname = t } pushState(t, r, o) { Fv() ? this._history.pushState(t, r, o) : this._location.hash = o } replaceState(t, r, o) { Fv() ? this._history.replaceState(t, r, o) : this._location.hash = o } forward() { this._history.forward() } back() { this._history.back() } historyGo(t = 0) { this._history.go(t) } getState() { return this._history.state } } return e.\u0275fac = function (t) { return new (t || e)(T(nt)) }, e.\u0275prov = x({ token: e, factory: function () { return function p1() { return new Nv(T(nt)) }() }, providedIn: "platform" }), e })(); function Fv() { return !!window.history.pushState } function Kc(e, n) { if (0 == e.length) return n; if (0 == n.length) return e; let t = 0; return e.endsWith("/") && t++, n.startsWith("/") && t++, 2 == t ? e + n.substring(1) : 1 == t ? e + n : e + "/" + n } function Ov(e) { const n = e.match(/#|\?|$/), t = n && n.index || e.length; return e.slice(0, t - ("/" === e[t - 1] ? 1 : 0)) + e.slice(t) } function Tn(e) { return e && "?" !== e[0] ? "?" + e : e } let hr = (() => { class e { historyGo(t) { throw new Error("Not implemented") } } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275prov = x({ token: e, factory: function () { return W(Lv) }, providedIn: "root" }), e })(); const kv = new A("appBaseHref"); let Lv = (() => { class e extends hr { constructor(t, r) { super(), this._platformLocation = t, this._removeListenerFns = [], this._baseHref = r ?? this._platformLocation.getBaseHrefFromDOM() ?? W(nt).location?.origin ?? "" } ngOnDestroy() { for (; this._removeListenerFns.length;)this._removeListenerFns.pop()() } onPopState(t) { this._removeListenerFns.push(this._platformLocation.onPopState(t), this._platformLocation.onHashChange(t)) } getBaseHref() { return this._baseHref } prepareExternalUrl(t) { return Kc(this._baseHref, t) } path(t = !1) { const r = this._platformLocation.pathname + Tn(this._platformLocation.search), o = this._platformLocation.hash; return o && t ? `${r}${o}` : r } pushState(t, r, o, i) { const s = this.prepareExternalUrl(o + Tn(i)); this._platformLocation.pushState(t, r, s) } replaceState(t, r, o, i) { const s = this.prepareExternalUrl(o + Tn(i)); this._platformLocation.replaceState(t, r, s) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } getState() { return this._platformLocation.getState() } historyGo(t = 0) { this._platformLocation.historyGo?.(t) } } return e.\u0275fac = function (t) { return new (t || e)(T(qc), T(kv, 8)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(), g1 = (() => { class e extends hr { constructor(t, r) { super(), this._platformLocation = t, this._baseHref = "", this._removeListenerFns = [], null != r && (this._baseHref = r) } ngOnDestroy() { for (; this._removeListenerFns.length;)this._removeListenerFns.pop()() } onPopState(t) { this._removeListenerFns.push(this._platformLocation.onPopState(t), this._platformLocation.onHashChange(t)) } getBaseHref() { return this._baseHref } path(t = !1) { let r = this._platformLocation.hash; return null == r && (r = "#"), r.length > 0 ? r.substring(1) : r } prepareExternalUrl(t) { const r = Kc(this._baseHref, t); return r.length > 0 ? "#" + r : r } pushState(t, r, o, i) { let s = this.prepareExternalUrl(o + Tn(i)); 0 == s.length && (s = this._platformLocation.pathname), this._platformLocation.pushState(t, r, s) } replaceState(t, r, o, i) { let s = this.prepareExternalUrl(o + Tn(i)); 0 == s.length && (s = this._platformLocation.pathname), this._platformLocation.replaceState(t, r, s) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } getState() { return this._platformLocation.getState() } historyGo(t = 0) { this._platformLocation.historyGo?.(t) } } return e.\u0275fac = function (t) { return new (t || e)(T(qc), T(kv, 8)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac }), e })(), Zc = (() => { class e { constructor(t) { this._subject = new pe, this._urlChangeListeners = [], this._urlChangeSubscription = null, this._locationStrategy = t; const r = this._locationStrategy.getBaseHref(); this._basePath = function v1(e) { if (new RegExp("^(https?:)?//").test(e)) { const [, t] = e.split(/\/\/[^\/]+/); return t } return e }(Ov(Vv(r))), this._locationStrategy.onPopState(o => { this._subject.emit({ url: this.path(!0), pop: !0, state: o.state, type: o.type }) }) } ngOnDestroy() { this._urlChangeSubscription?.unsubscribe(), this._urlChangeListeners = [] } path(t = !1) { return this.normalize(this._locationStrategy.path(t)) } getState() { return this._locationStrategy.getState() } isCurrentPathEqualTo(t, r = "") { return this.path() == this.normalize(t + Tn(r)) } normalize(t) { return e.stripTrailingSlash(function y1(e, n) { if (!e || !n.startsWith(e)) return n; const t = n.substring(e.length); return "" === t || ["/", ";", "?", "#"].includes(t[0]) ? t : n }(this._basePath, Vv(t))) } prepareExternalUrl(t) { return t && "/" !== t[0] && (t = "/" + t), this._locationStrategy.prepareExternalUrl(t) } go(t, r = "", o = null) { this._locationStrategy.pushState(o, "", t, r), this._notifyUrlChangeListeners(this.prepareExternalUrl(t + Tn(r)), o) } replaceState(t, r = "", o = null) { this._locationStrategy.replaceState(o, "", t, r), this._notifyUrlChangeListeners(this.prepareExternalUrl(t + Tn(r)), o) } forward() { this._locationStrategy.forward() } back() { this._locationStrategy.back() } historyGo(t = 0) { this._locationStrategy.historyGo?.(t) } onUrlChange(t) { return this._urlChangeListeners.push(t), this._urlChangeSubscription || (this._urlChangeSubscription = this.subscribe(r => { this._notifyUrlChangeListeners(r.url, r.state) })), () => { const r = this._urlChangeListeners.indexOf(t); this._urlChangeListeners.splice(r, 1), 0 === this._urlChangeListeners.length && (this._urlChangeSubscription?.unsubscribe(), this._urlChangeSubscription = null) } } _notifyUrlChangeListeners(t = "", r) { this._urlChangeListeners.forEach(o => o(t, r)) } subscribe(t, r, o) { return this._subject.subscribe({ next: t, error: r, complete: o }) } } return e.normalizeQueryParams = Tn, e.joinWithSlash = Kc, e.stripTrailingSlash = Ov, e.\u0275fac = function (t) { return new (t || e)(T(hr)) }, e.\u0275prov = x({ token: e, factory: function () { return function m1() { return new Zc(T(hr)) }() }, providedIn: "root" }), e })(); function Vv(e) { return e.replace(/\/index.html$/, "") } const jv = { ADP: [void 0, void 0, 0], AFN: [void 0, "\u060b", 0], ALL: [void 0, void 0, 0], AMD: [void 0, "\u058f", 2], AOA: [void 0, "Kz"], ARS: [void 0, "$"], AUD: ["A$", "$"], AZN: [void 0, "\u20bc"], BAM: [void 0, "KM"], BBD: [void 0, "$"], BDT: [void 0, "\u09f3"], BHD: [void 0, void 0, 3], BIF: [void 0, void 0, 0], BMD: [void 0, "$"], BND: [void 0, "$"], BOB: [void 0, "Bs"], BRL: ["R$"], BSD: [void 0, "$"], BWP: [void 0, "P"], BYN: [void 0, void 0, 2], BYR: [void 0, void 0, 0], BZD: [void 0, "$"], CAD: ["CA$", "$", 2], CHF: [void 0, void 0, 2], CLF: [void 0, void 0, 4], CLP: [void 0, "$", 0], CNY: ["CN\xa5", "\xa5"], COP: [void 0, "$", 2], CRC: [void 0, "\u20a1", 2], CUC: [void 0, "$"], CUP: [void 0, "$"], CZK: [void 0, "K\u010d", 2], DJF: [void 0, void 0, 0], DKK: [void 0, "kr", 2], DOP: [void 0, "$"], EGP: [void 0, "E\xa3"], ESP: [void 0, "\u20a7", 0], EUR: ["\u20ac"], FJD: [void 0, "$"], FKP: [void 0, "\xa3"], GBP: ["\xa3"], GEL: [void 0, "\u20be"], GHS: [void 0, "GH\u20b5"], GIP: [void 0, "\xa3"], GNF: [void 0, "FG", 0], GTQ: [void 0, "Q"], GYD: [void 0, "$", 2], HKD: ["HK$", "$"], HNL: [void 0, "L"], HRK: [void 0, "kn"], HUF: [void 0, "Ft", 2], IDR: [void 0, "Rp", 2], ILS: ["\u20aa"], INR: ["\u20b9"], IQD: [void 0, void 0, 0], IRR: [void 0, void 0, 0], ISK: [void 0, "kr", 0], ITL: [void 0, void 0, 0], JMD: [void 0, "$"], JOD: [void 0, void 0, 3], JPY: ["\xa5", void 0, 0], KHR: [void 0, "\u17db"], KMF: [void 0, "CF", 0], KPW: [void 0, "\u20a9", 0], KRW: ["\u20a9", void 0, 0], KWD: [void 0, void 0, 3], KYD: [void 0, "$"], KZT: [void 0, "\u20b8"], LAK: [void 0, "\u20ad", 0], LBP: [void 0, "L\xa3", 0], LKR: [void 0, "Rs"], LRD: [void 0, "$"], LTL: [void 0, "Lt"], LUF: [void 0, void 0, 0], LVL: [void 0, "Ls"], LYD: [void 0, void 0, 3], MGA: [void 0, "Ar", 0], MGF: [void 0, void 0, 0], MMK: [void 0, "K", 0], MNT: [void 0, "\u20ae", 2], MRO: [void 0, void 0, 0], MUR: [void 0, "Rs", 2], MXN: ["MX$", "$"], MYR: [void 0, "RM"], NAD: [void 0, "$"], NGN: [void 0, "\u20a6"], NIO: [void 0, "C$"], NOK: [void 0, "kr", 2], NPR: [void 0, "Rs"], NZD: ["NZ$", "$"], OMR: [void 0, void 0, 3], PHP: ["\u20b1"], PKR: [void 0, "Rs", 2], PLN: [void 0, "z\u0142"], PYG: [void 0, "\u20b2", 0], RON: [void 0, "lei"], RSD: [void 0, void 0, 0], RUB: [void 0, "\u20bd"], RWF: [void 0, "RF", 0], SBD: [void 0, "$"], SEK: [void 0, "kr", 2], SGD: [void 0, "$"], SHP: [void 0, "\xa3"], SLE: [void 0, void 0, 2], SLL: [void 0, void 0, 0], SOS: [void 0, void 0, 0], SRD: [void 0, "$"], SSP: [void 0, "\xa3"], STD: [void 0, void 0, 0], STN: [void 0, "Db"], SYP: [void 0, "\xa3", 0], THB: [void 0, "\u0e3f"], TMM: [void 0, void 0, 0], TND: [void 0, void 0, 3], TOP: [void 0, "T$"], TRL: [void 0, void 0, 0], TRY: [void 0, "\u20ba"], TTD: [void 0, "$"], TWD: ["NT$", "$", 2], TZS: [void 0, void 0, 2], UAH: [void 0, "\u20b4"], UGX: [void 0, void 0, 0], USD: ["$"], UYI: [void 0, void 0, 0], UYU: [void 0, "$"], UYW: [void 0, void 0, 4], UZS: [void 0, void 0, 2], VEF: [void 0, "Bs", 2], VND: ["\u20ab", void 0, 0], VUV: [void 0, void 0, 0], XAF: ["FCFA", void 0, 0], XCD: ["EC$", "$"], XOF: ["F\u202fCFA", void 0, 0], XPF: ["CFPF", void 0, 0], XXX: ["\xa4"], YER: [void 0, void 0, 0], ZAR: [void 0, "R"], ZMK: [void 0, void 0, 0], ZMW: [void 0, "ZK"], ZWD: [void 0, void 0, 0] }; var ct = (() => ((ct = ct || {})[ct.Decimal = 0] = "Decimal", ct[ct.Percent = 1] = "Percent", ct[ct.Currency = 2] = "Currency", ct[ct.Scientific = 3] = "Scientific", ct))(), N = (() => ((N = N || {})[N.Decimal = 0] = "Decimal", N[N.Group = 1] = "Group", N[N.List = 2] = "List", N[N.PercentSign = 3] = "PercentSign", N[N.PlusSign = 4] = "PlusSign", N[N.MinusSign = 5] = "MinusSign", N[N.Exponential = 6] = "Exponential", N[N.SuperscriptingExponent = 7] = "SuperscriptingExponent", N[N.PerMille = 8] = "PerMille", N[N.Infinity = 9] = "Infinity", N[N.NaN = 10] = "NaN", N[N.TimeSeparator = 11] = "TimeSeparator", N[N.CurrencyDecimal = 12] = "CurrencyDecimal", N[N.CurrencyGroup = 13] = "CurrencyGroup", N))(); function At(e, n) { const t = et(e), r = t[M.NumberSymbols][n]; if (typeof r > "u") { if (n === N.CurrencyDecimal) return t[M.NumberSymbols][N.Decimal]; if (n === N.CurrencyGroup) return t[M.NumberSymbols][N.Group] } return r } const T1 = 2, z1 = /^(\d+)?\.((\d+)(-(\d+))?)?$/, zv = 22, Ca = ".", _i = "0", G1 = ";", W1 = ",", ed = "#", Gv = "\xa4"; function K1(e, n, t, r, o) { const s = function nd(e, n = "-") { const t = { minInt: 1, minFrac: 0, maxFrac: 0, posPre: "", posSuf: "", negPre: "", negSuf: "", gSize: 0, lgSize: 0 }, r = e.split(G1), o = r[0], i = r[1], s = -1 !== o.indexOf(Ca) ? o.split(Ca) : [o.substring(0, o.lastIndexOf(_i) + 1), o.substring(o.lastIndexOf(_i) + 1)], a = s[0], l = s[1] || ""; t.posPre = a.substring(0, a.indexOf(ed)); for (let c = 0; c < l.length; c++) { const d = l.charAt(c); d === _i ? t.minFrac = t.maxFrac = c + 1 : d === ed ? t.maxFrac = c + 1 : t.posSuf += d } const u = a.split(W1); if (t.gSize = u[1] ? u[1].length : 0, t.lgSize = u[2] || u[1] ? (u[2] || u[1]).length : 0, i) { const c = o.length - t.posPre.length - t.posSuf.length, d = i.indexOf(ed); t.negPre = i.substring(0, d).replace(/'/g, ""), t.negSuf = i.slice(d + c).replace(/'/g, "") } else t.negPre = n + t.posPre, t.negSuf = t.posSuf; return t }(function Yc(e, n) { return et(e)[M.NumberFormats][n] }(n, ct.Currency), At(n, N.MinusSign)); return s.minFrac = function x1(e) { let n; const t = jv[e]; return t && (n = t[2]), "number" == typeof n ? n : T1 }(r), s.maxFrac = s.minFrac, function td(e, n, t, r, o, i, s = !1) { let a = "", l = !1; if (isFinite(e)) { let u = function X1(e) { let r, o, i, s, a, n = Math.abs(e) + "", t = 0; for ((o = n.indexOf(Ca)) > -1 && (n = n.replace(Ca, "")), (i = n.search(/e/i)) > 0 ? (o < 0 && (o = i), o += +n.slice(i + 1), n = n.substring(0, i)) : o < 0 && (o = n.length), i = 0; n.charAt(i) === _i; i++); if (i === (a = n.length)) r = [0], o = 1; else { for (a--; n.charAt(a) === _i;)a--; for (o -= i, r = [], s = 0; i <= a; i++, s++)r[s] = Number(n.charAt(i)) } return o > zv && (r = r.splice(0, zv - 1), t = o - 1, o = 1), { digits: r, exponent: t, integerLen: o } }(e); s && (u = function Q1(e) { if (0 === e.digits[0]) return e; const n = e.digits.length - e.integerLen; return e.exponent ? e.exponent += 2 : (0 === n ? e.digits.push(0, 0) : 1 === n && e.digits.push(0), e.integerLen += 2), e }(u)); let c = n.minInt, d = n.minFrac, f = n.maxFrac; if (i) { const S = i.match(z1); if (null === S) throw new Error(`${i} is not a valid digit info`); const _ = S[1], F = S[3], ie = S[5]; null != _ && (c = rd(_)), null != F && (d = rd(F)), null != ie ? f = rd(ie) : null != F && d > f && (f = d) } !function J1(e, n, t) { if (n > t) throw new Error(`The minimum number of digits after fraction (${n}) is higher than the maximum (${t}).`); let r = e.digits, o = r.length - e.integerLen; const i = Math.min(Math.max(n, o), t); let s = i + e.integerLen, a = r[s]; if (s > 0) { r.splice(Math.max(e.integerLen, s)); for (let d = s; d < r.length; d++)r[d] = 0 } else { o = Math.max(0, o), e.integerLen = 1, r.length = Math.max(1, s = i + 1), r[0] = 0; for (let d = 1; d < s; d++)r[d] = 0 } if (a >= 5) if (s - 1 < 0) { for (let d = 0; d > s; d--)r.unshift(0), e.integerLen++; r.unshift(1), e.integerLen++ } else r[s - 1]++; for (; o < Math.max(0, i); o++)r.push(0); let l = 0 !== i; const u = n + e.integerLen, c = r.reduceRight(function (d, f, h, p) { return p[h] = (f += d) < 10 ? f : f - 10, l && (0 === p[h] && h >= u ? p.pop() : l = !1), f >= 10 ? 1 : 0 }, 0); c && (r.unshift(c), e.integerLen++) }(u, d, f); let h = u.digits, p = u.integerLen; const g = u.exponent; let m = []; for (l = h.every(S => !S); p < c; p++)h.unshift(0); for (; p < 0; p++)h.unshift(0); p > 0 ? m = h.splice(p, h.length) : (m = h, h = [0]); const D = []; for (h.length >= n.lgSize && D.unshift(h.splice(-n.lgSize, h.length).join("")); h.length > n.gSize;)D.unshift(h.splice(-n.gSize, h.length).join("")); h.length && D.unshift(h.join("")), a = D.join(At(t, r)), m.length && (a += At(t, o) + m.join("")), g && (a += At(t, N.Exponential) + "+" + g) } else a = At(t, N.Infinity); return a = e < 0 && !l ? n.negPre + a + n.negSuf : n.posPre + a + n.posSuf, a }(e, s, n, N.CurrencyGroup, N.CurrencyDecimal, o).replace(Gv, t).replace(Gv, "").trim() } function rd(e) { const n = parseInt(e); if (isNaN(n)) throw new Error("Invalid integer literal when parsing " + e); return n } function qv(e, n) { n = encodeURIComponent(n); for (const t of e.split(";")) { const r = t.indexOf("="), [o, i] = -1 == r ? [t, ""] : [t.slice(0, r), t.slice(r + 1)]; if (o.trim() === n) return decodeURIComponent(i) } return null } class rx { constructor(n, t, r, o) { this.$implicit = n, this.ngForOf = t, this.index = r, this.count = o } get first() { return 0 === this.index } get last() { return this.index === this.count - 1 } get even() { return this.index % 2 == 0 } get odd() { return !this.even } } let Di = (() => { class e { set ngForOf(t) { this._ngForOf = t, this._ngForOfDirty = !0 } set ngForTrackBy(t) { this._trackByFn = t } get ngForTrackBy() { return this._trackByFn } constructor(t, r, o) { this._viewContainer = t, this._template = r, this._differs = o, this._ngForOf = null, this._ngForOfDirty = !0, this._differ = null } set ngForTemplate(t) { t && (this._template = t) } ngDoCheck() { if (this._ngForOfDirty) { this._ngForOfDirty = !1; const t = this._ngForOf; !this._differ && t && (this._differ = this._differs.find(t).create(this.ngForTrackBy)) } if (this._differ) { const t = this._differ.diff(this._ngForOf); t && this._applyChanges(t) } } _applyChanges(t) { const r = this._viewContainer; t.forEachOperation((o, i, s) => { if (null == o.previousIndex) r.createEmbeddedView(this._template, new rx(o.item, this._ngForOf, -1, -1), null === s ? void 0 : s); else if (null == s) r.remove(null === i ? void 0 : i); else if (null !== i) { const a = r.get(i); r.move(a, s), Qv(a, o) } }); for (let o = 0, i = r.length; o < i; o++) { const a = r.get(o).context; a.index = o, a.count = i, a.ngForOf = this._ngForOf } t.forEachIdentityChange(o => { Qv(r.get(o.currentIndex), o) }) } static ngTemplateContextGuard(t, r) { return !0 } } return e.\u0275fac = function (t) { return new (t || e)(y(Vt), y(Sn), y(fa)) }, e.\u0275dir = V({ type: e, selectors: [["", "ngFor", "", "ngForOf", ""]], inputs: { ngForOf: "ngForOf", ngForTrackBy: "ngForTrackBy", ngForTemplate: "ngForTemplate" }, standalone: !0 }), e })(); function Qv(e, n) { e.context.$implicit = n.item } let Ci = (() => { class e { constructor(t, r) { this._viewContainer = t, this._context = new ix, this._thenTemplateRef = null, this._elseTemplateRef = null, this._thenViewRef = null, this._elseViewRef = null, this._thenTemplateRef = r } set ngIf(t) { this._context.$implicit = this._context.ngIf = t, this._updateView() } set ngIfThen(t) { Xv("ngIfThen", t), this._thenTemplateRef = t, this._thenViewRef = null, this._updateView() } set ngIfElse(t) { Xv("ngIfElse", t), this._elseTemplateRef = t, this._elseViewRef = null, this._updateView() } _updateView() { this._context.$implicit ? this._thenViewRef || (this._viewContainer.clear(), this._elseViewRef = null, this._thenTemplateRef && (this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context))) : this._elseViewRef || (this._viewContainer.clear(), this._thenViewRef = null, this._elseTemplateRef && (this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context))) } static ngTemplateContextGuard(t, r) { return !0 } } return e.\u0275fac = function (t) { return new (t || e)(y(Vt), y(Sn)) }, e.\u0275dir = V({ type: e, selectors: [["", "ngIf", ""]], inputs: { ngIf: "ngIf", ngIfThen: "ngIfThen", ngIfElse: "ngIfElse" }, standalone: !0 }), e })(); class ix { constructor() { this.$implicit = null, this.ngIf = null } } function Xv(e, n) { if (n && !n.createEmbeddedView) throw new Error(`${e} must be a TemplateRef, but received '${ae(n)}'.`) } let e_ = (() => { class e { constructor(t, r, o) { this._ngEl = t, this._differs = r, this._renderer = o, this._ngStyle = null, this._differ = null } set ngStyle(t) { this._ngStyle = t, !this._differ && t && (this._differ = this._differs.find(t).create()) } ngDoCheck() { if (this._differ) { const t = this._differ.diff(this._ngStyle); t && this._applyChanges(t) } } _setStyle(t, r) { const [o, i] = t.split("."), s = -1 === o.indexOf("-") ? void 0 : st.DashCase; null != r ? this._renderer.setStyle(this._ngEl.nativeElement, o, i ? `${r}${i}` : r, s) : this._renderer.removeStyle(this._ngEl.nativeElement, o, s) } _applyChanges(t) { t.forEachRemovedItem(r => this._setStyle(r.key, null)), t.forEachAddedItem(r => this._setStyle(r.key, r.currentValue)), t.forEachChangedItem(r => this._setStyle(r.key, r.currentValue)) } } return e.\u0275fac = function (t) { return new (t || e)(y(lt), y(yi), y(wn)) }, e.\u0275dir = V({ type: e, selectors: [["", "ngStyle", ""]], inputs: { ngStyle: "ngStyle" }, standalone: !0 }), e })(); let wa = (() => { class e { constructor(t, r = "USD") { this._locale = t, this._defaultCurrencyCode = r } transform(t, r = this._defaultCurrencyCode, o = "symbol", i, s) { if (!function ld(e) { return !(null == e || "" === e || e != e) }(t)) return null; s = s || this._locale, "boolean" == typeof o && (o = o ? "symbol" : "code"); let a = r || this._defaultCurrencyCode; "code" !== o && (a = "symbol" === o || "symbol-narrow" === o ? function A1(e, n, t = "en") { const r = function E1(e) { return et(e)[M.Currencies] }(t)[e] || jv[e] || [], o = r[1]; return "narrow" === n && "string" == typeof o ? o : r[0] || e }(a, "symbol" === o ? "wide" : "narrow", s) : o); try { return K1(function ud(e) { if ("string" == typeof e && !isNaN(Number(e) - parseFloat(e))) return Number(e); if ("number" != typeof e) throw new Error(`${e} is not a number`); return e }(t), s, a, r, i) } catch (l) { throw function $t(e, n) { return new b(2100, !1) }() } } } return e.\u0275fac = function (t) { return new (t || e)(y(Mn, 16), y(xT, 16)) }, e.\u0275pipe = Ue({ name: "currency", type: e, pure: !0, standalone: !0 }), e })(); let n_ = (() => { class e { } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275mod = ft({ type: e }), e.\u0275inj = ot({}), e })(); let Nx = (() => { class e { } return e.\u0275prov = x({ token: e, providedIn: "root", factory: () => new Fx(T(nt), window) }), e })(); class Fx { constructor(n, t) { this.document = n, this.window = t, this.offset = () => [0, 0] } setOffset(n) { this.offset = Array.isArray(n) ? () => n : n } getScrollPosition() { return this.supportsScrolling() ? [this.window.pageXOffset, this.window.pageYOffset] : [0, 0] } scrollToPosition(n) { this.supportsScrolling() && this.window.scrollTo(n[0], n[1]) } scrollToAnchor(n) { if (!this.supportsScrolling()) return; const t = function Ox(e, n) { const t = e.getElementById(n) || e.getElementsByName(n)[0]; if (t) return t; if ("function" == typeof e.createTreeWalker && e.body && (e.body.createShadowRoot || e.body.attachShadow)) { const r = e.createTreeWalker(e.body, NodeFilter.SHOW_ELEMENT); let o = r.currentNode; for (; o;) { const i = o.shadowRoot; if (i) { const s = i.getElementById(n) || i.querySelector(`[name="${n}"]`); if (s) return s } o = r.nextNode() } } return null }(this.document, n); t && (this.scrollToElement(t), t.focus()) } setHistoryScrollRestoration(n) { if (this.supportScrollRestoration()) { const t = this.window.history; t && t.scrollRestoration && (t.scrollRestoration = n) } } scrollToElement(n) { const t = n.getBoundingClientRect(), r = t.left + this.window.pageXOffset, o = t.top + this.window.pageYOffset, i = this.offset(); this.window.scrollTo(r - i[0], o - i[1]) } supportScrollRestoration() { try { if (!this.supportsScrolling()) return !1; const n = o_(this.window.history) || o_(Object.getPrototypeOf(this.window.history)); return !(!n || !n.writable && !n.set) } catch { return !1 } } supportsScrolling() { try { return !!this.window && !!this.window.scrollTo && "pageXOffset" in this.window } catch { return !1 } } } function o_(e) { return Object.getOwnPropertyDescriptor(e, "scrollRestoration") } class i_ { } class lP extends d1 { constructor() { super(...arguments), this.supportsDOMEvents = !0 } } class fd extends lP { static makeCurrent() { !function c1(e) { Wc || (Wc = e) }(new fd) } onAndCancel(n, t, r) { return n.addEventListener(t, r, !1), () => { n.removeEventListener(t, r, !1) } } dispatchEvent(n, t) { n.dispatchEvent(t) } remove(n) { n.parentNode && n.parentNode.removeChild(n) } createElement(n, t) { return (t = t || this.getDefaultDocument()).createElement(n) } createHtmlDocument() { return document.implementation.createHTMLDocument("fakeTitle") } getDefaultDocument() { return document } isElementNode(n) { return n.nodeType === Node.ELEMENT_NODE } isShadowRoot(n) { return n instanceof DocumentFragment } getGlobalEventTarget(n, t) { return "window" === t ? window : "document" === t ? n : "body" === t ? n.body : null } getBaseHref(n) { const t = function uP() { return bi = bi || document.querySelector("base"), bi ? bi.getAttribute("href") : null }(); return null == t ? null : function cP(e) { Sa = Sa || document.createElement("a"), Sa.setAttribute("href", e); const n = Sa.pathname; return "/" === n.charAt(0) ? n : `/${n}` }(t) } resetBaseElement() { bi = null } getUserAgent() { return window.navigator.userAgent } getCookie(n) { return qv(document.cookie, n) } } let Sa, bi = null; const c_ = new A("TRANSITION_ID"), fP = [{ provide: oa, useFactory: function dP(e, n, t) { return () => { t.get(ia).donePromise.then(() => { const r = An(), o = n.querySelectorAll(`style[ng-transition="${e}"]`); for (let i = 0; i < o.length; i++)r.remove(o[i]) }) } }, deps: [c_, nt, Jt], multi: !0 }]; let pP = (() => { class e { build() { return new XMLHttpRequest } } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac }), e })(); const Ma = new A("EventManagerPlugins"); let Ia = (() => { class e { constructor(t, r) { this._zone = r, this._eventNameToPlugin = new Map, t.forEach(o => { o.manager = this }), this._plugins = t.slice().reverse() } addEventListener(t, r, o) { return this._findPluginFor(r).addEventListener(t, r, o) } addGlobalEventListener(t, r, o) { return this._findPluginFor(r).addGlobalEventListener(t, r, o) } getZone() { return this._zone } _findPluginFor(t) { const r = this._eventNameToPlugin.get(t); if (r) return r; const o = this._plugins; for (let i = 0; i < o.length; i++) { const s = o[i]; if (s.supports(t)) return this._eventNameToPlugin.set(t, s), s } throw new Error(`No event manager plugin found for event ${t}`) } } return e.\u0275fac = function (t) { return new (t || e)(T(Ma), T(De)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac }), e })(); class d_ { constructor(n) { this._doc = n } addGlobalEventListener(n, t, r) { const o = An().getGlobalEventTarget(this._doc, n); if (!o) throw new Error(`Unsupported event target ${o} for event ${t}`); return this.addEventListener(o, t, r) } } let f_ = (() => { class e { constructor() { this.usageCount = new Map } addStyles(t) { for (const r of t) 1 === this.changeUsageCount(r, 1) && this.onStyleAdded(r) } removeStyles(t) { for (const r of t) 0 === this.changeUsageCount(r, -1) && this.onStyleRemoved(r) } onStyleRemoved(t) { } onStyleAdded(t) { } getAllStyles() { return this.usageCount.keys() } changeUsageCount(t, r) { const o = this.usageCount; let i = o.get(t) ?? 0; return i += r, i > 0 ? o.set(t, i) : o.delete(t), i } ngOnDestroy() { for (const t of this.getAllStyles()) this.onStyleRemoved(t); this.usageCount.clear() } } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac }), e })(), Ei = (() => { class e extends f_ { constructor(t) { super(), this.doc = t, this.styleRef = new Map, this.hostNodes = new Set, this.resetHostNodes() } onStyleAdded(t) { for (const r of this.hostNodes) this.addStyleToHost(r, t) } onStyleRemoved(t) { const r = this.styleRef; r.get(t)?.forEach(i => i.remove()), r.delete(t) } ngOnDestroy() { super.ngOnDestroy(), this.styleRef.clear(), this.resetHostNodes() } addHost(t) { this.hostNodes.add(t); for (const r of this.getAllStyles()) this.addStyleToHost(t, r) } removeHost(t) { this.hostNodes.delete(t) } addStyleToHost(t, r) { const o = this.doc.createElement("style"); o.textContent = r, t.appendChild(o); const i = this.styleRef.get(r); i ? i.push(o) : this.styleRef.set(r, [o]) } resetHostNodes() { const t = this.hostNodes; t.clear(), t.add(this.doc.head) } } return e.\u0275fac = function (t) { return new (t || e)(T(nt)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac }), e })(); const hd = { svg: "http://www.w3.org/2000/svg", xhtml: "http://www.w3.org/1999/xhtml", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/", math: "http://www.w3.org/1998/MathML/" }, pd = /%COMP%/g, g_ = new A("RemoveStylesOnCompDestory", { providedIn: "root", factory: () => !1 }); function m_(e, n) { return n.flat(100).map(t => t.replace(pd, e)) } function y_(e) { return n => { if ("__ngUnwrap__" === n) return e; !1 === e(n) && (n.preventDefault(), n.returnValue = !1) } } let gd = (() => { class e { constructor(t, r, o, i) { this.eventManager = t, this.sharedStylesHost = r, this.appId = o, this.removeStylesOnCompDestory = i, this.rendererByCompId = new Map, this.defaultRenderer = new md(t) } createRenderer(t, r) { if (!t || !r) return this.defaultRenderer; const o = this.getOrCreateRenderer(t, r); return o instanceof D_ ? o.applyToHost(t) : o instanceof yd && o.applyStyles(), o } getOrCreateRenderer(t, r) { const o = this.rendererByCompId; let i = o.get(r.id); if (!i) { const s = this.eventManager, a = this.sharedStylesHost, l = this.removeStylesOnCompDestory; switch (r.encapsulation) { case Gt.Emulated: i = new D_(s, a, r, this.appId, l); break; case Gt.ShadowDom: return new CP(s, a, t, r); default: i = new yd(s, a, r, l) }i.onDestroy = () => o.delete(r.id), o.set(r.id, i) } return i } ngOnDestroy() { this.rendererByCompId.clear() } begin() { } end() { } } return e.\u0275fac = function (t) { return new (t || e)(T(Ia), T(Ei), T(mi), T(g_)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac }), e })(); class md { constructor(n) { this.eventManager = n, this.data = Object.create(null), this.destroyNode = null } destroy() { } createElement(n, t) { return t ? document.createElementNS(hd[t] || t, n) : document.createElement(n) } createComment(n) { return document.createComment(n) } createText(n) { return document.createTextNode(n) } appendChild(n, t) { (__(n) ? n.content : n).appendChild(t) } insertBefore(n, t, r) { n && (__(n) ? n.content : n).insertBefore(t, r) } removeChild(n, t) { n && n.removeChild(t) } selectRootElement(n, t) { let r = "string" == typeof n ? document.querySelector(n) : n; if (!r) throw new Error(`The selector "${n}" did not match any elements`); return t || (r.textContent = ""), r } parentNode(n) { return n.parentNode } nextSibling(n) { return n.nextSibling } setAttribute(n, t, r, o) { if (o) { t = o + ":" + t; const i = hd[o]; i ? n.setAttributeNS(i, t, r) : n.setAttribute(t, r) } else n.setAttribute(t, r) } removeAttribute(n, t, r) { if (r) { const o = hd[r]; o ? n.removeAttributeNS(o, t) : n.removeAttribute(`${r}:${t}`) } else n.removeAttribute(t) } addClass(n, t) { n.classList.add(t) } removeClass(n, t) { n.classList.remove(t) } setStyle(n, t, r, o) { o & (st.DashCase | st.Important) ? n.style.setProperty(t, r, o & st.Important ? "important" : "") : n.style[t] = r } removeStyle(n, t, r) { r & st.DashCase ? n.style.removeProperty(t) : n.style[t] = "" } setProperty(n, t, r) { n[t] = r } setValue(n, t) { n.nodeValue = t } listen(n, t, r) { return "string" == typeof n ? this.eventManager.addGlobalEventListener(n, t, y_(r)) : this.eventManager.addEventListener(n, t, y_(r)) } } function __(e) { return "TEMPLATE" === e.tagName && void 0 !== e.content } class CP extends md { constructor(n, t, r, o) { super(n), this.sharedStylesHost = t, this.hostEl = r, this.shadowRoot = r.attachShadow({ mode: "open" }), this.sharedStylesHost.addHost(this.shadowRoot); const i = m_(o.id, o.styles); for (const s of i) { const a = document.createElement("style"); a.textContent = s, this.shadowRoot.appendChild(a) } } nodeOrShadowRoot(n) { return n === this.hostEl ? this.shadowRoot : n } appendChild(n, t) { return super.appendChild(this.nodeOrShadowRoot(n), t) } insertBefore(n, t, r) { return super.insertBefore(this.nodeOrShadowRoot(n), t, r) } removeChild(n, t) { return super.removeChild(this.nodeOrShadowRoot(n), t) } parentNode(n) { return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(n))) } destroy() { this.sharedStylesHost.removeHost(this.shadowRoot) } } class yd extends md { constructor(n, t, r, o, i = r.id) { super(n), this.sharedStylesHost = t, this.removeStylesOnCompDestory = o, this.rendererUsageCount = 0, this.styles = m_(i, r.styles) } applyStyles() { this.sharedStylesHost.addStyles(this.styles), this.rendererUsageCount++ } destroy() { this.removeStylesOnCompDestory && (this.sharedStylesHost.removeStyles(this.styles), this.rendererUsageCount--, 0 === this.rendererUsageCount && this.onDestroy?.()) } } class D_ extends yd { constructor(n, t, r, o, i) { const s = o + "-" + r.id; super(n, t, r, i, s), this.contentAttr = function vP(e) { return "_ngcontent-%COMP%".replace(pd, e) }(s), this.hostAttr = function _P(e) { return "_nghost-%COMP%".replace(pd, e) }(s) } applyToHost(n) { this.applyStyles(), this.setAttribute(n, this.hostAttr, "") } createElement(n, t) { const r = super.createElement(n, t); return super.setAttribute(r, this.contentAttr, ""), r } } let wP = (() => { class e extends d_ { constructor(t) { super(t) } supports(t) { return !0 } addEventListener(t, r, o) { return t.addEventListener(r, o, !1), () => this.removeEventListener(t, r, o) } removeEventListener(t, r, o) { return t.removeEventListener(r, o) } } return e.\u0275fac = function (t) { return new (t || e)(T(nt)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac }), e })(); const C_ = ["alt", "control", "meta", "shift"], bP = { "\b": "Backspace", "\t": "Tab", "\x7f": "Delete", "\x1b": "Escape", Del: "Delete", Esc: "Escape", Left: "ArrowLeft", Right: "ArrowRight", Up: "ArrowUp", Down: "ArrowDown", Menu: "ContextMenu", Scroll: "ScrollLock", Win: "OS" }, EP = { alt: e => e.altKey, control: e => e.ctrlKey, meta: e => e.metaKey, shift: e => e.shiftKey }; let SP = (() => { class e extends d_ { constructor(t) { super(t) } supports(t) { return null != e.parseEventName(t) } addEventListener(t, r, o) { const i = e.parseEventName(r), s = e.eventCallback(i.fullKey, o, this.manager.getZone()); return this.manager.getZone().runOutsideAngular(() => An().onAndCancel(t, i.domEventName, s)) } static parseEventName(t) { const r = t.toLowerCase().split("."), o = r.shift(); if (0 === r.length || "keydown" !== o && "keyup" !== o) return null; const i = e._normalizeKey(r.pop()); let s = "", a = r.indexOf("code"); if (a > -1 && (r.splice(a, 1), s = "code."), C_.forEach(u => { const c = r.indexOf(u); c > -1 && (r.splice(c, 1), s += u + ".") }), s += i, 0 != r.length || 0 === i.length) return null; const l = {}; return l.domEventName = o, l.fullKey = s, l } static matchEventFullKeyCode(t, r) { let o = bP[t.key] || t.key, i = ""; return r.indexOf("code.") > -1 && (o = t.code, i = "code."), !(null == o || !o) && (o = o.toLowerCase(), " " === o ? o = "space" : "." === o && (o = "dot"), C_.forEach(s => { s !== o && (0, EP[s])(t) && (i += s + ".") }), i += o, i === r) } static eventCallback(t, r, o) { return i => { e.matchEventFullKeyCode(i, t) && o.runGuarded(() => r(i)) } } static _normalizeKey(t) { return "esc" === t ? "escape" : t } } return e.\u0275fac = function (t) { return new (t || e)(T(nt)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac }), e })(); const TP = mv(a1, "browser", [{ provide: Nc, useValue: "browser" }, { provide: iv, useValue: function MP() { fd.makeCurrent() }, multi: !0 }, { provide: nt, useFactory: function AP() { return function l0(e) { vu = e }(document), document }, deps: [] }]), E_ = new A(""), S_ = [{ provide: sa, useClass: class hP { addToWindow(n) { ce.getAngularTestability = (r, o = !0) => { const i = n.findTestabilityInTree(r, o); if (null == i) throw new Error("Could not find testability for element."); return i }, ce.getAllAngularTestabilities = () => n.getAllTestabilities(), ce.getAllAngularRootElements = () => n.getAllRootElements(), ce.frameworkStabilizers || (ce.frameworkStabilizers = []), ce.frameworkStabilizers.push(r => { const o = ce.getAllAngularTestabilities(); let i = o.length, s = !1; const a = function (l) { s = s || l, i--, 0 == i && r(s) }; o.forEach(function (l) { l.whenStable(a) }) }) } findTestabilityInTree(n, t, r) { return null == t ? null : n.getTestability(t) ?? (r ? An().isShadowRoot(t) ? this.findTestabilityInTree(n, t.host, !0) : this.findTestabilityInTree(n, t.parentElement, !0) : null) } }, deps: [] }, { provide: dv, useClass: Lc, deps: [De, Vc, sa] }, { provide: Lc, useClass: Lc, deps: [De, Vc, sa] }], M_ = [{ provide: Iu, useValue: "root" }, { provide: Wr, useFactory: function IP() { return new Wr }, deps: [] }, { provide: Ma, useClass: wP, multi: !0, deps: [nt, De, Nc] }, { provide: Ma, useClass: SP, multi: !0, deps: [nt] }, { provide: gd, useClass: gd, deps: [Ia, Ei, mi, g_] }, { provide: eg, useExisting: gd }, { provide: f_, useExisting: Ei }, { provide: Ei, useClass: Ei, deps: [nt] }, { provide: Ia, useClass: Ia, deps: [Ma, De] }, { provide: i_, useClass: pP, deps: [] }, []]; let xP = (() => { class e { constructor(t) { } static withServerTransition(t) { return { ngModule: e, providers: [{ provide: mi, useValue: t.appId }, { provide: c_, useExisting: mi }, fP] } } } return e.\u0275fac = function (t) { return new (t || e)(T(E_, 12)) }, e.\u0275mod = ft({ type: e }), e.\u0275inj = ot({ providers: [...M_, ...S_], imports: [n_, l1] }), e })(), I_ = (() => { class e { constructor(t) { this._doc = t } getTitle() { return this._doc.title } setTitle(t) { this._doc.title = t || "" } } return e.\u0275fac = function (t) { return new (t || e)(T(nt)) }, e.\u0275prov = x({ token: e, factory: function (t) { let r = null; return r = t ? new t : function RP() { return new I_(T(nt)) }(), r }, providedIn: "root" }), e })(); function R(...e) { return Se(e, Ao(e)) } typeof window < "u" && window; class Ut extends hn { constructor(n) { super(), this._value = n } get value() { return this.getValue() } _subscribe(n) { const t = super._subscribe(n); return !t.closed && n.next(this._value), t } getValue() { const { hasError: n, thrownError: t, _value: r } = this; if (n) throw t; return this._throwIfClosed(), r } next(n) { super.next(this._value = n) } } const Aa = So(e => function () { e(this), this.name = "EmptyError", this.message = "no elements in sequence" }), { isArray: VP } = Array, { getPrototypeOf: jP, prototype: BP, keys: $P } = Object; function x_(e) { if (1 === e.length) { const n = e[0]; if (VP(n)) return { args: n, keys: null }; if (function UP(e) { return e && "object" == typeof e && jP(e) === BP }(n)) { const t = $P(n); return { args: t.map(r => n[r]), keys: t } } } return { args: e, keys: null } } const { isArray: HP } = Array; function P_(e) { return G(n => function zP(e, n) { return HP(n) ? e(...n) : e(n) }(e, n)) } function R_(e, n) { return e.reduce((t, r, o) => (t[r] = n[o], t), {}) } function N_(...e) { const n = Ao(e), t = Wf(e), { args: r, keys: o } = x_(e); if (0 === r.length) return Se([], n); const i = new ve(function GP(e, n, t = Xn) { return r => { F_(n, () => { const { length: o } = e, i = new Array(o); let s = o, a = o; for (let l = 0; l < o; l++)F_(n, () => { const u = Se(e[l], n); let c = !1; u.subscribe(xe(r, d => { i[l] = d, c || (c = !0, a--), a || r.next(t(i.slice())) }, () => { --s || r.complete() })) }, r) }, r) } }(r, n, o ? s => R_(o, s) : Xn)); return t ? i.pipe(P_(t)) : i } function F_(e, n, t) { e ? pn(t, e, n) : n() } function Dd(...e) { return function WP() { return Er(1) }()(Se(e, Ao(e))) } function O_(e) { return new ve(n => { Ct(e()).subscribe(n) }) } function Si(e, n) { const t = se(e) ? e : () => e, r = o => o.error(t()); return new ve(n ? o => n.schedule(r, 0, o) : r) } function Cd() { return Oe((e, n) => { let t = null; e._refCount++; const r = xe(n, void 0, void 0, void 0, () => { if (!e || e._refCount <= 0 || 0 < --e._refCount) return void (t = null); const o = e._connection, i = t; t = null, o && (!i || o === i) && o.unsubscribe(), n.unsubscribe() }); e.subscribe(r), r.closed || (t = e.connect()) }) } class k_ extends ve { constructor(n, t) { super(), this.source = n, this.subjectFactory = t, this._subject = null, this._refCount = 0, this._connection = null, Rf(n) && (this.lift = n.lift) } _subscribe(n) { return this.getSubject().subscribe(n) } getSubject() { const n = this._subject; return (!n || n.isStopped) && (this._subject = this.subjectFactory()), this._subject } _teardown() { this._refCount = 0; const { _connection: n } = this; this._subject = this._connection = null, n?.unsubscribe() } connect() { let n = this._connection; if (!n) { n = this._connection = new Dt; const t = this.getSubject(); n.add(this.source.subscribe(xe(t, void 0, () => { this._teardown(), t.complete() }, r => { this._teardown(), t.error(r) }, () => this._teardown()))), n.closed && (this._connection = null, n = Dt.EMPTY) } return n } refCount() { return Cd()(this) } } function an(e, n) { return Oe((t, r) => { let o = null, i = 0, s = !1; const a = () => s && !o && r.complete(); t.subscribe(xe(r, l => { o?.unsubscribe(); let u = 0; const c = i++; Ct(e(l, c)).subscribe(o = xe(r, d => r.next(n ? n(l, d, c, u++) : d), () => { o = null, a() })) }, () => { s = !0, a() })) }) } function Mi(e) { return e <= 0 ? () => Ht : Oe((n, t) => { let r = 0; n.subscribe(xe(t, o => { ++r <= e && (t.next(o), e <= r && t.complete()) })) }) } function Pn(e, n) { return Oe((t, r) => { let o = 0; t.subscribe(xe(r, i => e.call(n, i, o++) && r.next(i))) }) } function Ta(e) { return Oe((n, t) => { let r = !1; n.subscribe(xe(t, o => { r = !0, t.next(o) }, () => { r || t.next(e), t.complete() })) }) } function L_(e = KP) { return Oe((n, t) => { let r = !1; n.subscribe(xe(t, o => { r = !0, t.next(o) }, () => r ? t.complete() : t.error(e()))) }) } function KP() { return new Aa } function Bn(e, n) { const t = arguments.length >= 2; return r => r.pipe(e ? Pn((o, i) => e(o, i, r)) : Xn, Mi(1), t ? Ta(n) : L_(() => new Aa)) } function $n(e, n) { return se(n) ? ke(e, n, 1) : ke(e, 1) } function Ze(e, n, t) { const r = se(e) || n || t ? { next: e, error: n, complete: t } : e; return r ? Oe((o, i) => { var s; null === (s = r.subscribe) || void 0 === s || s.call(r); let a = !0; o.subscribe(xe(i, l => { var u; null === (u = r.next) || void 0 === u || u.call(r, l), i.next(l) }, () => { var l; a = !1, null === (l = r.complete) || void 0 === l || l.call(r), i.complete() }, l => { var u; a = !1, null === (u = r.error) || void 0 === u || u.call(r, l), i.error(l) }, () => { var l, u; a && (null === (l = r.unsubscribe) || void 0 === l || l.call(r)), null === (u = r.finalize) || void 0 === u || u.call(r) })) }) : Xn } function ln(e) { return Oe((n, t) => { let i, r = null, o = !1; r = n.subscribe(xe(t, void 0, void 0, s => { i = Ct(e(s, ln(e)(n))), r ? (r.unsubscribe(), r = null, i.subscribe(t)) : o = !0 })), o && (r.unsubscribe(), r = null, i.subscribe(t)) }) } function V_(e, n) { return Oe(function ZP(e, n, t, r, o) { return (i, s) => { let a = t, l = n, u = 0; i.subscribe(xe(s, c => { const d = u++; l = a ? e(l, c, d) : (a = !0, c), r && s.next(l) }, o && (() => { a && s.next(l), s.complete() }))) } }(e, n, arguments.length >= 2, !0)) } function wd(e) { return e <= 0 ? () => Ht : Oe((n, t) => { let r = []; n.subscribe(xe(t, o => { r.push(o), e < r.length && r.shift() }, () => { for (const o of r) t.next(o); t.complete() }, void 0, () => { r = null })) }) } function j_(e, n) { const t = arguments.length >= 2; return r => r.pipe(e ? Pn((o, i) => e(o, i, r)) : Xn, wd(1), t ? Ta(n) : L_(() => new Aa)) } function bd(e) { return Oe((n, t) => { try { n.subscribe(t) } finally { t.add(e) } }) } const U = "primary", Ii = Symbol("RouteTitle"); class XP { constructor(n) { this.params = n || {} } has(n) { return Object.prototype.hasOwnProperty.call(this.params, n) } get(n) { if (this.has(n)) { const t = this.params[n]; return Array.isArray(t) ? t[0] : t } return null } getAll(n) { if (this.has(n)) { const t = this.params[n]; return Array.isArray(t) ? t : [t] } return [] } get keys() { return Object.keys(this.params) } } function ho(e) { return new XP(e) } function JP(e, n, t) { const r = t.path.split("/"); if (r.length > e.length || "full" === t.pathMatch && (n.hasChildren() || r.length < e.length)) return null; const o = {}; for (let i = 0; i < r.length; i++) { const s = r[i], a = e[i]; if (s.startsWith(":")) o[s.substring(1)] = a; else if (s !== a.path) return null } return { consumed: e.slice(0, r.length), posParams: o } } function un(e, n) { const t = e ? Object.keys(e) : void 0, r = n ? Object.keys(n) : void 0; if (!t || !r || t.length != r.length) return !1; let o; for (let i = 0; i < t.length; i++)if (o = t[i], !B_(e[o], n[o])) return !1; return !0 } function B_(e, n) { if (Array.isArray(e) && Array.isArray(n)) { if (e.length !== n.length) return !1; const t = [...e].sort(), r = [...n].sort(); return t.every((o, i) => r[i] === o) } return e === n } function $_(e) { return Array.prototype.concat.apply([], e) } function U_(e) { return e.length > 0 ? e[e.length - 1] : null } function $e(e, n) { for (const t in e) e.hasOwnProperty(t) && n(e[t], t) } function Un(e) { return nc(e) ? e : ii(e) ? Se(Promise.resolve(e)) : R(e) } const xa = !1, tR = { exact: function G_(e, n, t) { if (!pr(e.segments, n.segments) || !Pa(e.segments, n.segments, t) || e.numberOfChildren !== n.numberOfChildren) return !1; for (const r in n.children) if (!e.children[r] || !G_(e.children[r], n.children[r], t)) return !1; return !0 }, subset: W_ }, H_ = { exact: function nR(e, n) { return un(e, n) }, subset: function rR(e, n) { return Object.keys(n).length <= Object.keys(e).length && Object.keys(n).every(t => B_(e[t], n[t])) }, ignored: () => !0 }; function z_(e, n, t) { return tR[t.paths](e.root, n.root, t.matrixParams) && H_[t.queryParams](e.queryParams, n.queryParams) && !("exact" === t.fragment && e.fragment !== n.fragment) } function W_(e, n, t) { return q_(e, n, n.segments, t) } function q_(e, n, t, r) { if (e.segments.length > t.length) { const o = e.segments.slice(0, t.length); return !(!pr(o, t) || n.hasChildren() || !Pa(o, t, r)) } if (e.segments.length === t.length) { if (!pr(e.segments, t) || !Pa(e.segments, t, r)) return !1; for (const o in n.children) if (!e.children[o] || !W_(e.children[o], n.children[o], r)) return !1; return !0 } { const o = t.slice(0, e.segments.length), i = t.slice(e.segments.length); return !!(pr(e.segments, o) && Pa(e.segments, o, r) && e.children[U]) && q_(e.children[U], n, i, r) } } function Pa(e, n, t) { return n.every((r, o) => H_[t](e[o].parameters, r.parameters)) } class Hn { constructor(n = new K([], {}), t = {}, r = null) { this.root = n, this.queryParams = t, this.fragment = r } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = ho(this.queryParams)), this._queryParamMap } toString() { return sR.serialize(this) } } class K { constructor(n, t) { this.segments = n, this.children = t, this.parent = null, $e(t, (r, o) => r.parent = this) } hasChildren() { return this.numberOfChildren > 0 } get numberOfChildren() { return Object.keys(this.children).length } toString() { return Ra(this) } } class Ai { constructor(n, t) { this.path = n, this.parameters = t } get parameterMap() { return this._parameterMap || (this._parameterMap = ho(this.parameters)), this._parameterMap } toString() { return Y_(this) } } function pr(e, n) { return e.length === n.length && e.every((t, r) => t.path === n[r].path) } let Ti = (() => { class e { } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275prov = x({ token: e, factory: function () { return new Ed }, providedIn: "root" }), e })(); class Ed { parse(n) { const t = new gR(n); return new Hn(t.parseRootSegment(), t.parseQueryParams(), t.parseFragment()) } serialize(n) { const t = `/${xi(n.root, !0)}`, r = function uR(e) { const n = Object.keys(e).map(t => { const r = e[t]; return Array.isArray(r) ? r.map(o => `${Na(t)}=${Na(o)}`).join("&") : `${Na(t)}=${Na(r)}` }).filter(t => !!t); return n.length ? `?${n.join("&")}` : "" }(n.queryParams); return `${t}${r}${"string" == typeof n.fragment ? `#${function aR(e) { return encodeURI(e) }(n.fragment)}` : ""}` } } const sR = new Ed; function Ra(e) { return e.segments.map(n => Y_(n)).join("/") } function xi(e, n) { if (!e.hasChildren()) return Ra(e); if (n) { const t = e.children[U] ? xi(e.children[U], !1) : "", r = []; return $e(e.children, (o, i) => { i !== U && r.push(`${i}:${xi(o, !1)}`) }), r.length > 0 ? `${t}(${r.join("//")})` : t } { const t = function iR(e, n) { let t = []; return $e(e.children, (r, o) => { o === U && (t = t.concat(n(r, o))) }), $e(e.children, (r, o) => { o !== U && (t = t.concat(n(r, o))) }), t }(e, (r, o) => o === U ? [xi(e.children[U], !1)] : [`${o}:${xi(r, !1)}`]); return 1 === Object.keys(e.children).length && null != e.children[U] ? `${Ra(e)}/${t[0]}` : `${Ra(e)}/(${t.join("//")})` } } function K_(e) { return encodeURIComponent(e).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",") } function Na(e) { return K_(e).replace(/%3B/gi, ";") } function Sd(e) { return K_(e).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&") } function Fa(e) { return decodeURIComponent(e) } function Z_(e) { return Fa(e.replace(/\+/g, "%20")) } function Y_(e) { return `${Sd(e.path)}${function lR(e) { return Object.keys(e).map(n => `;${Sd(n)}=${Sd(e[n])}`).join("") }(e.parameters)}` } const cR = /^[^\/()?;=#]+/; function Oa(e) { const n = e.match(cR); return n ? n[0] : "" } const dR = /^[^=?&#]+/, hR = /^[^&#]+/; class gR { constructor(n) { this.url = n, this.remaining = n } parseRootSegment() { return this.consumeOptional("/"), "" === this.remaining || this.peekStartsWith("?") || this.peekStartsWith("#") ? new K([], {}) : new K([], this.parseChildren()) } parseQueryParams() { const n = {}; if (this.consumeOptional("?")) do { this.parseQueryParam(n) } while (this.consumeOptional("&")); return n } parseFragment() { return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null } parseChildren() { if ("" === this.remaining) return {}; this.consumeOptional("/"); const n = []; for (this.peekStartsWith("(") || n.push(this.parseSegment()); this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/(");)this.capture("/"), n.push(this.parseSegment()); let t = {}; this.peekStartsWith("/(") && (this.capture("/"), t = this.parseParens(!0)); let r = {}; return this.peekStartsWith("(") && (r = this.parseParens(!1)), (n.length > 0 || Object.keys(t).length > 0) && (r[U] = new K(n, t)), r } parseSegment() { const n = Oa(this.remaining); if ("" === n && this.peekStartsWith(";")) throw new b(4009, xa); return this.capture(n), new Ai(Fa(n), this.parseMatrixParams()) } parseMatrixParams() { const n = {}; for (; this.consumeOptional(";");)this.parseParam(n); return n } parseParam(n) { const t = Oa(this.remaining); if (!t) return; this.capture(t); let r = ""; if (this.consumeOptional("=")) { const o = Oa(this.remaining); o && (r = o, this.capture(r)) } n[Fa(t)] = Fa(r) } parseQueryParam(n) { const t = function fR(e) { const n = e.match(dR); return n ? n[0] : "" }(this.remaining); if (!t) return; this.capture(t); let r = ""; if (this.consumeOptional("=")) { const s = function pR(e) { const n = e.match(hR); return n ? n[0] : "" }(this.remaining); s && (r = s, this.capture(r)) } const o = Z_(t), i = Z_(r); if (n.hasOwnProperty(o)) { let s = n[o]; Array.isArray(s) || (s = [s], n[o] = s), s.push(i) } else n[o] = i } parseParens(n) { const t = {}; for (this.capture("("); !this.consumeOptional(")") && this.remaining.length > 0;) { const r = Oa(this.remaining), o = this.remaining[r.length]; if ("/" !== o && ")" !== o && ";" !== o) throw new b(4010, xa); let i; r.indexOf(":") > -1 ? (i = r.slice(0, r.indexOf(":")), this.capture(i), this.capture(":")) : n && (i = U); const s = this.parseChildren(); t[i] = 1 === Object.keys(s).length ? s[U] : new K([], s), this.consumeOptional("//") } return t } peekStartsWith(n) { return this.remaining.startsWith(n) } consumeOptional(n) { return !!this.peekStartsWith(n) && (this.remaining = this.remaining.substring(n.length), !0) } capture(n) { if (!this.consumeOptional(n)) throw new b(4011, xa) } } function Md(e) { return e.segments.length > 0 ? new K([], { [U]: e }) : e } function ka(e) { const n = {}; for (const r of Object.keys(e.children)) { const i = ka(e.children[r]); (i.segments.length > 0 || i.hasChildren()) && (n[r] = i) } return function mR(e) { if (1 === e.numberOfChildren && e.children[U]) { const n = e.children[U]; return new K(e.segments.concat(n.segments), n.children) } return e }(new K(e.segments, n)) } function gr(e) { return e instanceof Hn } const Id = !1; function yR(e, n, t, r, o) { if (0 === t.length) return po(n.root, n.root, n.root, r, o); const i = function tD(e) { if ("string" == typeof e[0] && 1 === e.length && "/" === e[0]) return new eD(!0, 0, e); let n = 0, t = !1; const r = e.reduce((o, i, s) => { if ("object" == typeof i && null != i) { if (i.outlets) { const a = {}; return $e(i.outlets, (l, u) => { a[u] = "string" == typeof l ? l.split("/") : l }), [...o, { outlets: a }] } if (i.segmentPath) return [...o, i.segmentPath] } return "string" != typeof i ? [...o, i] : 0 === s ? (i.split("/").forEach((a, l) => { 0 == l && "." === a || (0 == l && "" === a ? t = !0 : ".." === a ? n++ : "" != a && o.push(a)) }), o) : [...o, i] }, []); return new eD(t, n, r) }(t); return i.toRoot() ? po(n.root, n.root, new K([], {}), r, o) : function s(l) { const u = function _R(e, n, t, r) { if (e.isAbsolute) return new go(n.root, !0, 0); if (-1 === r) return new go(t, t === n.root, 0); return function nD(e, n, t) { let r = e, o = n, i = t; for (; i > o;) { if (i -= o, r = r.parent, !r) throw new b(4005, Id && "Invalid number of '../'"); o = r.segments.length } return new go(r, !1, o - i) }(t, r + (Pi(e.commands[0]) ? 0 : 1), e.numberOfDoubleDots) }(i, n, e.snapshot?._urlSegment, l), c = u.processChildren ? mo(u.segmentGroup, u.index, i.commands) : Ad(u.segmentGroup, u.index, i.commands); return po(n.root, u.segmentGroup, c, r, o) }(e.snapshot?._lastPathIndex) } function Pi(e) { return "object" == typeof e && null != e && !e.outlets && !e.segmentPath } function Ri(e) { return "object" == typeof e && null != e && e.outlets } function po(e, n, t, r, o) { let s, i = {}; r && $e(r, (l, u) => { i[u] = Array.isArray(l) ? l.map(c => `${c}`) : `${l}` }), s = e === n ? t : J_(e, n, t); const a = Md(ka(s)); return new Hn(a, i, o) } function J_(e, n, t) { const r = {}; return $e(e.children, (o, i) => { r[i] = o === n ? t : J_(o, n, t) }), new K(e.segments, r) } class eD { constructor(n, t, r) { if (this.isAbsolute = n, this.numberOfDoubleDots = t, this.commands = r, n && r.length > 0 && Pi(r[0])) throw new b(4003, Id && "Root segment cannot have matrix parameters"); const o = r.find(Ri); if (o && o !== U_(r)) throw new b(4004, Id && "{outlets:{}} has to be the last command") } toRoot() { return this.isAbsolute && 1 === this.commands.length && "/" == this.commands[0] } } class go { constructor(n, t, r) { this.segmentGroup = n, this.processChildren = t, this.index = r } } function Ad(e, n, t) { if (e || (e = new K([], {})), 0 === e.segments.length && e.hasChildren()) return mo(e, n, t); const r = function CR(e, n, t) { let r = 0, o = n; const i = { match: !1, pathIndex: 0, commandIndex: 0 }; for (; o < e.segments.length;) { if (r >= t.length) return i; const s = e.segments[o], a = t[r]; if (Ri(a)) break; const l = `${a}`, u = r < t.length - 1 ? t[r + 1] : null; if (o > 0 && void 0 === l) break; if (l && u && "object" == typeof u && void 0 === u.outlets) { if (!oD(l, u, s)) return i; r += 2 } else { if (!oD(l, {}, s)) return i; r++ } o++ } return { match: !0, pathIndex: o, commandIndex: r } }(e, n, t), o = t.slice(r.commandIndex); if (r.match && r.pathIndex < e.segments.length) { const i = new K(e.segments.slice(0, r.pathIndex), {}); return i.children[U] = new K(e.segments.slice(r.pathIndex), e.children), mo(i, 0, o) } return r.match && 0 === o.length ? new K(e.segments, {}) : r.match && !e.hasChildren() ? Td(e, n, t) : r.match ? mo(e, 0, o) : Td(e, n, t) } function mo(e, n, t) { if (0 === t.length) return new K(e.segments, {}); { const r = function DR(e) { return Ri(e[0]) ? e[0].outlets : { [U]: e } }(t), o = {}; return !r[U] && e.children[U] && 1 === e.numberOfChildren && 0 === e.children[U].segments.length ? mo(e.children[U], n, t) : ($e(r, (i, s) => { "string" == typeof i && (i = [i]), null !== i && (o[s] = Ad(e.children[s], n, i)) }), $e(e.children, (i, s) => { void 0 === r[s] && (o[s] = i) }), new K(e.segments, o)) } } function Td(e, n, t) { const r = e.segments.slice(0, n); let o = 0; for (; o < t.length;) { const i = t[o]; if (Ri(i)) { const l = wR(i.outlets); return new K(r, l) } if (0 === o && Pi(t[0])) { r.push(new Ai(e.segments[n].path, rD(t[0]))), o++; continue } const s = Ri(i) ? i.outlets[U] : `${i}`, a = o < t.length - 1 ? t[o + 1] : null; s && a && Pi(a) ? (r.push(new Ai(s, rD(a))), o += 2) : (r.push(new Ai(s, {})), o++) } return new K(r, {}) } function wR(e) { const n = {}; return $e(e, (t, r) => { "string" == typeof t && (t = [t]), null !== t && (n[r] = Td(new K([], {}), 0, t)) }), n } function rD(e) { const n = {}; return $e(e, (t, r) => n[r] = `${t}`), n } function oD(e, n, t) { return e == t.path && un(n, t.parameters) } const Ni = "imperative"; class cn { constructor(n, t) { this.id = n, this.url = t } } class xd extends cn { constructor(n, t, r = "imperative", o = null) { super(n, t), this.type = 0, this.navigationTrigger = r, this.restoredState = o } toString() { return `NavigationStart(id: ${this.id}, url: '${this.url}')` } } class mr extends cn { constructor(n, t, r) { super(n, t), this.urlAfterRedirects = r, this.type = 1 } toString() { return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')` } } class La extends cn { constructor(n, t, r, o) { super(n, t), this.reason = r, this.code = o, this.type = 2 } toString() { return `NavigationCancel(id: ${this.id}, url: '${this.url}')` } } class Va extends cn { constructor(n, t, r, o) { super(n, t), this.reason = r, this.code = o, this.type = 16 } } class Pd extends cn { constructor(n, t, r, o) { super(n, t), this.error = r, this.target = o, this.type = 3 } toString() { return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})` } } class bR extends cn { constructor(n, t, r, o) { super(n, t), this.urlAfterRedirects = r, this.state = o, this.type = 4 } toString() { return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class ER extends cn { constructor(n, t, r, o) { super(n, t), this.urlAfterRedirects = r, this.state = o, this.type = 7 } toString() { return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class SR extends cn { constructor(n, t, r, o, i) { super(n, t), this.urlAfterRedirects = r, this.state = o, this.shouldActivate = i, this.type = 8 } toString() { return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})` } } class MR extends cn { constructor(n, t, r, o) { super(n, t), this.urlAfterRedirects = r, this.state = o, this.type = 5 } toString() { return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class IR extends cn { constructor(n, t, r, o) { super(n, t), this.urlAfterRedirects = r, this.state = o, this.type = 6 } toString() { return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class AR { constructor(n) { this.route = n, this.type = 9 } toString() { return `RouteConfigLoadStart(path: ${this.route.path})` } } class TR { constructor(n) { this.route = n, this.type = 10 } toString() { return `RouteConfigLoadEnd(path: ${this.route.path})` } } class xR { constructor(n) { this.snapshot = n, this.type = 11 } toString() { return `ChildActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class PR { constructor(n) { this.snapshot = n, this.type = 12 } toString() { return `ChildActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class RR { constructor(n) { this.snapshot = n, this.type = 13 } toString() { return `ActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class NR { constructor(n) { this.snapshot = n, this.type = 14 } toString() { return `ActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class iD { constructor(n, t, r) { this.routerEvent = n, this.position = t, this.anchor = r, this.type = 15 } toString() { return `Scroll(anchor: '${this.anchor}', position: '${this.position ? `${this.position[0]}, ${this.position[1]}` : null}')` } } let kR = (() => { class e { createUrlTree(t, r, o, i, s, a) { return yR(t || r.root, o, i, s, a) } } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac }), e })(), VR = (() => { class e { } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275prov = x({ token: e, factory: function (n) { return kR.\u0275fac(n) }, providedIn: "root" }), e })(); class sD { constructor(n) { this._root = n } get root() { return this._root.value } parent(n) { const t = this.pathFromRoot(n); return t.length > 1 ? t[t.length - 2] : null } children(n) { const t = Rd(n, this._root); return t ? t.children.map(r => r.value) : [] } firstChild(n) { const t = Rd(n, this._root); return t && t.children.length > 0 ? t.children[0].value : null } siblings(n) { const t = Nd(n, this._root); return t.length < 2 ? [] : t[t.length - 2].children.map(o => o.value).filter(o => o !== n) } pathFromRoot(n) { return Nd(n, this._root).map(t => t.value) } } function Rd(e, n) { if (e === n.value) return n; for (const t of n.children) { const r = Rd(e, t); if (r) return r } return null } function Nd(e, n) { if (e === n.value) return [n]; for (const t of n.children) { const r = Nd(e, t); if (r.length) return r.unshift(n), r } return [] } class Rn { constructor(n, t) { this.value = n, this.children = t } toString() { return `TreeNode(${this.value})` } } function yo(e) { const n = {}; return e && e.children.forEach(t => n[t.value.outlet] = t), n } class aD extends sD { constructor(n, t) { super(n), this.snapshot = t, Fd(this, n) } toString() { return this.snapshot.toString() } } function lD(e, n) { const t = function jR(e, n) { const s = new ja([], {}, {}, "", {}, U, n, null, e.root, -1, {}); return new cD("", new Rn(s, [])) }(e, n), r = new Ut([new Ai("", {})]), o = new Ut({}), i = new Ut({}), s = new Ut({}), a = new Ut(""), l = new yr(r, o, s, a, i, U, n, t.root); return l.snapshot = t.root, new aD(new Rn(l, []), t) } class yr { constructor(n, t, r, o, i, s, a, l) { this.url = n, this.params = t, this.queryParams = r, this.fragment = o, this.data = i, this.outlet = s, this.component = a, this.title = this.data?.pipe(G(u => u[Ii])) ?? R(void 0), this._futureSnapshot = l } get routeConfig() { return this._futureSnapshot.routeConfig } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = this.params.pipe(G(n => ho(n)))), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = this.queryParams.pipe(G(n => ho(n)))), this._queryParamMap } toString() { return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})` } } function uD(e, n = "emptyOnly") { const t = e.pathFromRoot; let r = 0; if ("always" !== n) for (r = t.length - 1; r >= 1;) { const o = t[r], i = t[r - 1]; if (o.routeConfig && "" === o.routeConfig.path) r--; else { if (i.component) break; r-- } } return function BR(e) { return e.reduce((n, t) => ({ params: { ...n.params, ...t.params }, data: { ...n.data, ...t.data }, resolve: { ...t.data, ...n.resolve, ...t.routeConfig?.data, ...t._resolvedData } }), { params: {}, data: {}, resolve: {} }) }(t.slice(r)) } class ja { get title() { return this.data?.[Ii] } constructor(n, t, r, o, i, s, a, l, u, c, d) { this.url = n, this.params = t, this.queryParams = r, this.fragment = o, this.data = i, this.outlet = s, this.component = a, this.routeConfig = l, this._urlSegment = u, this._lastPathIndex = c, this._resolve = d } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = ho(this.params)), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = ho(this.queryParams)), this._queryParamMap } toString() { return `Route(url:'${this.url.map(r => r.toString()).join("/")}', path:'${this.routeConfig ? this.routeConfig.path : ""}')` } } class cD extends sD { constructor(n, t) { super(t), this.url = n, Fd(this, t) } toString() { return dD(this._root) } } function Fd(e, n) { n.value._routerState = e, n.children.forEach(t => Fd(e, t)) } function dD(e) { const n = e.children.length > 0 ? ` { ${e.children.map(dD).join(", ")} } ` : ""; return `${e.value}${n}` } function Od(e) { if (e.snapshot) { const n = e.snapshot, t = e._futureSnapshot; e.snapshot = t, un(n.queryParams, t.queryParams) || e.queryParams.next(t.queryParams), n.fragment !== t.fragment && e.fragment.next(t.fragment), un(n.params, t.params) || e.params.next(t.params), function eR(e, n) { if (e.length !== n.length) return !1; for (let t = 0; t < e.length; ++t)if (!un(e[t], n[t])) return !1; return !0 }(n.url, t.url) || e.url.next(t.url), un(n.data, t.data) || e.data.next(t.data) } else e.snapshot = e._futureSnapshot, e.data.next(e._futureSnapshot.data) } function kd(e, n) { const t = un(e.params, n.params) && function oR(e, n) { return pr(e, n) && e.every((t, r) => un(t.parameters, n[r].parameters)) }(e.url, n.url); return t && !(!e.parent != !n.parent) && (!e.parent || kd(e.parent, n.parent)) } function Fi(e, n, t) { if (t && e.shouldReuseRoute(n.value, t.value.snapshot)) { const r = t.value; r._futureSnapshot = n.value; const o = function UR(e, n, t) { return n.children.map(r => { for (const o of t.children) if (e.shouldReuseRoute(r.value, o.value.snapshot)) return Fi(e, r, o); return Fi(e, r) }) }(e, n, t); return new Rn(r, o) } { if (e.shouldAttach(n.value)) { const i = e.retrieve(n.value); if (null !== i) { const s = i.route; return s.value._futureSnapshot = n.value, s.children = n.children.map(a => Fi(e, a)), s } } const r = function HR(e) { return new yr(new Ut(e.url), new Ut(e.params), new Ut(e.queryParams), new Ut(e.fragment), new Ut(e.data), e.outlet, e.component, e) }(n.value), o = n.children.map(i => Fi(e, i)); return new Rn(r, o) } } const Ld = "ngNavigationCancelingError"; function fD(e, n) { const { redirectTo: t, navigationBehaviorOptions: r } = gr(n) ? { redirectTo: n, navigationBehaviorOptions: void 0 } : n, o = hD(!1, 0, n); return o.url = t, o.navigationBehaviorOptions = r, o } function hD(e, n, t) { const r = new Error("NavigationCancelingError: " + (e || "")); return r[Ld] = !0, r.cancellationCode = n, t && (r.url = t), r } function pD(e) { return gD(e) && gr(e.url) } function gD(e) { return e && e[Ld] } class zR { constructor() { this.outlet = null, this.route = null, this.resolver = null, this.injector = null, this.children = new Oi, this.attachRef = null } } let Oi = (() => { class e { constructor() { this.contexts = new Map } onChildOutletCreated(t, r) { const o = this.getOrCreateContext(t); o.outlet = r, this.contexts.set(t, o) } onChildOutletDestroyed(t) { const r = this.getContext(t); r && (r.outlet = null, r.attachRef = null) } onOutletDeactivated() { const t = this.contexts; return this.contexts = new Map, t } onOutletReAttached(t) { this.contexts = t } getOrCreateContext(t) { let r = this.getContext(t); return r || (r = new zR, this.contexts.set(t, r)), r } getContext(t) { return this.contexts.get(t) || null } } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); const Ba = !1; let Vd = (() => { class e { constructor() { this.activated = null, this._activatedRoute = null, this.name = U, this.activateEvents = new pe, this.deactivateEvents = new pe, this.attachEvents = new pe, this.detachEvents = new pe, this.parentContexts = W(Oi), this.location = W(Vt), this.changeDetector = W(ua), this.environmentInjector = W(Xt) } ngOnChanges(t) { if (t.name) { const { firstChange: r, previousValue: o } = t.name; if (r) return; this.isTrackedInParentContexts(o) && (this.deactivate(), this.parentContexts.onChildOutletDestroyed(o)), this.initializeOutletWithName() } } ngOnDestroy() { this.isTrackedInParentContexts(this.name) && this.parentContexts.onChildOutletDestroyed(this.name) } isTrackedInParentContexts(t) { return this.parentContexts.getContext(t)?.outlet === this } ngOnInit() { this.initializeOutletWithName() } initializeOutletWithName() { if (this.parentContexts.onChildOutletCreated(this.name, this), this.activated) return; const t = this.parentContexts.getContext(this.name); t?.route && (t.attachRef ? this.attach(t.attachRef, t.route) : this.activateWith(t.route, t.injector)) } get isActivated() { return !!this.activated } get component() { if (!this.activated) throw new b(4012, Ba); return this.activated.instance } get activatedRoute() { if (!this.activated) throw new b(4012, Ba); return this._activatedRoute } get activatedRouteData() { return this._activatedRoute ? this._activatedRoute.snapshot.data : {} } detach() { if (!this.activated) throw new b(4012, Ba); this.location.detach(); const t = this.activated; return this.activated = null, this._activatedRoute = null, this.detachEvents.emit(t.instance), t } attach(t, r) { this.activated = t, this._activatedRoute = r, this.location.insert(t.hostView), this.attachEvents.emit(t.instance) } deactivate() { if (this.activated) { const t = this.component; this.activated.destroy(), this.activated = null, this._activatedRoute = null, this.deactivateEvents.emit(t) } } activateWith(t, r) { if (this.isActivated) throw new b(4013, Ba); this._activatedRoute = t; const o = this.location, s = t.snapshot.component, a = this.parentContexts.getOrCreateContext(this.name).children, l = new GR(t, a, o.injector); if (r && function WR(e) { return !!e.resolveComponentFactory }(r)) { const u = r.resolveComponentFactory(s); this.activated = o.createComponent(u, o.length, l) } else this.activated = o.createComponent(s, { index: o.length, injector: l, environmentInjector: r ?? this.environmentInjector }); this.changeDetector.markForCheck(), this.activateEvents.emit(this.activated.instance) } } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275dir = V({ type: e, selectors: [["router-outlet"]], inputs: { name: "name" }, outputs: { activateEvents: "activate", deactivateEvents: "deactivate", attachEvents: "attach", detachEvents: "detach" }, exportAs: ["outlet"], standalone: !0, features: [Et] }), e })(); class GR { constructor(n, t, r) { this.route = n, this.childContexts = t, this.parent = r } get(n, t) { return n === yr ? this.route : n === Oi ? this.childContexts : this.parent.get(n, t) } } let jd = (() => { class e { } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275cmp = Wt({ type: e, selectors: [["ng-component"]], standalone: !0, features: [yy], decls: 1, vars: 0, template: function (t, r) { 1 & t && Ke(0, "router-outlet") }, dependencies: [Vd], encapsulation: 2 }), e })(); function mD(e, n) { return e.providers && !e._injector && (e._injector = ea(e.providers, n, `Route: ${e.path}`)), e._injector ?? n } function $d(e) { const n = e.children && e.children.map($d), t = n ? { ...e, children: n } : { ...e }; return !t.component && !t.loadComponent && (n || t.loadChildren) && t.outlet && t.outlet !== U && (t.component = jd), t } function xt(e) { return e.outlet || U } function yD(e, n) { const t = e.filter(r => xt(r) === n); return t.push(...e.filter(r => xt(r) !== n)), t } function ki(e) { if (!e) return null; if (e.routeConfig?._injector) return e.routeConfig._injector; for (let n = e.parent; n; n = n.parent) { const t = n.routeConfig; if (t?._loadedInjector) return t._loadedInjector; if (t?._injector) return t._injector } return null } class QR { constructor(n, t, r, o) { this.routeReuseStrategy = n, this.futureState = t, this.currState = r, this.forwardEvent = o } activate(n) { const t = this.futureState._root, r = this.currState ? this.currState._root : null; this.deactivateChildRoutes(t, r, n), Od(this.futureState.root), this.activateChildRoutes(t, r, n) } deactivateChildRoutes(n, t, r) { const o = yo(t); n.children.forEach(i => { const s = i.value.outlet; this.deactivateRoutes(i, o[s], r), delete o[s] }), $e(o, (i, s) => { this.deactivateRouteAndItsChildren(i, r) }) } deactivateRoutes(n, t, r) { const o = n.value, i = t ? t.value : null; if (o === i) if (o.component) { const s = r.getContext(o.outlet); s && this.deactivateChildRoutes(n, t, s.children) } else this.deactivateChildRoutes(n, t, r); else i && this.deactivateRouteAndItsChildren(t, r) } deactivateRouteAndItsChildren(n, t) { n.value.component && this.routeReuseStrategy.shouldDetach(n.value.snapshot) ? this.detachAndStoreRouteSubtree(n, t) : this.deactivateRouteAndOutlet(n, t) } detachAndStoreRouteSubtree(n, t) { const r = t.getContext(n.value.outlet), o = r && n.value.component ? r.children : t, i = yo(n); for (const s of Object.keys(i)) this.deactivateRouteAndItsChildren(i[s], o); if (r && r.outlet) { const s = r.outlet.detach(), a = r.children.onOutletDeactivated(); this.routeReuseStrategy.store(n.value.snapshot, { componentRef: s, route: n, contexts: a }) } } deactivateRouteAndOutlet(n, t) { const r = t.getContext(n.value.outlet), o = r && n.value.component ? r.children : t, i = yo(n); for (const s of Object.keys(i)) this.deactivateRouteAndItsChildren(i[s], o); r && (r.outlet && (r.outlet.deactivate(), r.children.onOutletDeactivated()), r.attachRef = null, r.resolver = null, r.route = null) } activateChildRoutes(n, t, r) { const o = yo(t); n.children.forEach(i => { this.activateRoutes(i, o[i.value.outlet], r), this.forwardEvent(new NR(i.value.snapshot)) }), n.children.length && this.forwardEvent(new PR(n.value.snapshot)) } activateRoutes(n, t, r) { const o = n.value, i = t ? t.value : null; if (Od(o), o === i) if (o.component) { const s = r.getOrCreateContext(o.outlet); this.activateChildRoutes(n, t, s.children) } else this.activateChildRoutes(n, t, r); else if (o.component) { const s = r.getOrCreateContext(o.outlet); if (this.routeReuseStrategy.shouldAttach(o.snapshot)) { const a = this.routeReuseStrategy.retrieve(o.snapshot); this.routeReuseStrategy.store(o.snapshot, null), s.children.onOutletReAttached(a.contexts), s.attachRef = a.componentRef, s.route = a.route.value, s.outlet && s.outlet.attach(a.componentRef, a.route.value), Od(a.route.value), this.activateChildRoutes(n, null, s.children) } else { const a = ki(o.snapshot), l = a?.get(Jo) ?? null; s.attachRef = null, s.route = o, s.resolver = l, s.injector = a, s.outlet && s.outlet.activateWith(o, s.injector), this.activateChildRoutes(n, null, s.children) } } else this.activateChildRoutes(n, null, r) } } class vD { constructor(n) { this.path = n, this.route = this.path[this.path.length - 1] } } class $a { constructor(n, t) { this.component = n, this.route = t } } function XR(e, n, t) { const r = e._root; return Li(r, n ? n._root : null, t, [r.value]) } function vo(e, n) { const t = Symbol(), r = n.get(e, t); return r === t ? "function" != typeof e || function eb(e) { return null !== rs(e) }(e) ? n.get(e) : e : r } function Li(e, n, t, r, o = { canDeactivateChecks: [], canActivateChecks: [] }) { const i = yo(n); return e.children.forEach(s => { (function eN(e, n, t, r, o = { canDeactivateChecks: [], canActivateChecks: [] }) { const i = e.value, s = n ? n.value : null, a = t ? t.getContext(e.value.outlet) : null; if (s && i.routeConfig === s.routeConfig) { const l = function tN(e, n, t) { if ("function" == typeof t) return t(e, n); switch (t) { case "pathParamsChange": return !pr(e.url, n.url); case "pathParamsOrQueryParamsChange": return !pr(e.url, n.url) || !un(e.queryParams, n.queryParams); case "always": return !0; case "paramsOrQueryParamsChange": return !kd(e, n) || !un(e.queryParams, n.queryParams); default: return !kd(e, n) } }(s, i, i.routeConfig.runGuardsAndResolvers); l ? o.canActivateChecks.push(new vD(r)) : (i.data = s.data, i._resolvedData = s._resolvedData), Li(e, n, i.component ? a ? a.children : null : t, r, o), l && a && a.outlet && a.outlet.isActivated && o.canDeactivateChecks.push(new $a(a.outlet.component, s)) } else s && Vi(n, a, o), o.canActivateChecks.push(new vD(r)), Li(e, null, i.component ? a ? a.children : null : t, r, o) })(s, i[s.value.outlet], t, r.concat([s.value]), o), delete i[s.value.outlet] }), $e(i, (s, a) => Vi(s, t.getContext(a), o)), o } function Vi(e, n, t) { const r = yo(e), o = e.value; $e(r, (i, s) => { Vi(i, o.component ? n ? n.children.getContext(s) : null : n, t) }), t.canDeactivateChecks.push(new $a(o.component && n && n.outlet && n.outlet.isActivated ? n.outlet.component : null, o)) } function ji(e) { return "function" == typeof e } function Ud(e) { return e instanceof Aa || "EmptyError" === e?.name } const Ua = Symbol("INITIAL_VALUE"); function _o() { return an(e => N_(e.map(n => n.pipe(Mi(1), function qP(...e) { const n = Ao(e); return Oe((t, r) => { (n ? Dd(e, t, n) : Dd(e, t)).subscribe(r) }) }(Ua)))).pipe(G(n => { for (const t of n) if (!0 !== t) { if (t === Ua) return Ua; if (!1 === t || t instanceof Hn) return t } return !0 }), Pn(n => n !== Ua), Mi(1))) } function _D(e) { return function _w(...e) { return Tf(e) }(Ze(n => { if (gr(n)) throw fD(0, n) }), G(n => !0 === n)) } const Hd = { matched: !1, consumedSegments: [], remainingSegments: [], parameters: {}, positionalParamSegments: {} }; function DD(e, n, t, r, o) { const i = zd(e, n, t); return i.matched ? function vN(e, n, t, r) { const o = n.canMatch; return o && 0 !== o.length ? R(o.map(s => { const a = vo(s, e); return Un(function aN(e) { return e && ji(e.canMatch) }(a) ? a.canMatch(n, t) : e.runInContext(() => a(n, t))) })).pipe(_o(), _D()) : R(!0) }(r = mD(n, r), n, t).pipe(G(s => !0 === s ? i : { ...Hd })) : R(i) } function zd(e, n, t) { if ("" === n.path) return "full" === n.pathMatch && (e.hasChildren() || t.length > 0) ? { ...Hd } : { matched: !0, consumedSegments: [], remainingSegments: t, parameters: {}, positionalParamSegments: {} }; const o = (n.matcher || JP)(t, e, n); if (!o) return { ...Hd }; const i = {}; $e(o.posParams, (a, l) => { i[l] = a.path }); const s = o.consumed.length > 0 ? { ...i, ...o.consumed[o.consumed.length - 1].parameters } : i; return { matched: !0, consumedSegments: o.consumed, remainingSegments: t.slice(o.consumed.length), parameters: s, positionalParamSegments: o.posParams ?? {} } } function Ha(e, n, t, r) { if (t.length > 0 && function CN(e, n, t) { return t.some(r => za(e, n, r) && xt(r) !== U) }(e, t, r)) { const i = new K(n, function DN(e, n, t, r) { const o = {}; o[U] = r, r._sourceSegment = e, r._segmentIndexShift = n.length; for (const i of t) if ("" === i.path && xt(i) !== U) { const s = new K([], {}); s._sourceSegment = e, s._segmentIndexShift = n.length, o[xt(i)] = s } return o }(e, n, r, new K(t, e.children))); return i._sourceSegment = e, i._segmentIndexShift = n.length, { segmentGroup: i, slicedSegments: [] } } if (0 === t.length && function wN(e, n, t) { return t.some(r => za(e, n, r)) }(e, t, r)) { const i = new K(e.segments, function _N(e, n, t, r, o) { const i = {}; for (const s of r) if (za(e, t, s) && !o[xt(s)]) { const a = new K([], {}); a._sourceSegment = e, a._segmentIndexShift = n.length, i[xt(s)] = a } return { ...o, ...i } }(e, n, t, r, e.children)); return i._sourceSegment = e, i._segmentIndexShift = n.length, { segmentGroup: i, slicedSegments: t } } const o = new K(e.segments, e.children); return o._sourceSegment = e, o._segmentIndexShift = n.length, { segmentGroup: o, slicedSegments: t } } function za(e, n, t) { return (!(e.hasChildren() || n.length > 0) || "full" !== t.pathMatch) && "" === t.path } function CD(e, n, t, r) { return !!(xt(e) === r || r !== U && za(n, t, e)) && ("**" === e.path || zd(n, e, t).matched) } function wD(e, n, t) { return 0 === n.length && !e.children[t] } const Ga = !1; class Wa { constructor(n) { this.segmentGroup = n || null } } class bD { constructor(n) { this.urlTree = n } } function Bi(e) { return Si(new Wa(e)) } function ED(e) { return Si(new bD(e)) } class MN { constructor(n, t, r, o, i) { this.injector = n, this.configLoader = t, this.urlSerializer = r, this.urlTree = o, this.config = i, this.allowRedirects = !0 } apply() { const n = Ha(this.urlTree.root, [], [], this.config).segmentGroup, t = new K(n.segments, n.children); return this.expandSegmentGroup(this.injector, this.config, t, U).pipe(G(i => this.createUrlTree(ka(i), this.urlTree.queryParams, this.urlTree.fragment))).pipe(ln(i => { if (i instanceof bD) return this.allowRedirects = !1, this.match(i.urlTree); throw i instanceof Wa ? this.noMatchError(i) : i })) } match(n) { return this.expandSegmentGroup(this.injector, this.config, n.root, U).pipe(G(o => this.createUrlTree(ka(o), n.queryParams, n.fragment))).pipe(ln(o => { throw o instanceof Wa ? this.noMatchError(o) : o })) } noMatchError(n) { return new b(4002, Ga) } createUrlTree(n, t, r) { const o = Md(n); return new Hn(o, t, r) } expandSegmentGroup(n, t, r, o) { return 0 === r.segments.length && r.hasChildren() ? this.expandChildren(n, t, r).pipe(G(i => new K([], i))) : this.expandSegment(n, r, t, r.segments, o, !0) } expandChildren(n, t, r) { const o = []; for (const i of Object.keys(r.children)) "primary" === i ? o.unshift(i) : o.push(i); return Se(o).pipe($n(i => { const s = r.children[i], a = yD(t, i); return this.expandSegmentGroup(n, a, s, i).pipe(G(l => ({ segment: l, outlet: i }))) }), V_((i, s) => (i[s.outlet] = s.segment, i), {}), j_()) } expandSegment(n, t, r, o, i, s) { return Se(r).pipe($n(a => this.expandSegmentAgainstRoute(n, t, r, a, o, i, s).pipe(ln(u => { if (u instanceof Wa) return R(null); throw u }))), Bn(a => !!a), ln((a, l) => { if (Ud(a)) return wD(t, o, i) ? R(new K([], {})) : Bi(t); throw a })) } expandSegmentAgainstRoute(n, t, r, o, i, s, a) { return CD(o, t, i, s) ? void 0 === o.redirectTo ? this.matchSegmentAgainstRoute(n, t, o, i, s) : a && this.allowRedirects ? this.expandSegmentAgainstRouteUsingRedirect(n, t, r, o, i, s) : Bi(t) : Bi(t) } expandSegmentAgainstRouteUsingRedirect(n, t, r, o, i, s) { return "**" === o.path ? this.expandWildCardWithParamsAgainstRouteUsingRedirect(n, r, o, s) : this.expandRegularSegmentAgainstRouteUsingRedirect(n, t, r, o, i, s) } expandWildCardWithParamsAgainstRouteUsingRedirect(n, t, r, o) { const i = this.applyRedirectCommands([], r.redirectTo, {}); return r.redirectTo.startsWith("/") ? ED(i) : this.lineralizeSegments(r, i).pipe(ke(s => { const a = new K(s, {}); return this.expandSegment(n, a, t, s, o, !1) })) } expandRegularSegmentAgainstRouteUsingRedirect(n, t, r, o, i, s) { const { matched: a, consumedSegments: l, remainingSegments: u, positionalParamSegments: c } = zd(t, o, i); if (!a) return Bi(t); const d = this.applyRedirectCommands(l, o.redirectTo, c); return o.redirectTo.startsWith("/") ? ED(d) : this.lineralizeSegments(o, d).pipe(ke(f => this.expandSegment(n, t, r, f.concat(u), s, !1))) } matchSegmentAgainstRoute(n, t, r, o, i) { return "**" === r.path ? (n = mD(r, n), r.loadChildren ? (r._loadedRoutes ? R({ routes: r._loadedRoutes, injector: r._loadedInjector }) : this.configLoader.loadChildren(n, r)).pipe(G(a => (r._loadedRoutes = a.routes, r._loadedInjector = a.injector, new K(o, {})))) : R(new K(o, {}))) : DD(t, r, o, n).pipe(an(({ matched: s, consumedSegments: a, remainingSegments: l }) => s ? this.getChildConfig(n = r._injector ?? n, r, o).pipe(ke(c => { const d = c.injector ?? n, f = c.routes, { segmentGroup: h, slicedSegments: p } = Ha(t, a, l, f), g = new K(h.segments, h.children); if (0 === p.length && g.hasChildren()) return this.expandChildren(d, f, g).pipe(G(_ => new K(a, _))); if (0 === f.length && 0 === p.length) return R(new K(a, {})); const m = xt(r) === i; return this.expandSegment(d, g, f, p, m ? U : i, !0).pipe(G(S => new K(a.concat(S.segments), S.children))) })) : Bi(t))) } getChildConfig(n, t, r) { return t.children ? R({ routes: t.children, injector: n }) : t.loadChildren ? void 0 !== t._loadedRoutes ? R({ routes: t._loadedRoutes, injector: t._loadedInjector }) : function yN(e, n, t, r) { const o = n.canLoad; return void 0 === o || 0 === o.length ? R(!0) : R(o.map(s => { const a = vo(s, e); return Un(function rN(e) { return e && ji(e.canLoad) }(a) ? a.canLoad(n, t) : e.runInContext(() => a(n, t))) })).pipe(_o(), _D()) }(n, t, r).pipe(ke(o => o ? this.configLoader.loadChildren(n, t).pipe(Ze(i => { t._loadedRoutes = i.routes, t._loadedInjector = i.injector })) : function EN(e) { return Si(hD(Ga, 3)) }())) : R({ routes: [], injector: n }) } lineralizeSegments(n, t) { let r = [], o = t.root; for (; ;) { if (r = r.concat(o.segments), 0 === o.numberOfChildren) return R(r); if (o.numberOfChildren > 1 || !o.children[U]) return n.redirectTo, Si(new b(4e3, Ga)); o = o.children[U] } } applyRedirectCommands(n, t, r) { return this.applyRedirectCreateUrlTree(t, this.urlSerializer.parse(t), n, r) } applyRedirectCreateUrlTree(n, t, r, o) { const i = this.createSegmentGroup(n, t.root, r, o); return new Hn(i, this.createQueryParams(t.queryParams, this.urlTree.queryParams), t.fragment) } createQueryParams(n, t) { const r = {}; return $e(n, (o, i) => { if ("string" == typeof o && o.startsWith(":")) { const a = o.substring(1); r[i] = t[a] } else r[i] = o }), r } createSegmentGroup(n, t, r, o) { const i = this.createSegments(n, t.segments, r, o); let s = {}; return $e(t.children, (a, l) => { s[l] = this.createSegmentGroup(n, a, r, o) }), new K(i, s) } createSegments(n, t, r, o) { return t.map(i => i.path.startsWith(":") ? this.findPosParam(n, i, o) : this.findOrReturn(i, r)) } findPosParam(n, t, r) { const o = r[t.path.substring(1)]; if (!o) throw new b(4001, Ga); return o } findOrReturn(n, t) { let r = 0; for (const o of t) { if (o.path === n.path) return t.splice(r), o; r++ } return n } } class AN { } class PN { constructor(n, t, r, o, i, s, a) { this.injector = n, this.rootComponentType = t, this.config = r, this.urlTree = o, this.url = i, this.paramsInheritanceStrategy = s, this.urlSerializer = a } recognize() { const n = Ha(this.urlTree.root, [], [], this.config.filter(t => void 0 === t.redirectTo)).segmentGroup; return this.processSegmentGroup(this.injector, this.config, n, U).pipe(G(t => { if (null === t) return null; const r = new ja([], Object.freeze({}), Object.freeze({ ...this.urlTree.queryParams }), this.urlTree.fragment, {}, U, this.rootComponentType, null, this.urlTree.root, -1, {}), o = new Rn(r, t), i = new cD(this.url, o); return this.inheritParamsAndData(i._root), i })) } inheritParamsAndData(n) { const t = n.value, r = uD(t, this.paramsInheritanceStrategy); t.params = Object.freeze(r.params), t.data = Object.freeze(r.data), n.children.forEach(o => this.inheritParamsAndData(o)) } processSegmentGroup(n, t, r, o) { return 0 === r.segments.length && r.hasChildren() ? this.processChildren(n, t, r) : this.processSegment(n, t, r, r.segments, o) } processChildren(n, t, r) { return Se(Object.keys(r.children)).pipe($n(o => { const i = r.children[o], s = yD(t, o); return this.processSegmentGroup(n, s, i, o) }), V_((o, i) => o && i ? (o.push(...i), o) : null), function YP(e, n = !1) { return Oe((t, r) => { let o = 0; t.subscribe(xe(r, i => { const s = e(i, o++); (s || n) && r.next(i), !s && r.complete() })) }) }(o => null !== o), Ta(null), j_(), G(o => { if (null === o) return null; const i = MD(o); return function RN(e) { e.sort((n, t) => n.value.outlet === U ? -1 : t.value.outlet === U ? 1 : n.value.outlet.localeCompare(t.value.outlet)) }(i), i })) } processSegment(n, t, r, o, i) { return Se(t).pipe($n(s => this.processSegmentAgainstRoute(s._injector ?? n, s, r, o, i)), Bn(s => !!s), ln(s => { if (Ud(s)) return wD(r, o, i) ? R([]) : R(null); throw s })) } processSegmentAgainstRoute(n, t, r, o, i) { if (t.redirectTo || !CD(t, r, o, i)) return R(null); let s; if ("**" === t.path) { const a = o.length > 0 ? U_(o).parameters : {}, l = AD(r) + o.length; s = R({ snapshot: new ja(o, a, Object.freeze({ ...this.urlTree.queryParams }), this.urlTree.fragment, TD(t), xt(t), t.component ?? t._loadedComponent ?? null, t, ID(r), l, xD(t)), consumedSegments: [], remainingSegments: [] }) } else s = DD(r, t, o, n).pipe(G(({ matched: a, consumedSegments: l, remainingSegments: u, parameters: c }) => { if (!a) return null; const d = AD(r) + l.length; return { snapshot: new ja(l, c, Object.freeze({ ...this.urlTree.queryParams }), this.urlTree.fragment, TD(t), xt(t), t.component ?? t._loadedComponent ?? null, t, ID(r), d, xD(t)), consumedSegments: l, remainingSegments: u } })); return s.pipe(an(a => { if (null === a) return R(null); const { snapshot: l, consumedSegments: u, remainingSegments: c } = a; n = t._injector ?? n; const d = t._loadedInjector ?? n, f = function NN(e) { return e.children ? e.children : e.loadChildren ? e._loadedRoutes : [] }(t), { segmentGroup: h, slicedSegments: p } = Ha(r, u, c, f.filter(m => void 0 === m.redirectTo)); if (0 === p.length && h.hasChildren()) return this.processChildren(d, f, h).pipe(G(m => null === m ? null : [new Rn(l, m)])); if (0 === f.length && 0 === p.length) return R([new Rn(l, [])]); const g = xt(t) === i; return this.processSegment(d, f, h, p, g ? U : i).pipe(G(m => null === m ? null : [new Rn(l, m)])) })) } } function FN(e) { const n = e.value.routeConfig; return n && "" === n.path && void 0 === n.redirectTo } function MD(e) { const n = [], t = new Set; for (const r of e) { if (!FN(r)) { n.push(r); continue } const o = n.find(i => r.value.routeConfig === i.value.routeConfig); void 0 !== o ? (o.children.push(...r.children), t.add(o)) : n.push(r) } for (const r of t) { const o = MD(r.children); n.push(new Rn(r.value, o)) } return n.filter(r => !t.has(r)) } function ID(e) { let n = e; for (; n._sourceSegment;)n = n._sourceSegment; return n } function AD(e) { let n = e, t = n._segmentIndexShift ?? 0; for (; n._sourceSegment;)n = n._sourceSegment, t += n._segmentIndexShift ?? 0; return t - 1 } function TD(e) { return e.data || {} } function xD(e) { return e.resolve || {} } function PD(e) { return "string" == typeof e.title || null === e.title } function Gd(e) { return an(n => { const t = e(n); return t ? Se(t).pipe(G(() => n)) : R(n) }) } const Do = new A("ROUTES"); let Wd = (() => { class e { constructor() { this.componentLoaders = new WeakMap, this.childrenLoaders = new WeakMap, this.compiler = W(sv) } loadComponent(t) { if (this.componentLoaders.get(t)) return this.componentLoaders.get(t); if (t._loadedComponent) return R(t._loadedComponent); this.onLoadStartListener && this.onLoadStartListener(t); const r = Un(t.loadComponent()).pipe(G(ND), Ze(i => { this.onLoadEndListener && this.onLoadEndListener(t), t._loadedComponent = i }), bd(() => { this.componentLoaders.delete(t) })), o = new k_(r, () => new hn).pipe(Cd()); return this.componentLoaders.set(t, o), o } loadChildren(t, r) { if (this.childrenLoaders.get(r)) return this.childrenLoaders.get(r); if (r._loadedRoutes) return R({ routes: r._loadedRoutes, injector: r._loadedInjector }); this.onLoadStartListener && this.onLoadStartListener(r); const i = this.loadModuleFactoryOrRoutes(r.loadChildren).pipe(G(a => { this.onLoadEndListener && this.onLoadEndListener(r); let l, u, c = !1; Array.isArray(a) ? u = a : (l = a.create(t).injector, u = $_(l.get(Do, [], k.Self | k.Optional))); return { routes: u.map($d), injector: l } }), bd(() => { this.childrenLoaders.delete(r) })), s = new k_(i, () => new hn).pipe(Cd()); return this.childrenLoaders.set(r, s), s } loadModuleFactoryOrRoutes(t) { return Un(t()).pipe(G(ND), ke(r => r instanceof gy || Array.isArray(r) ? R(r) : Se(this.compiler.compileModuleAsync(r)))) } } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); function ND(e) { return function UN(e) { return e && "object" == typeof e && "default" in e }(e) ? e.default : e } let Ka = (() => { class e { get hasRequestedNavigation() { return 0 !== this.navigationId } constructor() { this.currentNavigation = null, this.lastSuccessfulNavigation = null, this.events = new hn, this.configLoader = W(Wd), this.environmentInjector = W(Xt), this.urlSerializer = W(Ti), this.rootContexts = W(Oi), this.navigationId = 0, this.afterPreactivation = () => R(void 0), this.rootComponentType = null, this.configLoader.onLoadEndListener = o => this.events.next(new TR(o)), this.configLoader.onLoadStartListener = o => this.events.next(new AR(o)) } complete() { this.transitions?.complete() } handleNavigationRequest(t) { const r = ++this.navigationId; this.transitions?.next({ ...this.transitions.value, ...t, id: r }) } setupNavigations(t) { return this.transitions = new Ut({ id: 0, targetPageId: 0, currentUrlTree: t.currentUrlTree, currentRawUrl: t.currentUrlTree, extractedUrl: t.urlHandlingStrategy.extract(t.currentUrlTree), urlAfterRedirects: t.urlHandlingStrategy.extract(t.currentUrlTree), rawUrl: t.currentUrlTree, extras: {}, resolve: null, reject: null, promise: Promise.resolve(!0), source: Ni, restoredState: null, currentSnapshot: t.routerState.snapshot, targetSnapshot: null, currentRouterState: t.routerState, targetRouterState: null, guards: { canActivateChecks: [], canDeactivateChecks: [] }, guardsResult: null }), this.transitions.pipe(Pn(r => 0 !== r.id), G(r => ({ ...r, extractedUrl: t.urlHandlingStrategy.extract(r.rawUrl) })), an(r => { let o = !1, i = !1; return R(r).pipe(Ze(s => { this.currentNavigation = { id: s.id, initialUrl: s.rawUrl, extractedUrl: s.extractedUrl, trigger: s.source, extras: s.extras, previousNavigation: this.lastSuccessfulNavigation ? { ...this.lastSuccessfulNavigation, previousNavigation: null } : null } }), an(s => { const a = t.browserUrlTree.toString(), l = !t.navigated || s.extractedUrl.toString() !== a || a !== t.currentUrlTree.toString(); if (!l && "reload" !== (s.extras.onSameUrlNavigation ?? t.onSameUrlNavigation)) { const c = ""; return this.events.next(new Va(s.id, t.serializeUrl(r.rawUrl), c, 0)), t.rawUrlTree = s.rawUrl, s.resolve(null), Ht } if (t.urlHandlingStrategy.shouldProcessUrl(s.rawUrl)) return FD(s.source) && (t.browserUrlTree = s.extractedUrl), R(s).pipe(an(c => { const d = this.transitions?.getValue(); return this.events.next(new xd(c.id, this.urlSerializer.serialize(c.extractedUrl), c.source, c.restoredState)), d !== this.transitions?.getValue() ? Ht : Promise.resolve(c) }), function IN(e, n, t, r) { return an(o => function SN(e, n, t, r, o) { return new MN(e, n, t, r, o).apply() }(e, n, t, o.extractedUrl, r).pipe(G(i => ({ ...o, urlAfterRedirects: i })))) }(this.environmentInjector, this.configLoader, this.urlSerializer, t.config), Ze(c => { this.currentNavigation = { ...this.currentNavigation, finalUrl: c.urlAfterRedirects }, r.urlAfterRedirects = c.urlAfterRedirects }), function kN(e, n, t, r, o) { return ke(i => function xN(e, n, t, r, o, i, s = "emptyOnly") { return new PN(e, n, t, r, o, s, i).recognize().pipe(an(a => null === a ? function TN(e) { return new ve(n => n.error(e)) }(new AN) : R(a))) }(e, n, t, i.urlAfterRedirects, r.serialize(i.urlAfterRedirects), r, o).pipe(G(s => ({ ...i, targetSnapshot: s })))) }(this.environmentInjector, this.rootComponentType, t.config, this.urlSerializer, t.paramsInheritanceStrategy), Ze(c => { if (r.targetSnapshot = c.targetSnapshot, "eager" === t.urlUpdateStrategy) { if (!c.extras.skipLocationChange) { const f = t.urlHandlingStrategy.merge(c.urlAfterRedirects, c.rawUrl); t.setBrowserUrl(f, c) } t.browserUrlTree = c.urlAfterRedirects } const d = new bR(c.id, this.urlSerializer.serialize(c.extractedUrl), this.urlSerializer.serialize(c.urlAfterRedirects), c.targetSnapshot); this.events.next(d) })); if (l && t.urlHandlingStrategy.shouldProcessUrl(t.rawUrlTree)) { const { id: c, extractedUrl: d, source: f, restoredState: h, extras: p } = s, g = new xd(c, this.urlSerializer.serialize(d), f, h); this.events.next(g); const m = lD(d, this.rootComponentType).snapshot; return R(r = { ...s, targetSnapshot: m, urlAfterRedirects: d, extras: { ...p, skipLocationChange: !1, replaceUrl: !1 } }) } { const c = ""; return this.events.next(new Va(s.id, t.serializeUrl(r.extractedUrl), c, 1)), t.rawUrlTree = s.rawUrl, s.resolve(null), Ht } }), Ze(s => { const a = new ER(s.id, this.urlSerializer.serialize(s.extractedUrl), this.urlSerializer.serialize(s.urlAfterRedirects), s.targetSnapshot); this.events.next(a) }), G(s => r = { ...s, guards: XR(s.targetSnapshot, s.currentSnapshot, this.rootContexts) }), function uN(e, n) { return ke(t => { const { targetSnapshot: r, currentSnapshot: o, guards: { canActivateChecks: i, canDeactivateChecks: s } } = t; return 0 === s.length && 0 === i.length ? R({ ...t, guardsResult: !0 }) : function cN(e, n, t, r) { return Se(e).pipe(ke(o => function mN(e, n, t, r, o) { const i = n && n.routeConfig ? n.routeConfig.canDeactivate : null; return i && 0 !== i.length ? R(i.map(a => { const l = ki(n) ?? o, u = vo(a, l); return Un(function sN(e) { return e && ji(e.canDeactivate) }(u) ? u.canDeactivate(e, n, t, r) : l.runInContext(() => u(e, n, t, r))).pipe(Bn()) })).pipe(_o()) : R(!0) }(o.component, o.route, t, n, r)), Bn(o => !0 !== o, !0)) }(s, r, o, e).pipe(ke(a => a && function nN(e) { return "boolean" == typeof e }(a) ? function dN(e, n, t, r) { return Se(n).pipe($n(o => Dd(function hN(e, n) { return null !== e && n && n(new xR(e)), R(!0) }(o.route.parent, r), function fN(e, n) { return null !== e && n && n(new RR(e)), R(!0) }(o.route, r), function gN(e, n, t) { const r = n[n.length - 1], i = n.slice(0, n.length - 1).reverse().map(s => function JR(e) { const n = e.routeConfig ? e.routeConfig.canActivateChild : null; return n && 0 !== n.length ? { node: e, guards: n } : null }(s)).filter(s => null !== s).map(s => O_(() => R(s.guards.map(l => { const u = ki(s.node) ?? t, c = vo(l, u); return Un(function iN(e) { return e && ji(e.canActivateChild) }(c) ? c.canActivateChild(r, e) : u.runInContext(() => c(r, e))).pipe(Bn()) })).pipe(_o()))); return R(i).pipe(_o()) }(e, o.path, t), function pN(e, n, t) { const r = n.routeConfig ? n.routeConfig.canActivate : null; if (!r || 0 === r.length) return R(!0); const o = r.map(i => O_(() => { const s = ki(n) ?? t, a = vo(i, s); return Un(function oN(e) { return e && ji(e.canActivate) }(a) ? a.canActivate(n, e) : s.runInContext(() => a(n, e))).pipe(Bn()) })); return R(o).pipe(_o()) }(e, o.route, t))), Bn(o => !0 !== o, !0)) }(r, i, e, n) : R(a)), G(a => ({ ...t, guardsResult: a }))) }) }(this.environmentInjector, s => this.events.next(s)), Ze(s => { if (r.guardsResult = s.guardsResult, gr(s.guardsResult)) throw fD(0, s.guardsResult); const a = new SR(s.id, this.urlSerializer.serialize(s.extractedUrl), this.urlSerializer.serialize(s.urlAfterRedirects), s.targetSnapshot, !!s.guardsResult); this.events.next(a) }), Pn(s => !!s.guardsResult || (t.restoreHistory(s), this.cancelNavigationTransition(s, "", 3), !1)), Gd(s => { if (s.guards.canActivateChecks.length) return R(s).pipe(Ze(a => { const l = new MR(a.id, this.urlSerializer.serialize(a.extractedUrl), this.urlSerializer.serialize(a.urlAfterRedirects), a.targetSnapshot); this.events.next(l) }), an(a => { let l = !1; return R(a).pipe(function LN(e, n) { return ke(t => { const { targetSnapshot: r, guards: { canActivateChecks: o } } = t; if (!o.length) return R(t); let i = 0; return Se(o).pipe($n(s => function VN(e, n, t, r) { const o = e.routeConfig, i = e._resolve; return void 0 !== o?.title && !PD(o) && (i[Ii] = o.title), function jN(e, n, t, r) { const o = function BN(e) { return [...Object.keys(e), ...Object.getOwnPropertySymbols(e)] }(e); if (0 === o.length) return R({}); const i = {}; return Se(o).pipe(ke(s => function $N(e, n, t, r) { const o = ki(n) ?? r, i = vo(e, o); return Un(i.resolve ? i.resolve(n, t) : o.runInContext(() => i(n, t))) }(e[s], n, t, r).pipe(Bn(), Ze(a => { i[s] = a }))), wd(1), function QP(e) { return G(() => e) }(i), ln(s => Ud(s) ? Ht : Si(s))) }(i, e, n, r).pipe(G(s => (e._resolvedData = s, e.data = uD(e, t).resolve, o && PD(o) && (e.data[Ii] = o.title), null))) }(s.route, r, e, n)), Ze(() => i++), wd(1), ke(s => i === o.length ? R(t) : Ht)) }) }(t.paramsInheritanceStrategy, this.environmentInjector), Ze({ next: () => l = !0, complete: () => { l || (t.restoreHistory(a), this.cancelNavigationTransition(a, "", 2)) } })) }), Ze(a => { const l = new IR(a.id, this.urlSerializer.serialize(a.extractedUrl), this.urlSerializer.serialize(a.urlAfterRedirects), a.targetSnapshot); this.events.next(l) })) }), Gd(s => { const a = l => { const u = []; l.routeConfig?.loadComponent && !l.routeConfig._loadedComponent && u.push(this.configLoader.loadComponent(l.routeConfig).pipe(Ze(c => { l.component = c }), G(() => { }))); for (const c of l.children) u.push(...a(c)); return u }; return N_(a(s.targetSnapshot.root)).pipe(Ta(), Mi(1)) }), Gd(() => this.afterPreactivation()), G(s => { const a = function $R(e, n, t) { const r = Fi(e, n._root, t ? t._root : void 0); return new aD(r, n) }(t.routeReuseStrategy, s.targetSnapshot, s.currentRouterState); return r = { ...s, targetRouterState: a } }), Ze(s => { t.currentUrlTree = s.urlAfterRedirects, t.rawUrlTree = t.urlHandlingStrategy.merge(s.urlAfterRedirects, s.rawUrl), t.routerState = s.targetRouterState, "deferred" === t.urlUpdateStrategy && (s.extras.skipLocationChange || t.setBrowserUrl(t.rawUrlTree, s), t.browserUrlTree = s.urlAfterRedirects) }), ((e, n, t) => G(r => (new QR(n, r.targetRouterState, r.currentRouterState, t).activate(e), r)))(this.rootContexts, t.routeReuseStrategy, s => this.events.next(s)), Ze({ next: s => { o = !0, this.lastSuccessfulNavigation = this.currentNavigation, t.navigated = !0, this.events.next(new mr(s.id, this.urlSerializer.serialize(s.extractedUrl), this.urlSerializer.serialize(t.currentUrlTree))), t.titleStrategy?.updateTitle(s.targetRouterState.snapshot), s.resolve(!0) }, complete: () => { o = !0 } }), bd(() => { o || i || this.cancelNavigationTransition(r, "", 1), this.currentNavigation?.id === r.id && (this.currentNavigation = null) }), ln(s => { if (i = !0, gD(s)) { pD(s) || (t.navigated = !0, t.restoreHistory(r, !0)); const a = new La(r.id, this.urlSerializer.serialize(r.extractedUrl), s.message, s.cancellationCode); if (this.events.next(a), pD(s)) { const l = t.urlHandlingStrategy.merge(s.url, t.rawUrlTree), u = { skipLocationChange: r.extras.skipLocationChange, replaceUrl: "eager" === t.urlUpdateStrategy || FD(r.source) }; t.scheduleNavigation(l, Ni, null, u, { resolve: r.resolve, reject: r.reject, promise: r.promise }) } else r.resolve(!1) } else { t.restoreHistory(r, !0); const a = new Pd(r.id, this.urlSerializer.serialize(r.extractedUrl), s, r.targetSnapshot ?? void 0); this.events.next(a); try { r.resolve(t.errorHandler(s)) } catch (l) { r.reject(l) } } return Ht })) })) } cancelNavigationTransition(t, r, o) { const i = new La(t.id, this.urlSerializer.serialize(t.extractedUrl), r, o); this.events.next(i), t.resolve(!1) } } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); function FD(e) { return e !== Ni } let OD = (() => { class e { buildTitle(t) { let r, o = t.root; for (; void 0 !== o;)r = this.getResolvedTitleForRoute(o) ?? r, o = o.children.find(i => i.outlet === U); return r } getResolvedTitleForRoute(t) { return t.data[Ii] } } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275prov = x({ token: e, factory: function () { return W(HN) }, providedIn: "root" }), e })(), HN = (() => { class e extends OD { constructor(t) { super(), this.title = t } updateTitle(t) { const r = this.buildTitle(t); void 0 !== r && this.title.setTitle(r) } } return e.\u0275fac = function (t) { return new (t || e)(T(I_)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(), zN = (() => { class e { } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275prov = x({ token: e, factory: function () { return W(WN) }, providedIn: "root" }), e })(); class GN { shouldDetach(n) { return !1 } store(n, t) { } shouldAttach(n) { return !1 } retrieve(n) { return null } shouldReuseRoute(n, t) { return n.routeConfig === t.routeConfig } } let WN = (() => { class e extends GN { } return e.\u0275fac = function () { let n; return function (r) { return (n || (n = je(e)))(r || e) } }(), e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); const Za = new A("", { providedIn: "root", factory: () => ({}) }); let KN = (() => { class e { } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275prov = x({ token: e, factory: function () { return W(ZN) }, providedIn: "root" }), e })(), ZN = (() => { class e { shouldProcessUrl(t) { return !0 } extract(t) { return t } merge(t, r) { return t } } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); function YN(e) { throw e } function QN(e, n, t) { return n.parse("/") } const XN = { paths: "exact", fragment: "ignored", matrixParams: "ignored", queryParams: "exact" }, JN = { paths: "subset", fragment: "ignored", matrixParams: "ignored", queryParams: "subset" }; let Fe = (() => { class e { get navigationId() { return this.navigationTransitions.navigationId } get browserPageId() { return this.location.getState()?.\u0275routerPageId } get events() { return this.navigationTransitions.events } constructor() { this.disposed = !1, this.currentPageId = 0, this.console = W(AT), this.isNgZoneEnabled = !1, this.options = W(Za, { optional: !0 }) || {}, this.errorHandler = this.options.errorHandler || YN, this.malformedUriErrorHandler = this.options.malformedUriErrorHandler || QN, this.navigated = !1, this.lastSuccessfulId = -1, this.urlHandlingStrategy = W(KN), this.routeReuseStrategy = W(zN), this.urlCreationStrategy = W(VR), this.titleStrategy = W(OD), this.onSameUrlNavigation = this.options.onSameUrlNavigation || "ignore", this.paramsInheritanceStrategy = this.options.paramsInheritanceStrategy || "emptyOnly", this.urlUpdateStrategy = this.options.urlUpdateStrategy || "deferred", this.canceledNavigationResolution = this.options.canceledNavigationResolution || "replace", this.config = $_(W(Do, { optional: !0 }) ?? []), this.navigationTransitions = W(Ka), this.urlSerializer = W(Ti), this.location = W(Zc), this.isNgZoneEnabled = W(De) instanceof De && De.isInAngularZone(), this.resetConfig(this.config), this.currentUrlTree = new Hn, this.rawUrlTree = this.currentUrlTree, this.browserUrlTree = this.currentUrlTree, this.routerState = lD(this.currentUrlTree, null), this.navigationTransitions.setupNavigations(this).subscribe(t => { this.lastSuccessfulId = t.id, this.currentPageId = t.targetPageId }, t => { this.console.warn(`Unhandled Navigation Error: ${t}`) }) } resetRootComponentType(t) { this.routerState.root.component = t, this.navigationTransitions.rootComponentType = t } initialNavigation() { if (this.setUpLocationChangeListener(), !this.navigationTransitions.hasRequestedNavigation) { const t = this.location.getState(); this.navigateToSyncWithBrowser(this.location.path(!0), Ni, t) } } setUpLocationChangeListener() { this.locationSubscription || (this.locationSubscription = this.location.subscribe(t => { const r = "popstate" === t.type ? "popstate" : "hashchange"; "popstate" === r && setTimeout(() => { this.navigateToSyncWithBrowser(t.url, r, t.state) }, 0) })) } navigateToSyncWithBrowser(t, r, o) { const i = { replaceUrl: !0 }, s = o?.navigationId ? o : null; if (o) { const l = { ...o }; delete l.navigationId, delete l.\u0275routerPageId, 0 !== Object.keys(l).length && (i.state = l) } const a = this.parseUrl(t); this.scheduleNavigation(a, r, s, i) } get url() { return this.serializeUrl(this.currentUrlTree) } getCurrentNavigation() { return this.navigationTransitions.currentNavigation } resetConfig(t) { this.config = t.map($d), this.navigated = !1, this.lastSuccessfulId = -1 } ngOnDestroy() { this.dispose() } dispose() { this.navigationTransitions.complete(), this.locationSubscription && (this.locationSubscription.unsubscribe(), this.locationSubscription = void 0), this.disposed = !0 } createUrlTree(t, r = {}) { const { relativeTo: o, queryParams: i, fragment: s, queryParamsHandling: a, preserveFragment: l } = r, u = l ? this.currentUrlTree.fragment : s; let c = null; switch (a) { case "merge": c = { ...this.currentUrlTree.queryParams, ...i }; break; case "preserve": c = this.currentUrlTree.queryParams; break; default: c = i || null }return null !== c && (c = this.removeEmptyProps(c)), this.urlCreationStrategy.createUrlTree(o, this.routerState, this.currentUrlTree, t, c, u ?? null) } navigateByUrl(t, r = { skipLocationChange: !1 }) { const o = gr(t) ? t : this.parseUrl(t), i = this.urlHandlingStrategy.merge(o, this.rawUrlTree); return this.scheduleNavigation(i, Ni, null, r) } navigate(t, r = { skipLocationChange: !1 }) { return function eF(e) { for (let n = 0; n < e.length; n++) { const t = e[n]; if (null == t) throw new b(4008, false) } }(t), this.navigateByUrl(this.createUrlTree(t, r), r) } serializeUrl(t) { return this.urlSerializer.serialize(t) } parseUrl(t) { let r; try { r = this.urlSerializer.parse(t) } catch (o) { r = this.malformedUriErrorHandler(o, this.urlSerializer, t) } return r } isActive(t, r) { let o; if (o = !0 === r ? { ...XN } : !1 === r ? { ...JN } : r, gr(t)) return z_(this.currentUrlTree, t, o); const i = this.parseUrl(t); return z_(this.currentUrlTree, i, o) } removeEmptyProps(t) { return Object.keys(t).reduce((r, o) => { const i = t[o]; return null != i && (r[o] = i), r }, {}) } scheduleNavigation(t, r, o, i, s) { if (this.disposed) return Promise.resolve(!1); let a, l, u, c; return s ? (a = s.resolve, l = s.reject, u = s.promise) : u = new Promise((d, f) => { a = d, l = f }), c = "computed" === this.canceledNavigationResolution ? o && o.\u0275routerPageId ? o.\u0275routerPageId : i.replaceUrl || i.skipLocationChange ? this.browserPageId ?? 0 : (this.browserPageId ?? 0) + 1 : 0, this.navigationTransitions.handleNavigationRequest({ targetPageId: c, source: r, restoredState: o, currentUrlTree: this.currentUrlTree, currentRawUrl: this.currentUrlTree, rawUrl: t, extras: i, resolve: a, reject: l, promise: u, currentSnapshot: this.routerState.snapshot, currentRouterState: this.routerState }), u.catch(d => Promise.reject(d)) } setBrowserUrl(t, r) { const o = this.urlSerializer.serialize(t), i = { ...r.extras.state, ...this.generateNgRouterState(r.id, r.targetPageId) }; this.location.isCurrentPathEqualTo(o) || r.extras.replaceUrl ? this.location.replaceState(o, "", i) : this.location.go(o, "", i) } restoreHistory(t, r = !1) { if ("computed" === this.canceledNavigationResolution) { const o = this.currentPageId - t.targetPageId; "popstate" !== t.source && "eager" !== this.urlUpdateStrategy && this.currentUrlTree !== this.getCurrentNavigation()?.finalUrl || 0 === o ? this.currentUrlTree === this.getCurrentNavigation()?.finalUrl && 0 === o && (this.resetState(t), this.browserUrlTree = t.currentUrlTree, this.resetUrlToCurrentUrlTree()) : this.location.historyGo(o) } else "replace" === this.canceledNavigationResolution && (r && this.resetState(t), this.resetUrlToCurrentUrlTree()) } resetState(t) { this.routerState = t.currentRouterState, this.currentUrlTree = t.currentUrlTree, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, t.rawUrl) } resetUrlToCurrentUrlTree() { this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), "", this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId)) } generateNgRouterState(t, r) { return "computed" === this.canceledNavigationResolution ? { navigationId: t, \u0275routerPageId: r } : { navigationId: t } } } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(), vr = (() => { class e { constructor(t, r, o, i, s, a) { this.router = t, this.route = r, this.tabIndexAttribute = o, this.renderer = i, this.el = s, this.locationStrategy = a, this._preserveFragment = !1, this._skipLocationChange = !1, this._replaceUrl = !1, this.href = null, this.commands = null, this.onChanges = new hn; const l = s.nativeElement.tagName?.toLowerCase(); this.isAnchorElement = "a" === l || "area" === l, this.isAnchorElement ? this.subscription = t.events.subscribe(u => { u instanceof mr && this.updateHref() }) : this.setTabIndexIfNotOnNativeEl("0") } set preserveFragment(t) { this._preserveFragment = fo(t) } get preserveFragment() { return this._preserveFragment } set skipLocationChange(t) { this._skipLocationChange = fo(t) } get skipLocationChange() { return this._skipLocationChange } set replaceUrl(t) { this._replaceUrl = fo(t) } get replaceUrl() { return this._replaceUrl } setTabIndexIfNotOnNativeEl(t) { null != this.tabIndexAttribute || this.isAnchorElement || this.applyAttributeValue("tabindex", t) } ngOnChanges(t) { this.isAnchorElement && this.updateHref(), this.onChanges.next(this) } set routerLink(t) { null != t ? (this.commands = Array.isArray(t) ? t : [t], this.setTabIndexIfNotOnNativeEl("0")) : (this.commands = null, this.setTabIndexIfNotOnNativeEl(null)) } onClick(t, r, o, i, s) { return !!(null === this.urlTree || this.isAnchorElement && (0 !== t || r || o || i || s || "string" == typeof this.target && "_self" != this.target)) || (this.router.navigateByUrl(this.urlTree, { skipLocationChange: this.skipLocationChange, replaceUrl: this.replaceUrl, state: this.state }), !this.isAnchorElement) } ngOnDestroy() { this.subscription?.unsubscribe() } updateHref() { this.href = null !== this.urlTree && this.locationStrategy ? this.locationStrategy?.prepareExternalUrl(this.router.serializeUrl(this.urlTree)) : null; const t = null === this.href ? null : function Up(e, n, t) { return function x0(e, n) { return "src" === n && ("embed" === e || "frame" === e || "iframe" === e || "media" === e || "script" === e) || "href" === n && ("base" === e || "link" === e) ? $p : Hr }(n, t)(e) }(this.href, this.el.nativeElement.tagName.toLowerCase(), "href"); this.applyAttributeValue("href", t) } applyAttributeValue(t, r) { const o = this.renderer, i = this.el.nativeElement; null !== r ? o.setAttribute(i, t, r) : o.removeAttribute(i, t) } get urlTree() { return null === this.commands ? null : this.router.createUrlTree(this.commands, { relativeTo: void 0 !== this.relativeTo ? this.relativeTo : this.route, queryParams: this.queryParams, fragment: this.fragment, queryParamsHandling: this.queryParamsHandling, preserveFragment: this.preserveFragment }) } } return e.\u0275fac = function (t) { return new (t || e)(y(Fe), y(yr), function Es(e) { return function eE(e, n) { if ("class" === n) return e.classes; if ("style" === n) return e.styles; const t = e.attrs; if (t) { const r = t.length; let o = 0; for (; o < r;) { const i = t[o]; if (Rh(i)) break; if (0 === i) o += 2; else if ("number" == typeof i) for (o++; o < r && "string" == typeof t[o];)o++; else { if (i === n) return t[o + 1]; o += 2 } } } return null }(Ve(), e) }("tabindex"), y(wn), y(lt), y(hr)) }, e.\u0275dir = V({ type: e, selectors: [["", "routerLink", ""]], hostVars: 1, hostBindings: function (t, r) { 1 & t && Z("click", function (i) { return r.onClick(i.button, i.ctrlKey, i.shiftKey, i.altKey, i.metaKey) }), 2 & t && nn("target", r.target) }, inputs: { target: "target", queryParams: "queryParams", fragment: "fragment", queryParamsHandling: "queryParamsHandling", state: "state", relativeTo: "relativeTo", preserveFragment: "preserveFragment", skipLocationChange: "skipLocationChange", replaceUrl: "replaceUrl", routerLink: "routerLink" }, standalone: !0, features: [Et] }), e })(), kD = (() => { class e { get isActive() { return this._isActive } constructor(t, r, o, i, s) { this.router = t, this.element = r, this.renderer = o, this.cdr = i, this.link = s, this.classes = [], this._isActive = !1, this.routerLinkActiveOptions = { exact: !1 }, this.isActiveChange = new pe, this.routerEventsSubscription = t.events.subscribe(a => { a instanceof mr && this.update() }) } ngAfterContentInit() { R(this.links.changes, R(null)).pipe(Er()).subscribe(t => { this.update(), this.subscribeToEachLinkOnChanges() }) } subscribeToEachLinkOnChanges() { this.linkInputChangesSubscription?.unsubscribe(); const t = [...this.links.toArray(), this.link].filter(r => !!r).map(r => r.onChanges); this.linkInputChangesSubscription = Se(t).pipe(Er()).subscribe(r => { this._isActive !== this.isLinkActive(this.router)(r) && this.update() }) } set routerLinkActive(t) { const r = Array.isArray(t) ? t : t.split(" "); this.classes = r.filter(o => !!o) } ngOnChanges(t) { this.update() } ngOnDestroy() { this.routerEventsSubscription.unsubscribe(), this.linkInputChangesSubscription?.unsubscribe() } update() { !this.links || !this.router.navigated || Promise.resolve().then(() => { const t = this.hasActiveLinks(); this._isActive !== t && (this._isActive = t, this.cdr.markForCheck(), this.classes.forEach(r => { t ? this.renderer.addClass(this.element.nativeElement, r) : this.renderer.removeClass(this.element.nativeElement, r) }), t && void 0 !== this.ariaCurrentWhenActive ? this.renderer.setAttribute(this.element.nativeElement, "aria-current", this.ariaCurrentWhenActive.toString()) : this.renderer.removeAttribute(this.element.nativeElement, "aria-current"), this.isActiveChange.emit(t)) }) } isLinkActive(t) { const r = function tF(e) { return !!e.paths }(this.routerLinkActiveOptions) ? this.routerLinkActiveOptions : this.routerLinkActiveOptions.exact || !1; return o => !!o.urlTree && t.isActive(o.urlTree, r) } hasActiveLinks() { const t = this.isLinkActive(this.router); return this.link && t(this.link) || this.links.some(t) } } return e.\u0275fac = function (t) { return new (t || e)(y(Fe), y(lt), y(wn), y(ua), y(vr, 8)) }, e.\u0275dir = V({ type: e, selectors: [["", "routerLinkActive", ""]], contentQueries: function (t, r, o) { if (1 & t && ky(o, vr, 5), 2 & t) { let i; Oy(i = function Ly() { return function sT(e, n) { return e[qt].queries[n].queryList }(C(), Sh()) }()) && (r.links = i) } }, inputs: { routerLinkActiveOptions: "routerLinkActiveOptions", ariaCurrentWhenActive: "ariaCurrentWhenActive", routerLinkActive: "routerLinkActive" }, outputs: { isActiveChange: "isActiveChange" }, exportAs: ["routerLinkActive"], standalone: !0, features: [Et] }), e })(); class LD { } let nF = (() => { class e { constructor(t, r, o, i, s) { this.router = t, this.injector = o, this.preloadingStrategy = i, this.loader = s } setUpPreloading() { this.subscription = this.router.events.pipe(Pn(t => t instanceof mr), $n(() => this.preload())).subscribe(() => { }) } preload() { return this.processRoutes(this.injector, this.router.config) } ngOnDestroy() { this.subscription && this.subscription.unsubscribe() } processRoutes(t, r) { const o = []; for (const i of r) { i.providers && !i._injector && (i._injector = ea(i.providers, t, `Route: ${i.path}`)); const s = i._injector ?? t, a = i._loadedInjector ?? s; (i.loadChildren && !i._loadedRoutes && void 0 === i.canLoad || i.loadComponent && !i._loadedComponent) && o.push(this.preloadConfig(s, i)), (i.children || i._loadedRoutes) && o.push(this.processRoutes(a, i.children ?? i._loadedRoutes)) } return Se(o).pipe(Er()) } preloadConfig(t, r) { return this.preloadingStrategy.preload(r, () => { let o; o = r.loadChildren && void 0 === r.canLoad ? this.loader.loadChildren(t, r) : R(null); const i = o.pipe(ke(s => null === s ? R(void 0) : (r._loadedRoutes = s.routes, r._loadedInjector = s.injector, this.processRoutes(s.injector ?? t, s.routes)))); return r.loadComponent && !r._loadedComponent ? Se([i, this.loader.loadComponent(r)]).pipe(Er()) : i }) } } return e.\u0275fac = function (t) { return new (t || e)(T(Fe), T(sv), T(Xt), T(LD), T(Wd)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); const Kd = new A(""); let VD = (() => { class e { constructor(t, r, o, i, s = {}) { this.urlSerializer = t, this.transitions = r, this.viewportScroller = o, this.zone = i, this.options = s, this.lastId = 0, this.lastSource = "imperative", this.restoredId = 0, this.store = {}, s.scrollPositionRestoration = s.scrollPositionRestoration || "disabled", s.anchorScrolling = s.anchorScrolling || "disabled" } init() { "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.setHistoryScrollRestoration("manual"), this.routerEventsSubscription = this.createScrollEvents(), this.scrollEventsSubscription = this.consumeScrollEvents() } createScrollEvents() { return this.transitions.events.subscribe(t => { t instanceof xd ? (this.store[this.lastId] = this.viewportScroller.getScrollPosition(), this.lastSource = t.navigationTrigger, this.restoredId = t.restoredState ? t.restoredState.navigationId : 0) : t instanceof mr && (this.lastId = t.id, this.scheduleScrollEvent(t, this.urlSerializer.parse(t.urlAfterRedirects).fragment)) }) } consumeScrollEvents() { return this.transitions.events.subscribe(t => { t instanceof iD && (t.position ? "top" === this.options.scrollPositionRestoration ? this.viewportScroller.scrollToPosition([0, 0]) : "enabled" === this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition(t.position) : t.anchor && "enabled" === this.options.anchorScrolling ? this.viewportScroller.scrollToAnchor(t.anchor) : "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition([0, 0])) }) } scheduleScrollEvent(t, r) { this.zone.runOutsideAngular(() => { setTimeout(() => { this.zone.run(() => { this.transitions.events.next(new iD(t, "popstate" === this.lastSource ? this.store[this.restoredId] : null, r)) }) }, 0) }) } ngOnDestroy() { this.routerEventsSubscription?.unsubscribe(), this.scrollEventsSubscription?.unsubscribe() } } return e.\u0275fac = function (t) { !function _g() { throw new Error("invalid") }() }, e.\u0275prov = x({ token: e, factory: e.\u0275fac }), e })(); var _t = (() => ((_t = _t || {})[_t.COMPLETE = 0] = "COMPLETE", _t[_t.FAILED = 1] = "FAILED", _t[_t.REDIRECTING = 2] = "REDIRECTING", _t))(); const Co = !1; function zn(e, n) { return { \u0275kind: e, \u0275providers: n } } const Zd = new A("", { providedIn: "root", factory: () => !1 }); function BD() { const e = W(Jt); return n => { const t = e.get(aa); if (n !== t.components[0]) return; const r = e.get(Fe), o = e.get($D); 1 === e.get(Yd) && r.initialNavigation(), e.get(UD, null, k.Optional)?.setUpPreloading(), e.get(Kd, null, k.Optional)?.init(), r.resetRootComponentType(t.componentTypes[0]), o.closed || (o.next(), o.unsubscribe()) } } const $D = new A(Co ? "bootstrap done indicator" : "", { factory: () => new hn }), Yd = new A(Co ? "initial navigation" : "", { providedIn: "root", factory: () => 1 }); function aF() { let e = []; return e = Co ? [{ provide: Os, multi: !0, useFactory: () => { const n = W(Fe); return () => n.events.subscribe(t => { console.group?.(`Router Event: ${t.constructor.name}`), console.log(function FR(e) { if (!("type" in e)) return `Unknown Router Event: ${e.constructor.name}`; switch (e.type) { case 14: return `ActivationEnd(path: '${e.snapshot.routeConfig?.path || ""}')`; case 13: return `ActivationStart(path: '${e.snapshot.routeConfig?.path || ""}')`; case 12: return `ChildActivationEnd(path: '${e.snapshot.routeConfig?.path || ""}')`; case 11: return `ChildActivationStart(path: '${e.snapshot.routeConfig?.path || ""}')`; case 8: return `GuardsCheckEnd(id: ${e.id}, url: '${e.url}', urlAfterRedirects: '${e.urlAfterRedirects}', state: ${e.state}, shouldActivate: ${e.shouldActivate})`; case 7: return `GuardsCheckStart(id: ${e.id}, url: '${e.url}', urlAfterRedirects: '${e.urlAfterRedirects}', state: ${e.state})`; case 2: return `NavigationCancel(id: ${e.id}, url: '${e.url}')`; case 16: return `NavigationSkipped(id: ${e.id}, url: '${e.url}')`; case 1: return `NavigationEnd(id: ${e.id}, url: '${e.url}', urlAfterRedirects: '${e.urlAfterRedirects}')`; case 3: return `NavigationError(id: ${e.id}, url: '${e.url}', error: ${e.error})`; case 0: return `NavigationStart(id: ${e.id}, url: '${e.url}')`; case 6: return `ResolveEnd(id: ${e.id}, url: '${e.url}', urlAfterRedirects: '${e.urlAfterRedirects}', state: ${e.state})`; case 5: return `ResolveStart(id: ${e.id}, url: '${e.url}', urlAfterRedirects: '${e.urlAfterRedirects}', state: ${e.state})`; case 10: return `RouteConfigLoadEnd(path: ${e.route.path})`; case 9: return `RouteConfigLoadStart(path: ${e.route.path})`; case 4: return `RoutesRecognized(id: ${e.id}, url: '${e.url}', urlAfterRedirects: '${e.urlAfterRedirects}', state: ${e.state})`; case 15: return `Scroll(anchor: '${e.anchor}', position: '${e.position ? `${e.position[0]}, ${e.position[1]}` : null}')` } }(t)), console.log(t), console.groupEnd?.() }) } }] : [], zn(1, e) } const UD = new A(Co ? "router preloader" : ""); function lF(e) { return zn(0, [{ provide: UD, useExisting: nF }, { provide: LD, useExisting: e }]) } const $i = !1, HD = new A($i ? "router duplicate forRoot guard" : "ROUTER_FORROOT_GUARD"), uF = [Zc, { provide: Ti, useClass: Ed }, Fe, Oi, { provide: yr, useFactory: function jD(e) { return e.routerState.root }, deps: [Fe] }, Wd, $i ? { provide: Zd, useValue: !0 } : []]; function cF() { return new pv("Router", Fe) } let zD = (() => { class e { constructor(t) { } static forRoot(t, r) { return { ngModule: e, providers: [uF, $i && r?.enableTracing ? aF().\u0275providers : [], { provide: Do, multi: !0, useValue: t }, { provide: HD, useFactory: pF, deps: [[Fe, new Ho, new zo]] }, { provide: Za, useValue: r || {} }, r?.useHash ? { provide: hr, useClass: g1 } : { provide: hr, useClass: Lv }, { provide: Kd, useFactory: () => { const e = W(Nx), n = W(De), t = W(Za), r = W(Ka), o = W(Ti); return t.scrollOffset && e.setOffset(t.scrollOffset), new VD(o, r, e, n, t) } }, r?.preloadingStrategy ? lF(r.preloadingStrategy).\u0275providers : [], { provide: pv, multi: !0, useFactory: cF }, r?.initialNavigation ? gF(r) : [], [{ provide: GD, useFactory: BD }, { provide: hv, multi: !0, useExisting: GD }]] } } static forChild(t) { return { ngModule: e, providers: [{ provide: Do, multi: !0, useValue: t }] } } } return e.\u0275fac = function (t) { return new (t || e)(T(HD, 8)) }, e.\u0275mod = ft({ type: e }), e.\u0275inj = ot({ imports: [jd] }), e })(); function pF(e) { if ($i && e) throw new b(4007, "The Router was provided more than once. This can happen if 'forRoot' is used outside of the root injector. Lazy loaded modules should use RouterModule.forChild() instead."); return "guarded" } function gF(e) { return ["disabled" === e.initialNavigation ? zn(3, [{ provide: oa, multi: !0, useFactory: () => { const n = W(Fe); return () => { n.setUpLocationChangeListener() } } }, { provide: Yd, useValue: 2 }]).\u0275providers : [], "enabledBlocking" === e.initialNavigation ? zn(2, [{ provide: Yd, useValue: 0 }, { provide: oa, multi: !0, deps: [Jt], useFactory: n => { const t = n.get(h1, Promise.resolve()); return () => t.then(() => new Promise(r => { const o = n.get(Fe), i = n.get($D); (function rF(e, n) { e.events.pipe(Pn(t => t instanceof mr || t instanceof La || t instanceof Pd || t instanceof Va), G(t => t instanceof mr || t instanceof Va ? _t.COMPLETE : t instanceof La && (0 === t.code || 1 === t.code) ? _t.REDIRECTING : _t.FAILED), Pn(t => t !== _t.REDIRECTING), Mi(1)).subscribe(() => { n() }) })(o, () => { r(!0) }), n.get(Ka).afterPreactivation = () => (r(!0), i.closed ? R(void 0) : i), o.initialNavigation() })) } }]).\u0275providers : []] } const GD = new A($i ? "Router Initializer" : ""); class Ya { } class Qd { } class dn { constructor(n) { this.normalizedNames = new Map, this.lazyUpdate = null, n ? this.lazyInit = "string" == typeof n ? () => { this.headers = new Map, n.split("\n").forEach(t => { const r = t.indexOf(":"); if (r > 0) { const o = t.slice(0, r), i = o.toLowerCase(), s = t.slice(r + 1).trim(); this.maybeSetNormalizedName(o, i), this.headers.has(i) ? this.headers.get(i).push(s) : this.headers.set(i, [s]) } }) } : () => { this.headers = new Map, Object.keys(n).forEach(t => { let r = n[t]; const o = t.toLowerCase(); "string" == typeof r && (r = [r]), r.length > 0 && (this.headers.set(o, r), this.maybeSetNormalizedName(t, o)) }) } : this.headers = new Map } has(n) { return this.init(), this.headers.has(n.toLowerCase()) } get(n) { this.init(); const t = this.headers.get(n.toLowerCase()); return t && t.length > 0 ? t[0] : null } keys() { return this.init(), Array.from(this.normalizedNames.values()) } getAll(n) { return this.init(), this.headers.get(n.toLowerCase()) || null } append(n, t) { return this.clone({ name: n, value: t, op: "a" }) } set(n, t) { return this.clone({ name: n, value: t, op: "s" }) } delete(n, t) { return this.clone({ name: n, value: t, op: "d" }) } maybeSetNormalizedName(n, t) { this.normalizedNames.has(t) || this.normalizedNames.set(t, n) } init() { this.lazyInit && (this.lazyInit instanceof dn ? this.copyFrom(this.lazyInit) : this.lazyInit(), this.lazyInit = null, this.lazyUpdate && (this.lazyUpdate.forEach(n => this.applyUpdate(n)), this.lazyUpdate = null)) } copyFrom(n) { n.init(), Array.from(n.headers.keys()).forEach(t => { this.headers.set(t, n.headers.get(t)), this.normalizedNames.set(t, n.normalizedNames.get(t)) }) } clone(n) { const t = new dn; return t.lazyInit = this.lazyInit && this.lazyInit instanceof dn ? this.lazyInit : this, t.lazyUpdate = (this.lazyUpdate || []).concat([n]), t } applyUpdate(n) { const t = n.name.toLowerCase(); switch (n.op) { case "a": case "s": let r = n.value; if ("string" == typeof r && (r = [r]), 0 === r.length) return; this.maybeSetNormalizedName(n.name, t); const o = ("a" === n.op ? this.headers.get(t) : void 0) || []; o.push(...r), this.headers.set(t, o); break; case "d": const i = n.value; if (i) { let s = this.headers.get(t); if (!s) return; s = s.filter(a => -1 === i.indexOf(a)), 0 === s.length ? (this.headers.delete(t), this.normalizedNames.delete(t)) : this.headers.set(t, s) } else this.headers.delete(t), this.normalizedNames.delete(t) } } forEach(n) { this.init(), Array.from(this.normalizedNames.keys()).forEach(t => n(this.normalizedNames.get(t), this.headers.get(t))) } } class yF { encodeKey(n) { return WD(n) } encodeValue(n) { return WD(n) } decodeKey(n) { return decodeURIComponent(n) } decodeValue(n) { return decodeURIComponent(n) } } const _F = /%(\d[a-f0-9])/gi, DF = { 40: "@", "3A": ":", 24: "$", "2C": ",", "3B": ";", "3D": "=", "3F": "?", "2F": "/" }; function WD(e) { return encodeURIComponent(e).replace(_F, (n, t) => DF[t] ?? n) } function Qa(e) { return `${e}` } class Gn { constructor(n = {}) { if (this.updates = null, this.cloneFrom = null, this.encoder = n.encoder || new yF, n.fromString) { if (n.fromObject) throw new Error("Cannot specify both fromString and fromObject."); this.map = function vF(e, n) { const t = new Map; return e.length > 0 && e.replace(/^\?/, "").split("&").forEach(o => { const i = o.indexOf("="), [s, a] = -1 == i ? [n.decodeKey(o), ""] : [n.decodeKey(o.slice(0, i)), n.decodeValue(o.slice(i + 1))], l = t.get(s) || []; l.push(a), t.set(s, l) }), t }(n.fromString, this.encoder) } else n.fromObject ? (this.map = new Map, Object.keys(n.fromObject).forEach(t => { const r = n.fromObject[t], o = Array.isArray(r) ? r.map(Qa) : [Qa(r)]; this.map.set(t, o) })) : this.map = null } has(n) { return this.init(), this.map.has(n) } get(n) { this.init(); const t = this.map.get(n); return t ? t[0] : null } getAll(n) { return this.init(), this.map.get(n) || null } keys() { return this.init(), Array.from(this.map.keys()) } append(n, t) { return this.clone({ param: n, value: t, op: "a" }) } appendAll(n) { const t = []; return Object.keys(n).forEach(r => { const o = n[r]; Array.isArray(o) ? o.forEach(i => { t.push({ param: r, value: i, op: "a" }) }) : t.push({ param: r, value: o, op: "a" }) }), this.clone(t) } set(n, t) { return this.clone({ param: n, value: t, op: "s" }) } delete(n, t) { return this.clone({ param: n, value: t, op: "d" }) } toString() { return this.init(), this.keys().map(n => { const t = this.encoder.encodeKey(n); return this.map.get(n).map(r => t + "=" + this.encoder.encodeValue(r)).join("&") }).filter(n => "" !== n).join("&") } clone(n) { const t = new Gn({ encoder: this.encoder }); return t.cloneFrom = this.cloneFrom || this, t.updates = (this.updates || []).concat(n), t } init() { null === this.map && (this.map = new Map), null !== this.cloneFrom && (this.cloneFrom.init(), this.cloneFrom.keys().forEach(n => this.map.set(n, this.cloneFrom.map.get(n))), this.updates.forEach(n => { switch (n.op) { case "a": case "s": const t = ("a" === n.op ? this.map.get(n.param) : void 0) || []; t.push(Qa(n.value)), this.map.set(n.param, t); break; case "d": if (void 0 === n.value) { this.map.delete(n.param); break } { let r = this.map.get(n.param) || []; const o = r.indexOf(Qa(n.value)); -1 !== o && r.splice(o, 1), r.length > 0 ? this.map.set(n.param, r) : this.map.delete(n.param) } } }), this.cloneFrom = this.updates = null) } } class CF { constructor() { this.map = new Map } set(n, t) { return this.map.set(n, t), this } get(n) { return this.map.has(n) || this.map.set(n, n.defaultValue()), this.map.get(n) } delete(n) { return this.map.delete(n), this } has(n) { return this.map.has(n) } keys() { return this.map.keys() } } function qD(e) { return typeof ArrayBuffer < "u" && e instanceof ArrayBuffer } function KD(e) { return typeof Blob < "u" && e instanceof Blob } function ZD(e) { return typeof FormData < "u" && e instanceof FormData } class Ui { constructor(n, t, r, o) { let i; if (this.url = t, this.body = null, this.reportProgress = !1, this.withCredentials = !1, this.responseType = "json", this.method = n.toUpperCase(), function wF(e) { switch (e) { case "DELETE": case "GET": case "HEAD": case "OPTIONS": case "JSONP": return !1; default: return !0 } }(this.method) || o ? (this.body = void 0 !== r ? r : null, i = o) : i = r, i && (this.reportProgress = !!i.reportProgress, this.withCredentials = !!i.withCredentials, i.responseType && (this.responseType = i.responseType), i.headers && (this.headers = i.headers), i.context && (this.context = i.context), i.params && (this.params = i.params)), this.headers || (this.headers = new dn), this.context || (this.context = new CF), this.params) { const s = this.params.toString(); if (0 === s.length) this.urlWithParams = t; else { const a = t.indexOf("?"); this.urlWithParams = t + (-1 === a ? "?" : a < t.length - 1 ? "&" : "") + s } } else this.params = new Gn, this.urlWithParams = t } serializeBody() { return null === this.body ? null : qD(this.body) || KD(this.body) || ZD(this.body) || function bF(e) { return typeof URLSearchParams < "u" && e instanceof URLSearchParams }(this.body) || "string" == typeof this.body ? this.body : this.body instanceof Gn ? this.body.toString() : "object" == typeof this.body || "boolean" == typeof this.body || Array.isArray(this.body) ? JSON.stringify(this.body) : this.body.toString() } detectContentTypeHeader() { return null === this.body || ZD(this.body) ? null : KD(this.body) ? this.body.type || null : qD(this.body) ? null : "string" == typeof this.body ? "text/plain" : this.body instanceof Gn ? "application/x-www-form-urlencoded;charset=UTF-8" : "object" == typeof this.body || "number" == typeof this.body || "boolean" == typeof this.body ? "application/json" : null } clone(n = {}) { const t = n.method || this.method, r = n.url || this.url, o = n.responseType || this.responseType, i = void 0 !== n.body ? n.body : this.body, s = void 0 !== n.withCredentials ? n.withCredentials : this.withCredentials, a = void 0 !== n.reportProgress ? n.reportProgress : this.reportProgress; let l = n.headers || this.headers, u = n.params || this.params; const c = n.context ?? this.context; return void 0 !== n.setHeaders && (l = Object.keys(n.setHeaders).reduce((d, f) => d.set(f, n.setHeaders[f]), l)), n.setParams && (u = Object.keys(n.setParams).reduce((d, f) => d.set(f, n.setParams[f]), u)), new Ui(t, r, i, { params: u, headers: l, context: c, reportProgress: a, responseType: o, withCredentials: s }) } } var Te = (() => ((Te = Te || {})[Te.Sent = 0] = "Sent", Te[Te.UploadProgress = 1] = "UploadProgress", Te[Te.ResponseHeader = 2] = "ResponseHeader", Te[Te.DownloadProgress = 3] = "DownloadProgress", Te[Te.Response = 4] = "Response", Te[Te.User = 5] = "User", Te))(); class Xd { constructor(n, t = 200, r = "OK") { this.headers = n.headers || new dn, this.status = void 0 !== n.status ? n.status : t, this.statusText = n.statusText || r, this.url = n.url || null, this.ok = this.status >= 200 && this.status < 300 } } class Jd extends Xd { constructor(n = {}) { super(n), this.type = Te.ResponseHeader } clone(n = {}) { return new Jd({ headers: n.headers || this.headers, status: void 0 !== n.status ? n.status : this.status, statusText: n.statusText || this.statusText, url: n.url || this.url || void 0 }) } } class Xa extends Xd { constructor(n = {}) { super(n), this.type = Te.Response, this.body = void 0 !== n.body ? n.body : null } clone(n = {}) { return new Xa({ body: void 0 !== n.body ? n.body : this.body, headers: n.headers || this.headers, status: void 0 !== n.status ? n.status : this.status, statusText: n.statusText || this.statusText, url: n.url || this.url || void 0 }) } } class YD extends Xd { constructor(n) { super(n, 0, "Unknown Error"), this.name = "HttpErrorResponse", this.ok = !1, this.message = this.status >= 200 && this.status < 300 ? `Http failure during parsing for ${n.url || "(unknown url)"}` : `Http failure response for ${n.url || "(unknown url)"}: ${n.status} ${n.statusText}`, this.error = n.error || null } } function ef(e, n) { return { body: n, headers: e.headers, context: e.context, observe: e.observe, params: e.params, reportProgress: e.reportProgress, responseType: e.responseType, withCredentials: e.withCredentials } } let QD = (() => { class e { constructor(t) { this.handler = t } request(t, r, o = {}) { let i; if (t instanceof Ui) i = t; else { let l, u; l = o.headers instanceof dn ? o.headers : new dn(o.headers), o.params && (u = o.params instanceof Gn ? o.params : new Gn({ fromObject: o.params })), i = new Ui(t, r, void 0 !== o.body ? o.body : null, { headers: l, context: o.context, params: u, reportProgress: o.reportProgress, responseType: o.responseType || "json", withCredentials: o.withCredentials }) } const s = R(i).pipe($n(l => this.handler.handle(l))); if (t instanceof Ui || "events" === o.observe) return s; const a = s.pipe(Pn(l => l instanceof Xa)); switch (o.observe || "body") { case "body": switch (i.responseType) { case "arraybuffer": return a.pipe(G(l => { if (null !== l.body && !(l.body instanceof ArrayBuffer)) throw new Error("Response is not an ArrayBuffer."); return l.body })); case "blob": return a.pipe(G(l => { if (null !== l.body && !(l.body instanceof Blob)) throw new Error("Response is not a Blob."); return l.body })); case "text": return a.pipe(G(l => { if (null !== l.body && "string" != typeof l.body) throw new Error("Response is not a string."); return l.body })); default: return a.pipe(G(l => l.body)) }case "response": return a; default: throw new Error(`Unreachable: unhandled observe type ${o.observe}}`) } } delete(t, r = {}) { return this.request("DELETE", t, r) } get(t, r = {}) { return this.request("GET", t, r) } head(t, r = {}) { return this.request("HEAD", t, r) } jsonp(t, r) { return this.request("JSONP", t, { params: (new Gn).append(r, "JSONP_CALLBACK"), observe: "body", responseType: "json" }) } options(t, r = {}) { return this.request("OPTIONS", t, r) } patch(t, r, o = {}) { return this.request("PATCH", t, ef(o, r)) } post(t, r, o = {}) { return this.request("POST", t, ef(o, r)) } put(t, r, o = {}) { return this.request("PUT", t, ef(o, r)) } } return e.\u0275fac = function (t) { return new (t || e)(T(Ya)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac }), e })(); function XD(e, n) { return n(e) } function EF(e, n) { return (t, r) => n.intercept(t, { handle: o => e(o, r) }) } const MF = new A("HTTP_INTERCEPTORS"), Hi = new A("HTTP_INTERCEPTOR_FNS"); function IF() { let e = null; return (n, t) => (null === e && (e = (W(MF, { optional: !0 }) ?? []).reduceRight(EF, XD)), e(n, t)) } let JD = (() => { class e extends Ya { constructor(t, r) { super(), this.backend = t, this.injector = r, this.chain = null } handle(t) { if (null === this.chain) { const r = Array.from(new Set(this.injector.get(Hi))); this.chain = r.reduceRight((o, i) => function SF(e, n, t) { return (r, o) => t.runInContext(() => n(r, i => e(i, o))) }(o, i, this.injector), XD) } return this.chain(t, r => this.backend.handle(r)) } } return e.\u0275fac = function (t) { return new (t || e)(T(Qd), T(Xt)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac }), e })(); const PF = /^\)\]\}',?\n/; let tC = (() => { class e { constructor(t) { this.xhrFactory = t } handle(t) { if ("JSONP" === t.method) throw new Error("Attempted to construct Jsonp request without HttpClientJsonpModule installed."); return new ve(r => { const o = this.xhrFactory.build(); if (o.open(t.method, t.urlWithParams), t.withCredentials && (o.withCredentials = !0), t.headers.forEach((h, p) => o.setRequestHeader(h, p.join(","))), t.headers.has("Accept") || o.setRequestHeader("Accept", "application/json, text/plain, */*"), !t.headers.has("Content-Type")) { const h = t.detectContentTypeHeader(); null !== h && o.setRequestHeader("Content-Type", h) } if (t.responseType) { const h = t.responseType.toLowerCase(); o.responseType = "json" !== h ? h : "text" } const i = t.serializeBody(); let s = null; const a = () => { if (null !== s) return s; const h = o.statusText || "OK", p = new dn(o.getAllResponseHeaders()), g = function RF(e) { return "responseURL" in e && e.responseURL ? e.responseURL : /^X-Request-URL:/m.test(e.getAllResponseHeaders()) ? e.getResponseHeader("X-Request-URL") : null }(o) || t.url; return s = new Jd({ headers: p, status: o.status, statusText: h, url: g }), s }, l = () => { let { headers: h, status: p, statusText: g, url: m } = a(), D = null; 204 !== p && (D = typeof o.response > "u" ? o.responseText : o.response), 0 === p && (p = D ? 200 : 0); let S = p >= 200 && p < 300; if ("json" === t.responseType && "string" == typeof D) { const _ = D; D = D.replace(PF, ""); try { D = "" !== D ? JSON.parse(D) : null } catch (F) { D = _, S && (S = !1, D = { error: F, text: D }) } } S ? (r.next(new Xa({ body: D, headers: h, status: p, statusText: g, url: m || void 0 })), r.complete()) : r.error(new YD({ error: D, headers: h, status: p, statusText: g, url: m || void 0 })) }, u = h => { const { url: p } = a(), g = new YD({ error: h, status: o.status || 0, statusText: o.statusText || "Unknown Error", url: p || void 0 }); r.error(g) }; let c = !1; const d = h => { c || (r.next(a()), c = !0); let p = { type: Te.DownloadProgress, loaded: h.loaded }; h.lengthComputable && (p.total = h.total), "text" === t.responseType && o.responseText && (p.partialText = o.responseText), r.next(p) }, f = h => { let p = { type: Te.UploadProgress, loaded: h.loaded }; h.lengthComputable && (p.total = h.total), r.next(p) }; return o.addEventListener("load", l), o.addEventListener("error", u), o.addEventListener("timeout", u), o.addEventListener("abort", u), t.reportProgress && (o.addEventListener("progress", d), null !== i && o.upload && o.upload.addEventListener("progress", f)), o.send(i), r.next({ type: Te.Sent }), () => { o.removeEventListener("error", u), o.removeEventListener("abort", u), o.removeEventListener("load", l), o.removeEventListener("timeout", u), t.reportProgress && (o.removeEventListener("progress", d), null !== i && o.upload && o.upload.removeEventListener("progress", f)), o.readyState !== o.DONE && o.abort() } }) } } return e.\u0275fac = function (t) { return new (t || e)(T(i_)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac }), e })(); const tf = new A("XSRF_ENABLED"), nC = new A("XSRF_COOKIE_NAME", { providedIn: "root", factory: () => "XSRF-TOKEN" }), rC = new A("XSRF_HEADER_NAME", { providedIn: "root", factory: () => "X-XSRF-TOKEN" }); class oC { } let OF = (() => { class e { constructor(t, r, o) { this.doc = t, this.platform = r, this.cookieName = o, this.lastCookieString = "", this.lastToken = null, this.parseCount = 0 } getToken() { if ("server" === this.platform) return null; const t = this.doc.cookie || ""; return t !== this.lastCookieString && (this.parseCount++, this.lastToken = qv(t, this.cookieName), this.lastCookieString = t), this.lastToken } } return e.\u0275fac = function (t) { return new (t || e)(T(nt), T(Nc), T(nC)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac }), e })(); function kF(e, n) { const t = e.url.toLowerCase(); if (!W(tf) || "GET" === e.method || "HEAD" === e.method || t.startsWith("http://") || t.startsWith("https://")) return n(e); const r = W(oC).getToken(), o = W(rC); return null != r && !e.headers.has(o) && (e = e.clone({ headers: e.headers.set(o, r) })), n(e) } var be = (() => ((be = be || {})[be.Interceptors = 0] = "Interceptors", be[be.LegacyInterceptors = 1] = "LegacyInterceptors", be[be.CustomXsrfConfiguration = 2] = "CustomXsrfConfiguration", be[be.NoXsrfProtection = 3] = "NoXsrfProtection", be[be.JsonpSupport = 4] = "JsonpSupport", be[be.RequestsMadeViaParent = 5] = "RequestsMadeViaParent", be))(); function wo(e, n) { return { \u0275kind: e, \u0275providers: n } } function LF(...e) { const n = [QD, tC, JD, { provide: Ya, useExisting: JD }, { provide: Qd, useExisting: tC }, { provide: Hi, useValue: kF, multi: !0 }, { provide: tf, useValue: !0 }, { provide: oC, useClass: OF }]; for (const t of e) n.push(...t.\u0275providers); return function P0(e) { return { \u0275providers: e } }(n) } const iC = new A("LEGACY_INTERCEPTOR_FN"); let jF = (() => { class e { } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275mod = ft({ type: e }), e.\u0275inj = ot({ providers: [LF(wo(be.LegacyInterceptors, [{ provide: iC, useFactory: IF }, { provide: Hi, useExisting: iC, multi: !0 }]))] }), e })(), _r = (() => { class e { constructor(t) { this.http = t, this.baseUrl = "http://localhost:3000", this.header = new dn, this.header = this.header.append("Accept", "application/json"), this.header = this.header.append("Content-Type", "application/json"), localStorage.getItem("token") && (this.header = this.header.set("Authorization", `Bearer ${localStorage.getItem("token")}`)) } get(t) { let r = this.baseUrl + t; return new Promise((o, i) => { this.http.get(r, { headers: this.header }).pipe(ln(s => (i(s), s))).subscribe(s => { o(s) }) }) } post(t, r) { let o = this.baseUrl + t; return new Promise((i, s) => { this.http.post(o, r, { headers: this.header }).pipe(ln(a => (s(a), a))).subscribe(a => { i(a) }) }) } patch(t, r) { let o = this.baseUrl + t; return new Promise((i, s) => { this.http.patch(o, r, { headers: this.header }).subscribe(a => { i(a) }, a => { s(a) }) }) } login(t, r) { const o = { phonenumber: t, password: r }; return new Promise((i, s) => { this.http.post(`${this.baseUrl}/login`, o).subscribe(a => { this.header = this.header.set("Authorization", `Bearer ${a.data.access_token}`), localStorage.setItem("token", a.data.access_token), localStorage.setItem("phone", t), i(a) }, a => s(a)) }) } register(t, r, o) { return this.post("/register", { username: t, password: r, email: o }) } logout() { localStorage.removeItem("token"), localStorage.removeItem("phone") } } return e.\u0275fac = function (t) { return new (t || e)(T(QD)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(), sC = (() => { class e { constructor(t, r) { this._renderer = t, this._elementRef = r, this.onChange = o => { }, this.onTouched = () => { } } setProperty(t, r) { this._renderer.setProperty(this._elementRef.nativeElement, t, r) } registerOnTouched(t) { this.onTouched = t } registerOnChange(t) { this.onChange = t } setDisabledState(t) { this.setProperty("disabled", t) } } return e.\u0275fac = function (t) { return new (t || e)(y(wn), y(lt)) }, e.\u0275dir = V({ type: e }), e })(), Dr = (() => { class e extends sC { } return e.\u0275fac = function () { let n; return function (r) { return (n || (n = je(e)))(r || e) } }(), e.\u0275dir = V({ type: e, features: [re] }), e })(); const fn = new A("NgValueAccessor"), UF = { provide: fn, useExisting: le(() => Nn), multi: !0 }, zF = new A("CompositionEventMode"); let Nn = (() => { class e extends sC { constructor(t, r, o) { super(t, r), this._compositionMode = o, this._composing = !1, null == this._compositionMode && (this._compositionMode = !function HF() { const e = An() ? An().getUserAgent() : ""; return /android (\d+)/.test(e.toLowerCase()) }()) } writeValue(t) { this.setProperty("value", t ?? "") } _handleInput(t) { (!this._compositionMode || this._compositionMode && !this._composing) && this.onChange(t) } _compositionStart() { this._composing = !0 } _compositionEnd(t) { this._composing = !1, this._compositionMode && this.onChange(t) } } return e.\u0275fac = function (t) { return new (t || e)(y(wn), y(lt), y(zF, 8)) }, e.\u0275dir = V({ type: e, selectors: [["input", "formControlName", "", 3, "type", "checkbox"], ["textarea", "formControlName", ""], ["input", "formControl", "", 3, "type", "checkbox"], ["textarea", "formControl", ""], ["input", "ngModel", "", 3, "type", "checkbox"], ["textarea", "ngModel", ""], ["", "ngDefaultControl", ""]], hostBindings: function (t, r) { 1 & t && Z("input", function (i) { return r._handleInput(i.target.value) })("blur", function () { return r.onTouched() })("compositionstart", function () { return r._compositionStart() })("compositionend", function (i) { return r._compositionEnd(i.target.value) }) }, features: [fe([UF]), re] }), e })(); const GF = !1; function Wn(e) { return null == e || ("string" == typeof e || Array.isArray(e)) && 0 === e.length } const Ye = new A("NgValidators"), qn = new A("NgAsyncValidators"); function dC(e) { return Wn(e.value) ? { required: !0 } : null } function Ja(e) { return null } function yC(e) { return null != e } function vC(e) { const n = ii(e) ? Se(e) : e; if (GF && !nc(n)) { let t = "Expected async validator to return Promise or Observable."; throw "object" == typeof e && (t += " Are you using a synchronous validator where an async validator is expected?"), new b(-1101, t) } return n } function _C(e) { let n = {}; return e.forEach(t => { n = null != t ? { ...n, ...t } : n }), 0 === Object.keys(n).length ? null : n } function DC(e, n) { return n.map(t => t(e)) } function CC(e) { return e.map(n => function qF(e) { return !e.validate }(n) ? n : t => n.validate(t)) } function nf(e) { return null != e ? function wC(e) { if (!e) return null; const n = e.filter(yC); return 0 == n.length ? null : function (t) { return _C(DC(t, n)) } }(CC(e)) : null } function rf(e) { return null != e ? function bC(e) { if (!e) return null; const n = e.filter(yC); return 0 == n.length ? null : function (t) { return function BF(...e) { const n = Wf(e), { args: t, keys: r } = x_(e), o = new ve(i => { const { length: s } = t; if (!s) return void i.complete(); const a = new Array(s); let l = s, u = s; for (let c = 0; c < s; c++) { let d = !1; Ct(t[c]).subscribe(xe(i, f => { d || (d = !0, u--), a[c] = f }, () => l--, void 0, () => { (!l || !d) && (u || i.next(r ? R_(r, a) : a), i.complete()) })) } }); return n ? o.pipe(P_(n)) : o }(DC(t, n).map(vC)).pipe(G(_C)) } }(CC(e)) : null } function EC(e, n) { return null === e ? [n] : Array.isArray(e) ? [...e, n] : [e, n] } function sf(e) { return e ? Array.isArray(e) ? e : [e] : [] } function el(e, n) { return Array.isArray(e) ? e.includes(n) : e === n } function IC(e, n) { const t = sf(n); return sf(e).forEach(o => { el(t, o) || t.push(o) }), t } function AC(e, n) { return sf(n).filter(t => !el(e, t)) } class TC { constructor() { this._rawValidators = [], this._rawAsyncValidators = [], this._onDestroyCallbacks = [] } get value() { return this.control ? this.control.value : null } get valid() { return this.control ? this.control.valid : null } get invalid() { return this.control ? this.control.invalid : null } get pending() { return this.control ? this.control.pending : null } get disabled() { return this.control ? this.control.disabled : null } get enabled() { return this.control ? this.control.enabled : null } get errors() { return this.control ? this.control.errors : null } get pristine() { return this.control ? this.control.pristine : null } get dirty() { return this.control ? this.control.dirty : null } get touched() { return this.control ? this.control.touched : null } get status() { return this.control ? this.control.status : null } get untouched() { return this.control ? this.control.untouched : null } get statusChanges() { return this.control ? this.control.statusChanges : null } get valueChanges() { return this.control ? this.control.valueChanges : null } get path() { return null } _setValidators(n) { this._rawValidators = n || [], this._composedValidatorFn = nf(this._rawValidators) } _setAsyncValidators(n) { this._rawAsyncValidators = n || [], this._composedAsyncValidatorFn = rf(this._rawAsyncValidators) } get validator() { return this._composedValidatorFn || null } get asyncValidator() { return this._composedAsyncValidatorFn || null } _registerOnDestroy(n) { this._onDestroyCallbacks.push(n) } _invokeOnDestroyCallbacks() { this._onDestroyCallbacks.forEach(n => n()), this._onDestroyCallbacks = [] } reset(n) { this.control && this.control.reset(n) } hasError(n, t) { return !!this.control && this.control.hasError(n, t) } getError(n, t) { return this.control ? this.control.getError(n, t) : null } } class rt extends TC { get formDirective() { return null } get path() { return null } } class Kn extends TC { constructor() { super(...arguments), this._parent = null, this.name = null, this.valueAccessor = null } } class xC { constructor(n) { this._cd = n } get isTouched() { return !!this._cd?.control?.touched } get isUntouched() { return !!this._cd?.control?.untouched } get isPristine() { return !!this._cd?.control?.pristine } get isDirty() { return !!this._cd?.control?.dirty } get isValid() { return !!this._cd?.control?.valid } get isInvalid() { return !!this._cd?.control?.invalid } get isPending() { return !!this._cd?.control?.pending } get isSubmitted() { return !!this._cd?.submitted } } let Cr = (() => { class e extends xC { constructor(t) { super(t) } } return e.\u0275fac = function (t) { return new (t || e)(y(Kn, 2)) }, e.\u0275dir = V({ type: e, selectors: [["", "formControlName", ""], ["", "ngModel", ""], ["", "formControl", ""]], hostVars: 14, hostBindings: function (t, r) { 2 & t && Ks("ng-untouched", r.isUntouched)("ng-touched", r.isTouched)("ng-pristine", r.isPristine)("ng-dirty", r.isDirty)("ng-valid", r.isValid)("ng-invalid", r.isInvalid)("ng-pending", r.isPending) }, features: [re] }), e })(), zi = (() => { class e extends xC { constructor(t) { super(t) } } return e.\u0275fac = function (t) { return new (t || e)(y(rt, 10)) }, e.\u0275dir = V({ type: e, selectors: [["", "formGroupName", ""], ["", "formArrayName", ""], ["", "ngModelGroup", ""], ["", "formGroup", ""], ["form", 3, "ngNoForm", ""], ["", "ngForm", ""]], hostVars: 16, hostBindings: function (t, r) { 2 & t && Ks("ng-untouched", r.isUntouched)("ng-touched", r.isTouched)("ng-pristine", r.isPristine)("ng-dirty", r.isDirty)("ng-valid", r.isValid)("ng-invalid", r.isInvalid)("ng-pending", r.isPending)("ng-submitted", r.isSubmitted) }, features: [re] }), e })(); function PC(e, n) { return e ? `with name: '${n}'` : `at index: ${n}` } const uf = !1, Gi = "VALID", nl = "INVALID", bo = "PENDING", Wi = "DISABLED"; function cf(e) { return (rl(e) ? e.validators : e) || null } function df(e, n) { return (rl(n) ? n.asyncValidators : e) || null } function rl(e) { return null != e && !Array.isArray(e) && "object" == typeof e } class FC { constructor(n, t) { this._pendingDirty = !1, this._hasOwnPendingAsyncValidator = !1, this._pendingTouched = !1, this._onCollectionChange = () => { }, this._parent = null, this.pristine = !0, this.touched = !1, this._onDisabledChange = [], this._assignValidators(n), this._assignAsyncValidators(t) } get validator() { return this._composedValidatorFn } set validator(n) { this._rawValidators = this._composedValidatorFn = n } get asyncValidator() { return this._composedAsyncValidatorFn } set asyncValidator(n) { this._rawAsyncValidators = this._composedAsyncValidatorFn = n } get parent() { return this._parent } get valid() { return this.status === Gi } get invalid() { return this.status === nl } get pending() { return this.status == bo } get disabled() { return this.status === Wi } get enabled() { return this.status !== Wi } get dirty() { return !this.pristine } get untouched() { return !this.touched } get updateOn() { return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : "change" } setValidators(n) { this._assignValidators(n) } setAsyncValidators(n) { this._assignAsyncValidators(n) } addValidators(n) { this.setValidators(IC(n, this._rawValidators)) } addAsyncValidators(n) { this.setAsyncValidators(IC(n, this._rawAsyncValidators)) } removeValidators(n) { this.setValidators(AC(n, this._rawValidators)) } removeAsyncValidators(n) { this.setAsyncValidators(AC(n, this._rawAsyncValidators)) } hasValidator(n) { return el(this._rawValidators, n) } hasAsyncValidator(n) { return el(this._rawAsyncValidators, n) } clearValidators() { this.validator = null } clearAsyncValidators() { this.asyncValidator = null } markAsTouched(n = {}) { this.touched = !0, this._parent && !n.onlySelf && this._parent.markAsTouched(n) } markAllAsTouched() { this.markAsTouched({ onlySelf: !0 }), this._forEachChild(n => n.markAllAsTouched()) } markAsUntouched(n = {}) { this.touched = !1, this._pendingTouched = !1, this._forEachChild(t => { t.markAsUntouched({ onlySelf: !0 }) }), this._parent && !n.onlySelf && this._parent._updateTouched(n) } markAsDirty(n = {}) { this.pristine = !1, this._parent && !n.onlySelf && this._parent.markAsDirty(n) } markAsPristine(n = {}) { this.pristine = !0, this._pendingDirty = !1, this._forEachChild(t => { t.markAsPristine({ onlySelf: !0 }) }), this._parent && !n.onlySelf && this._parent._updatePristine(n) } markAsPending(n = {}) { this.status = bo, !1 !== n.emitEvent && this.statusChanges.emit(this.status), this._parent && !n.onlySelf && this._parent.markAsPending(n) } disable(n = {}) { const t = this._parentMarkedDirty(n.onlySelf); this.status = Wi, this.errors = null, this._forEachChild(r => { r.disable({ ...n, onlySelf: !0 }) }), this._updateValue(), !1 !== n.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._updateAncestors({ ...n, skipPristineCheck: t }), this._onDisabledChange.forEach(r => r(!0)) } enable(n = {}) { const t = this._parentMarkedDirty(n.onlySelf); this.status = Gi, this._forEachChild(r => { r.enable({ ...n, onlySelf: !0 }) }), this.updateValueAndValidity({ onlySelf: !0, emitEvent: n.emitEvent }), this._updateAncestors({ ...n, skipPristineCheck: t }), this._onDisabledChange.forEach(r => r(!1)) } _updateAncestors(n) { this._parent && !n.onlySelf && (this._parent.updateValueAndValidity(n), n.skipPristineCheck || this._parent._updatePristine(), this._parent._updateTouched()) } setParent(n) { this._parent = n } getRawValue() { return this.value } updateValueAndValidity(n = {}) { this._setInitialStatus(), this._updateValue(), this.enabled && (this._cancelExistingSubscription(), this.errors = this._runValidator(), this.status = this._calculateStatus(), (this.status === Gi || this.status === bo) && this._runAsyncValidator(n.emitEvent)), !1 !== n.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._parent && !n.onlySelf && this._parent.updateValueAndValidity(n) } _updateTreeValidity(n = { emitEvent: !0 }) { this._forEachChild(t => t._updateTreeValidity(n)), this.updateValueAndValidity({ onlySelf: !0, emitEvent: n.emitEvent }) } _setInitialStatus() { this.status = this._allControlsDisabled() ? Wi : Gi } _runValidator() { return this.validator ? this.validator(this) : null } _runAsyncValidator(n) { if (this.asyncValidator) { this.status = bo, this._hasOwnPendingAsyncValidator = !0; const t = vC(this.asyncValidator(this)); this._asyncValidationSubscription = t.subscribe(r => { this._hasOwnPendingAsyncValidator = !1, this.setErrors(r, { emitEvent: n }) }) } } _cancelExistingSubscription() { this._asyncValidationSubscription && (this._asyncValidationSubscription.unsubscribe(), this._hasOwnPendingAsyncValidator = !1) } setErrors(n, t = {}) { this.errors = n, this._updateControlsErrors(!1 !== t.emitEvent) } get(n) { let t = n; return null == t || (Array.isArray(t) || (t = t.split(".")), 0 === t.length) ? null : t.reduce((r, o) => r && r._find(o), this) } getError(n, t) { const r = t ? this.get(t) : this; return r && r.errors ? r.errors[n] : null } hasError(n, t) { return !!this.getError(n, t) } get root() { let n = this; for (; n._parent;)n = n._parent; return n } _updateControlsErrors(n) { this.status = this._calculateStatus(), n && this.statusChanges.emit(this.status), this._parent && this._parent._updateControlsErrors(n) } _initObservables() { this.valueChanges = new pe, this.statusChanges = new pe } _calculateStatus() { return this._allControlsDisabled() ? Wi : this.errors ? nl : this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(bo) ? bo : this._anyControlsHaveStatus(nl) ? nl : Gi } _anyControlsHaveStatus(n) { return this._anyControls(t => t.status === n) } _anyControlsDirty() { return this._anyControls(n => n.dirty) } _anyControlsTouched() { return this._anyControls(n => n.touched) } _updatePristine(n = {}) { this.pristine = !this._anyControlsDirty(), this._parent && !n.onlySelf && this._parent._updatePristine(n) } _updateTouched(n = {}) { this.touched = this._anyControlsTouched(), this._parent && !n.onlySelf && this._parent._updateTouched(n) } _registerOnCollectionChange(n) { this._onCollectionChange = n } _setUpdateStrategy(n) { rl(n) && null != n.updateOn && (this._updateOn = n.updateOn) } _parentMarkedDirty(n) { return !n && !(!this._parent || !this._parent.dirty) && !this._parent._anyControlsDirty() } _find(n) { return null } _assignValidators(n) { this._rawValidators = Array.isArray(n) ? n.slice() : n, this._composedValidatorFn = function eO(e) { return Array.isArray(e) ? nf(e) : e || null }(this._rawValidators) } _assignAsyncValidators(n) { this._rawAsyncValidators = Array.isArray(n) ? n.slice() : n, this._composedAsyncValidatorFn = function tO(e) { return Array.isArray(e) ? rf(e) : e || null }(this._rawAsyncValidators) } } class ff extends FC { constructor(n, t, r) { super(cf(t), df(r, t)), this.controls = n, this._initObservables(), this._setUpdateStrategy(t), this._setUpControls(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }) } registerControl(n, t) { return this.controls[n] ? this.controls[n] : (this.controls[n] = t, t.setParent(this), t._registerOnCollectionChange(this._onCollectionChange), t) } addControl(n, t, r = {}) { this.registerControl(n, t), this.updateValueAndValidity({ emitEvent: r.emitEvent }), this._onCollectionChange() } removeControl(n, t = {}) { this.controls[n] && this.controls[n]._registerOnCollectionChange(() => { }), delete this.controls[n], this.updateValueAndValidity({ emitEvent: t.emitEvent }), this._onCollectionChange() } setControl(n, t, r = {}) { this.controls[n] && this.controls[n]._registerOnCollectionChange(() => { }), delete this.controls[n], t && this.registerControl(n, t), this.updateValueAndValidity({ emitEvent: r.emitEvent }), this._onCollectionChange() } contains(n) { return this.controls.hasOwnProperty(n) && this.controls[n].enabled } setValue(n, t = {}) { (function NC(e, n, t) { e._forEachChild((r, o) => { if (void 0 === t[o]) throw new b(1002, uf ? function JF(e, n) { return `Must supply a value for form control ${PC(e, n)}` }(n, o) : "") }) })(this, !0, n), Object.keys(n).forEach(r => { (function RC(e, n, t) { const r = e.controls; if (!(n ? Object.keys(r) : r).length) throw new b(1e3, uf ? function QF(e) { return `\n    There are no form controls registered with this ${e ? "group" : "array"} yet. If you're using ngModel,\n    you may want to check next tick (e.g. use setTimeout).\n  ` }(n) : ""); if (!r[t]) throw new b(1001, uf ? function XF(e, n) { return `Cannot find form control ${PC(e, n)}` }(n, t) : "") })(this, !0, r), this.controls[r].setValue(n[r], { onlySelf: !0, emitEvent: t.emitEvent }) }), this.updateValueAndValidity(t) } patchValue(n, t = {}) { null != n && (Object.keys(n).forEach(r => { const o = this.controls[r]; o && o.patchValue(n[r], { onlySelf: !0, emitEvent: t.emitEvent }) }), this.updateValueAndValidity(t)) } reset(n = {}, t = {}) { this._forEachChild((r, o) => { r.reset(n[o], { onlySelf: !0, emitEvent: t.emitEvent }) }), this._updatePristine(t), this._updateTouched(t), this.updateValueAndValidity(t) } getRawValue() { return this._reduceChildren({}, (n, t, r) => (n[r] = t.getRawValue(), n)) } _syncPendingControls() { let n = this._reduceChildren(!1, (t, r) => !!r._syncPendingControls() || t); return n && this.updateValueAndValidity({ onlySelf: !0 }), n } _forEachChild(n) { Object.keys(this.controls).forEach(t => { const r = this.controls[t]; r && n(r, t) }) } _setUpControls() { this._forEachChild(n => { n.setParent(this), n._registerOnCollectionChange(this._onCollectionChange) }) } _updateValue() { this.value = this._reduceValue() } _anyControls(n) { for (const [t, r] of Object.entries(this.controls)) if (this.contains(t) && n(r)) return !0; return !1 } _reduceValue() { return this._reduceChildren({}, (t, r, o) => ((r.enabled || this.disabled) && (t[o] = r.value), t)) } _reduceChildren(n, t) { let r = n; return this._forEachChild((o, i) => { r = t(r, o, i) }), r } _allControlsDisabled() { for (const n of Object.keys(this.controls)) if (this.controls[n].enabled) return !1; return Object.keys(this.controls).length > 0 || this.disabled } _find(n) { return this.controls.hasOwnProperty(n) ? this.controls[n] : null } } const Eo = new A("CallSetDisabledState", { providedIn: "root", factory: () => ol }), ol = "always"; function qi(e, n, t = ol) { hf(e, n), n.valueAccessor.writeValue(e.value), (e.disabled || "always" === t) && n.valueAccessor.setDisabledState?.(e.disabled), function oO(e, n) { n.valueAccessor.registerOnChange(t => { e._pendingValue = t, e._pendingChange = !0, e._pendingDirty = !0, "change" === e.updateOn && OC(e, n) }) }(e, n), function sO(e, n) { const t = (r, o) => { n.valueAccessor.writeValue(r), o && n.viewToModelUpdate(r) }; e.registerOnChange(t), n._registerOnDestroy(() => { e._unregisterOnChange(t) }) }(e, n), function iO(e, n) { n.valueAccessor.registerOnTouched(() => { e._pendingTouched = !0, "blur" === e.updateOn && e._pendingChange && OC(e, n), "submit" !== e.updateOn && e.markAsTouched() }) }(e, n), function rO(e, n) { if (n.valueAccessor.setDisabledState) { const t = r => { n.valueAccessor.setDisabledState(r) }; e.registerOnDisabledChange(t), n._registerOnDestroy(() => { e._unregisterOnDisabledChange(t) }) } }(e, n) } function al(e, n) { e.forEach(t => { t.registerOnValidatorChange && t.registerOnValidatorChange(n) }) } function hf(e, n) { const t = function SC(e) { return e._rawValidators }(e); null !== n.validator ? e.setValidators(EC(t, n.validator)) : "function" == typeof t && e.setValidators([t]); const r = function MC(e) { return e._rawAsyncValidators }(e); null !== n.asyncValidator ? e.setAsyncValidators(EC(r, n.asyncValidator)) : "function" == typeof r && e.setAsyncValidators([r]); const o = () => e.updateValueAndValidity(); al(n._rawValidators, o), al(n._rawAsyncValidators, o) } function OC(e, n) { e._pendingDirty && e.markAsDirty(), e.setValue(e._pendingValue, { emitModelToViewChange: !1 }), n.viewToModelUpdate(e._pendingValue), e._pendingChange = !1 } const dO = { provide: rt, useExisting: le(() => wr) }, Ki = (() => Promise.resolve())(); let wr = (() => { class e extends rt { constructor(t, r, o) { super(), this.callSetDisabledState = o, this.submitted = !1, this._directives = new Set, this.ngSubmit = new pe, this.form = new ff({}, nf(t), rf(r)) } ngAfterViewInit() { this._setUpdateStrategy() } get formDirective() { return this } get control() { return this.form } get path() { return [] } get controls() { return this.form.controls } addControl(t) { Ki.then(() => { const r = this._findContainer(t.path); t.control = r.registerControl(t.name, t.control), qi(t.control, t, this.callSetDisabledState), t.control.updateValueAndValidity({ emitEvent: !1 }), this._directives.add(t) }) } getControl(t) { return this.form.get(t.path) } removeControl(t) { Ki.then(() => { const r = this._findContainer(t.path); r && r.removeControl(t.name), this._directives.delete(t) }) } addFormGroup(t) { Ki.then(() => { const r = this._findContainer(t.path), o = new ff({}); (function kC(e, n) { hf(e, n) })(o, t), r.registerControl(t.name, o), o.updateValueAndValidity({ emitEvent: !1 }) }) } removeFormGroup(t) { Ki.then(() => { const r = this._findContainer(t.path); r && r.removeControl(t.name) }) } getFormGroup(t) { return this.form.get(t.path) } updateModel(t, r) { Ki.then(() => { this.form.get(t.path).setValue(r) }) } setValue(t) { this.control.setValue(t) } onSubmit(t) { return this.submitted = !0, function LC(e, n) { e._syncPendingControls(), n.forEach(t => { const r = t.control; "submit" === r.updateOn && r._pendingChange && (t.viewToModelUpdate(r._pendingValue), r._pendingChange = !1) }) }(this.form, this._directives), this.ngSubmit.emit(t), "dialog" === t?.target?.method } onReset() { this.resetForm() } resetForm(t) { this.form.reset(t), this.submitted = !1 } _setUpdateStrategy() { this.options && null != this.options.updateOn && (this.form._updateOn = this.options.updateOn) } _findContainer(t) { return t.pop(), t.length ? this.form.get(t) : this.form } } return e.\u0275fac = function (t) { return new (t || e)(y(Ye, 10), y(qn, 10), y(Eo, 8)) }, e.\u0275dir = V({ type: e, selectors: [["form", 3, "ngNoForm", "", 3, "formGroup", ""], ["ng-form"], ["", "ngForm", ""]], hostBindings: function (t, r) { 1 & t && Z("submit", function (i) { return r.onSubmit(i) })("reset", function () { return r.onReset() }) }, inputs: { options: ["ngFormOptions", "options"] }, outputs: { ngSubmit: "ngSubmit" }, exportAs: ["ngForm"], features: [fe([dO]), re] }), e })(); function VC(e, n) { const t = e.indexOf(n); t > -1 && e.splice(t, 1) } function jC(e) { return "object" == typeof e && null !== e && 2 === Object.keys(e).length && "value" in e && "disabled" in e } const BC = class extends FC { constructor(n = null, t, r) { super(cf(t), df(r, t)), this.defaultValue = null, this._onChange = [], this._pendingChange = !1, this._applyFormState(n), this._setUpdateStrategy(t), this._initObservables(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }), rl(t) && (t.nonNullable || t.initialValueIsDefault) && (this.defaultValue = jC(n) ? n.value : n) } setValue(n, t = {}) { this.value = this._pendingValue = n, this._onChange.length && !1 !== t.emitModelToViewChange && this._onChange.forEach(r => r(this.value, !1 !== t.emitViewToModelChange)), this.updateValueAndValidity(t) } patchValue(n, t = {}) { this.setValue(n, t) } reset(n = this.defaultValue, t = {}) { this._applyFormState(n), this.markAsPristine(t), this.markAsUntouched(t), this.setValue(this.value, t), this._pendingChange = !1 } _updateValue() { } _anyControls(n) { return !1 } _allControlsDisabled() { return this.disabled } registerOnChange(n) { this._onChange.push(n) } _unregisterOnChange(n) { VC(this._onChange, n) } registerOnDisabledChange(n) { this._onDisabledChange.push(n) } _unregisterOnDisabledChange(n) { VC(this._onDisabledChange, n) } _forEachChild(n) { } _syncPendingControls() { return !("submit" !== this.updateOn || (this._pendingDirty && this.markAsDirty(), this._pendingTouched && this.markAsTouched(), !this._pendingChange) || (this.setValue(this._pendingValue, { onlySelf: !0, emitModelToViewChange: !1 }), 0)) } _applyFormState(n) { jC(n) ? (this.value = this._pendingValue = n.value, n.disabled ? this.disable({ onlySelf: !0, emitEvent: !1 }) : this.enable({ onlySelf: !0, emitEvent: !1 })) : this.value = this._pendingValue = n } }, pO = { provide: Kn, useExisting: le(() => Zn) }, HC = (() => Promise.resolve())(); let Zn = (() => { class e extends Kn { constructor(t, r, o, i, s, a) { super(), this._changeDetectorRef = s, this.callSetDisabledState = a, this.control = new BC, this._registered = !1, this.update = new pe, this._parent = t, this._setValidators(r), this._setAsyncValidators(o), this.valueAccessor = function mf(e, n) { if (!n) return null; let t, r, o; return Array.isArray(n), n.forEach(i => { i.constructor === Nn ? t = i : function uO(e) { return Object.getPrototypeOf(e.constructor) === Dr }(i) ? r = i : o = i }), o || r || t || null }(0, i) } ngOnChanges(t) { if (this._checkForErrors(), !this._registered || "name" in t) { if (this._registered && (this._checkName(), this.formDirective)) { const r = t.name.previousValue; this.formDirective.removeControl({ name: r, path: this._getPath(r) }) } this._setUpControl() } "isDisabled" in t && this._updateDisabled(t), function gf(e, n) { if (!e.hasOwnProperty("model")) return !1; const t = e.model; return !!t.isFirstChange() || !Object.is(n, t.currentValue) }(t, this.viewModel) && (this._updateValue(this.model), this.viewModel = this.model) } ngOnDestroy() { this.formDirective && this.formDirective.removeControl(this) } get path() { return this._getPath(this.name) } get formDirective() { return this._parent ? this._parent.formDirective : null } viewToModelUpdate(t) { this.viewModel = t, this.update.emit(t) } _setUpControl() { this._setUpdateStrategy(), this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this), this._registered = !0 } _setUpdateStrategy() { this.options && null != this.options.updateOn && (this.control._updateOn = this.options.updateOn) } _isStandalone() { return !this._parent || !(!this.options || !this.options.standalone) } _setUpStandalone() { qi(this.control, this, this.callSetDisabledState), this.control.updateValueAndValidity({ emitEvent: !1 }) } _checkForErrors() { this._isStandalone() || this._checkParentType(), this._checkName() } _checkParentType() { } _checkName() { this.options && this.options.name && (this.name = this.options.name), this._isStandalone() } _updateValue(t) { HC.then(() => { this.control.setValue(t, { emitViewToModelChange: !1 }), this._changeDetectorRef?.markForCheck() }) } _updateDisabled(t) { const r = t.isDisabled.currentValue, o = 0 !== r && fo(r); HC.then(() => { o && !this.control.disabled ? this.control.disable() : !o && this.control.disabled && this.control.enable(), this._changeDetectorRef?.markForCheck() }) } _getPath(t) { return this._parent ? function il(e, n) { return [...n.path, e] }(t, this._parent) : [t] } } return e.\u0275fac = function (t) { return new (t || e)(y(rt, 9), y(Ye, 10), y(qn, 10), y(fn, 10), y(ua, 8), y(Eo, 8)) }, e.\u0275dir = V({ type: e, selectors: [["", "ngModel", "", 3, "formControlName", "", 3, "formControl", ""]], inputs: { name: "name", isDisabled: ["disabled", "isDisabled"], model: ["ngModel", "model"], options: ["ngModelOptions", "options"] }, outputs: { update: "ngModelChange" }, exportAs: ["ngModel"], features: [fe([pO]), re, Et] }), e })(), Zi = (() => { class e { } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275dir = V({ type: e, selectors: [["form", 3, "ngNoForm", "", 3, "ngNativeValidate", ""]], hostAttrs: ["novalidate", ""] }), e })(); const gO = { provide: fn, useExisting: le(() => yf), multi: !0 }; let yf = (() => { class e extends Dr { writeValue(t) { this.setProperty("value", t ?? "") } registerOnChange(t) { this.onChange = r => { t("" == r ? null : parseFloat(r)) } } } return e.\u0275fac = function () { let n; return function (r) { return (n || (n = je(e)))(r || e) } }(), e.\u0275dir = V({ type: e, selectors: [["input", "type", "number", "formControlName", ""], ["input", "type", "number", "formControl", ""], ["input", "type", "number", "ngModel", ""]], hostBindings: function (t, r) { 1 & t && Z("input", function (i) { return r.onChange(i.target.value) })("blur", function () { return r.onTouched() }) }, features: [fe([gO]), re] }), e })(), zC = (() => { class e { } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275mod = ft({ type: e }), e.\u0275inj = ot({}), e })(); const EO = { provide: fn, useExisting: le(() => ul), multi: !0 }; function QC(e, n) { return null == e ? `${n}` : (n && "object" == typeof n && (n = "Object"), `${e}: ${n}`.slice(0, 50)) } let ul = (() => { class e extends Dr { constructor() { super(...arguments), this._optionMap = new Map, this._idCounter = 0, this._compareWith = Object.is } set compareWith(t) { this._compareWith = t } writeValue(t) { this.value = t; const o = QC(this._getOptionId(t), t); this.setProperty("value", o) } registerOnChange(t) { this.onChange = r => { this.value = this._getOptionValue(r), t(this.value) } } _registerOption() { return (this._idCounter++).toString() } _getOptionId(t) { for (const r of Array.from(this._optionMap.keys())) if (this._compareWith(this._optionMap.get(r), t)) return r; return null } _getOptionValue(t) { const r = function SO(e) { return e.split(":")[0] }(t); return this._optionMap.has(r) ? this._optionMap.get(r) : t } } return e.\u0275fac = function () { let n; return function (r) { return (n || (n = je(e)))(r || e) } }(), e.\u0275dir = V({ type: e, selectors: [["select", "formControlName", "", 3, "multiple", ""], ["select", "formControl", "", 3, "multiple", ""], ["select", "ngModel", "", 3, "multiple", ""]], hostBindings: function (t, r) { 1 & t && Z("change", function (i) { return r.onChange(i.target.value) })("blur", function () { return r.onTouched() }) }, inputs: { compareWith: "compareWith" }, features: [fe([EO]), re] }), e })(), XC = (() => { class e { constructor(t, r, o) { this._element = t, this._renderer = r, this._select = o, this._select && (this.id = this._select._registerOption()) } set ngValue(t) { null != this._select && (this._select._optionMap.set(this.id, t), this._setElementValue(QC(this.id, t)), this._select.writeValue(this._select.value)) } set value(t) { this._setElementValue(t), this._select && this._select.writeValue(this._select.value) } _setElementValue(t) { this._renderer.setProperty(this._element.nativeElement, "value", t) } ngOnDestroy() { this._select && (this._select._optionMap.delete(this.id), this._select.writeValue(this._select.value)) } } return e.\u0275fac = function (t) { return new (t || e)(y(lt), y(wn), y(ul, 9)) }, e.\u0275dir = V({ type: e, selectors: [["option"]], inputs: { ngValue: "ngValue", value: "value" } }), e })(); const MO = { provide: fn, useExisting: le(() => Cf), multi: !0 }; function JC(e, n) { return null == e ? `${n}` : ("string" == typeof n && (n = `'${n}'`), n && "object" == typeof n && (n = "Object"), `${e}: ${n}`.slice(0, 50)) } let Cf = (() => { class e extends Dr { constructor() { super(...arguments), this._optionMap = new Map, this._idCounter = 0, this._compareWith = Object.is } set compareWith(t) { this._compareWith = t } writeValue(t) { let r; if (this.value = t, Array.isArray(t)) { const o = t.map(i => this._getOptionId(i)); r = (i, s) => { i._setSelected(o.indexOf(s.toString()) > -1) } } else r = (o, i) => { o._setSelected(!1) }; this._optionMap.forEach(r) } registerOnChange(t) { this.onChange = r => { const o = [], i = r.selectedOptions; if (void 0 !== i) { const s = i; for (let a = 0; a < s.length; a++) { const u = this._getOptionValue(s[a].value); o.push(u) } } else { const s = r.options; for (let a = 0; a < s.length; a++) { const l = s[a]; if (l.selected) { const u = this._getOptionValue(l.value); o.push(u) } } } this.value = o, t(o) } } _registerOption(t) { const r = (this._idCounter++).toString(); return this._optionMap.set(r, t), r } _getOptionId(t) { for (const r of Array.from(this._optionMap.keys())) if (this._compareWith(this._optionMap.get(r)._value, t)) return r; return null } _getOptionValue(t) { const r = function IO(e) { return e.split(":")[0] }(t); return this._optionMap.has(r) ? this._optionMap.get(r)._value : t } } return e.\u0275fac = function () { let n; return function (r) { return (n || (n = je(e)))(r || e) } }(), e.\u0275dir = V({ type: e, selectors: [["select", "multiple", "", "formControlName", ""], ["select", "multiple", "", "formControl", ""], ["select", "multiple", "", "ngModel", ""]], hostBindings: function (t, r) { 1 & t && Z("change", function (i) { return r.onChange(i.target) })("blur", function () { return r.onTouched() }) }, inputs: { compareWith: "compareWith" }, features: [fe([MO]), re] }), e })(), ew = (() => { class e { constructor(t, r, o) { this._element = t, this._renderer = r, this._select = o, this._select && (this.id = this._select._registerOption(this)) } set ngValue(t) { null != this._select && (this._value = t, this._setElementValue(JC(this.id, t)), this._select.writeValue(this._select.value)) } set value(t) { this._select ? (this._value = t, this._setElementValue(JC(this.id, t)), this._select.writeValue(this._select.value)) : this._setElementValue(t) } _setElementValue(t) { this._renderer.setProperty(this._element.nativeElement, "value", t) } _setSelected(t) { this._renderer.setProperty(this._element.nativeElement, "selected", t) } ngOnDestroy() { this._select && (this._select._optionMap.delete(this.id), this._select.writeValue(this._select.value)) } } return e.\u0275fac = function (t) { return new (t || e)(y(lt), y(wn), y(Cf, 9)) }, e.\u0275dir = V({ type: e, selectors: [["option"]], inputs: { ngValue: "ngValue", value: "value" } }), e })(); let br = (() => { class e { constructor() { this._validator = Ja } ngOnChanges(t) { if (this.inputName in t) { const r = this.normalizeInput(t[this.inputName].currentValue); this._enabled = this.enabled(r), this._validator = this._enabled ? this.createValidator(r) : Ja, this._onChange && this._onChange() } } validate(t) { return this._validator(t) } registerOnValidatorChange(t) { this._onChange = t } enabled(t) { return null != t } } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275dir = V({ type: e, features: [Et] }), e })(); const TO = { provide: Ye, useExisting: le(() => wf), multi: !0 }; let wf = (() => { class e extends br { constructor() { super(...arguments), this.inputName = "min", this.normalizeInput = t => function nw(e) { return "number" == typeof e ? e : parseFloat(e) }(t), this.createValidator = t => function uC(e) { return n => { if (Wn(n.value) || Wn(e)) return null; const t = parseFloat(n.value); return !isNaN(t) && t < e ? { min: { min: e, actual: n.value } } : null } }(t) } } return e.\u0275fac = function () { let n; return function (r) { return (n || (n = je(e)))(r || e) } }(), e.\u0275dir = V({ type: e, selectors: [["input", "type", "number", "min", "", "formControlName", ""], ["input", "type", "number", "min", "", "formControl", ""], ["input", "type", "number", "min", "", "ngModel", ""]], hostVars: 1, hostBindings: function (t, r) { 2 & t && nn("min", r._enabled ? r.min : null) }, inputs: { min: "min" }, features: [fe([TO]), re] }), e })(); const xO = { provide: Ye, useExisting: le(() => Yi), multi: !0 }; let Yi = (() => { class e extends br { constructor() { super(...arguments), this.inputName = "required", this.normalizeInput = fo, this.createValidator = t => dC } enabled(t) { return t } } return e.\u0275fac = function () { let n; return function (r) { return (n || (n = je(e)))(r || e) } }(), e.\u0275dir = V({ type: e, selectors: [["", "required", "", "formControlName", "", 3, "type", "checkbox"], ["", "required", "", "formControl", "", 3, "type", "checkbox"], ["", "required", "", "ngModel", "", 3, "type", "checkbox"]], hostVars: 1, hostBindings: function (t, r) { 2 & t && nn("required", r._enabled ? "" : null) }, inputs: { required: "required" }, features: [fe([xO]), re] }), e })(), kO = (() => { class e { } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275mod = ft({ type: e }), e.\u0275inj = ot({ imports: [zC] }), e })(), VO = (() => { class e { static withConfig(t) { return { ngModule: e, providers: [{ provide: Eo, useValue: t.callSetDisabledState ?? ol }] } } } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275mod = ft({ type: e }), e.\u0275inj = ot({ imports: [kO] }), e })(), jO = (() => { class e { constructor(t) { this.el = t } onMouseEnter() { this.highlight("#efefef") } onMouseLeave() { this.highlight("") } highlight(t) { this.el.nativeElement.style.backgroundColor = t } } return e.\u0275fac = function (t) { return new (t || e)(y(lt)) }, e.\u0275dir = V({ type: e, selectors: [["", "appHighlight", ""]], hostBindings: function (t, r) { 1 & t && Z("mouseenter", function () { return r.onMouseEnter() })("mouseleave", function () { return r.onMouseLeave() }) }, inputs: { highlightColor: ["appHighlight", "highlightColor"] } }), e })(); class uw { constructor() { this.change = new pe, this.instances = {}, this.DEFAULT_ID = "DEFAULT_PAGINATION_ID" } defaultId() { return this.DEFAULT_ID } register(n) { return null == n.id && (n.id = this.DEFAULT_ID), this.instances[n.id] ? this.updateInstance(n) : (this.instances[n.id] = n, !0) } updateInstance(n) { let t = !1; for (let r in this.instances[n.id]) n[r] !== this.instances[n.id][r] && (this.instances[n.id][r] = n[r], t = !0); return t } getCurrentPage(n) { return this.instances[n] ? this.instances[n].currentPage : 1 } setCurrentPage(n, t) { if (this.instances[n]) { let r = this.instances[n]; t <= Math.ceil(r.totalItems / r.itemsPerPage) && 1 <= t && (this.instances[n].currentPage = t, this.change.emit(n)) } } setTotalItems(n, t) { this.instances[n] && 0 <= t && (this.instances[n].totalItems = t, this.change.emit(n)) } setItemsPerPage(n, t) { this.instances[n] && (this.instances[n].itemsPerPage = t, this.change.emit(n)) } getInstance(n = this.DEFAULT_ID) { return this.instances[n] ? this.clone(this.instances[n]) : {} } clone(n) { var t = {}; for (var r in n) n.hasOwnProperty(r) && (t[r] = n[r]); return t } } const ZO = Number.MAX_SAFE_INTEGER; let YO = (() => { class e { constructor(t) { this.service = t, this.state = {} } transform(t, r) { if (!(t instanceof Array)) { let d = r.id || this.service.defaultId(); return this.state[d] ? this.state[d].slice : t } let a, l, o = r.totalItems && r.totalItems !== t.length, i = this.createInstance(t, r), s = i.id, u = i.itemsPerPage, c = this.service.register(i); if (!o && t instanceof Array) { if (u = +u || ZO, a = (i.currentPage - 1) * u, l = a + u, this.stateIsIdentical(s, t, a, l)) return this.state[s].slice; { let f = t.slice(a, l); return this.saveState(s, t, f, a, l), this.service.change.emit(s), f } } return c && this.service.change.emit(s), this.saveState(s, t, t, a, l), t } createInstance(t, r) { return this.checkConfig(r), { id: null != r.id ? r.id : this.service.defaultId(), itemsPerPage: +r.itemsPerPage || 0, currentPage: +r.currentPage || 1, totalItems: +r.totalItems || t.length } } checkConfig(t) { const o = ["itemsPerPage", "currentPage"].filter(i => !(i in t)); if (0 < o.length) throw new Error(`PaginatePipe: Argument is missing the following required properties: ${o.join(", ")}`) } saveState(t, r, o, i, s) { this.state[t] = { collection: r, size: r.length, slice: o, start: i, end: s } } stateIsIdentical(t, r, o, i) { let s = this.state[t]; return !(!s || s.size !== r.length || s.start !== o || s.end !== i) && s.slice.every((l, u) => l === r[o + u]) } } return e.\u0275fac = function (t) { return new (t || e)(y(uw, 16)) }, e.\u0275pipe = Ue({ name: "paginate", type: e, pure: !1 }), e })(), QO = (() => { class e { } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275mod = ft({ type: e }), e.\u0275inj = ot({ providers: [uw], imports: [[n_]] }), e })(), XO = (() => { class e { transform(t, r) { return r && t ? e.filter(t, r) : t } static filter(t, r) { const o = r.toLowerCase(); function i(s, a) { for (let l in s) if (null !== s[l] && null != s[l] && ("object" == typeof s[l] && i(s[l], a) || s[l].toString().toLowerCase().includes(o))) return !0; return !1 } return t.filter(function (s) { return i(s, r) }) } } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275pipe = Ue({ name: "filter", type: e, pure: !1 }), e.\u0275prov = x({ token: e, factory: e.\u0275fac }), e })(), JO = (() => { class e { } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275mod = ft({ type: e }), e.\u0275inj = ot({}), e })(); function ek(e, n) { if (1 & e) { const t = lr(); v(0, "div", 10), Z("click", function () { const i = Kt(t).$implicit; return Zt(Ot(2).goToProduct(i)) }), v(1, "a", 11), Ke(2, "img", 12), v(3, "p", 13)(4, "b"), E(5), w()()(), v(6, "span", 14), E(7), dr(8, "currency"), w()() } if (2 & e) { const t = n.$implicit; P(1), Q("title", t.name + " details"), P(1), Q("src", t.image[0].path[0].img, Hr), P(3), Be(t.name), P(2), sn(" ", hi(8, 4, t.memory[0].price), "") } } function tk(e, n) { if (1 & e) { const t = lr(); v(0, "div", 2)(1, "div", 3)(2, "input", 4), Z("ngModelChange", function (o) { return Kt(t), Zt(Ot().searchField = o) }), w()(), v(3, "div", 5), ut(4, ek, 9, 6, "div", 6), dr(5, "paginate"), dr(6, "filter"), w(), v(7, "ul", 7)(8, "li", 8), Z("click", function () { return Kt(t), Zt(Ot().previousPage()) }), v(9, "a", 9), E(10, "Previous"), w()(), v(11, "li", 8), Z("click", function () { return Kt(t), Zt(Ot().nextPage()) }), v(12, "a", 9), E(13, "Next"), w()()()() } if (2 & e) { const t = Ot(); P(2), Q("ngModel", t.searchField), P(2), Q("ngForOf", vc(5, 2, vc(6, 5, t.listProducts, t.searchField), t.config)) } } function nk(e, n) { 1 & e && (v(0, "div", 15), Ke(1, "div", 16), w()) } let rk = (() => { class e { constructor(t, r) { this.DataService = t, this.router = r, this.listProducts = [], this.searchField = "", this.page_size = 1, this.config = { itemsPerPage: 6, currentPage: 1 } } ngOnInit() { this.loadproducts() } loadproducts() { this.DataService.get("/products").then(t => { this.listProducts = t.data, this.page_size = Math.ceil(this.listProducts.length / this.config.itemsPerPage) }) } goToProduct(t) { this.router.navigate(["/products/" + t.id]) } nextPage() { this.config.currentPage + 1 <= this.page_size && this.config.currentPage++ } previousPage() { this.config.currentPage - 1 > 0 && this.config.currentPage-- } } return e.\u0275fac = function (t) { return new (t || e)(y(_r), y(Fe)) }, e.\u0275cmp = Wt({ type: e, selectors: [["app-products"]], decls: 2, vars: 2, consts: [["class", "container mt-5", 4, "ngIf"], ["class", " d-flex justify-content-center align-content-end", "style", " width: 100vw;", 4, "ngIf"], [1, "container", "mt-5"], [1, "search"], ["type", "text", "autocomplete", "on", "placeholder", "\uf002 Search", 1, "form-control", 3, "ngModel", "ngModelChange"], [1, "row"], ["class", "col-md-4 mt-5 text-center", 3, "appHighlight", "click", 4, "ngFor", "ngForOf"], [1, "pagination"], [1, "page-item", 3, "click"], [1, "page-link"], [1, "col-md-4", "mt-5", "text-center", 3, "appHighlight", "click"], [3, "title"], ["alt", "image can't display", "height", "250px", 1, "mt-3", 3, "src"], [1, "mt-5", 2, "color", "black"], [2, "font-size", "20px"], [1, "d-flex", "justify-content-center", "align-content-end", 2, "width", "100vw"], [1, "spinner-border", "text-danger"]], template: function (t, r) { 1 & t && (ut(0, tk, 14, 8, "div", 0), ut(1, nk, 2, 0, "div", 1)), 2 & t && (Q("ngIf", 0 != r.listProducts.length), P(1), Q("ngIf", 0 == r.listProducts.length)) }, dependencies: [Di, Ci, Nn, Cr, Zn, jO, wa, YO, XO], styles: [".pagination[_ngcontent-%COMP%]{display:flex;justify-content:center;margin-top:20px}.search[_ngcontent-%COMP%]{max-width:400px;padding-bottom:40px;margin:auto}.form-control[_ngcontent-%COMP%]{margin-top:10px;box-shadow:0 5px 50px #b0c1d9}.form-control[_ngcontent-%COMP%]::placeholder{font-family:FontAwesome;color:gray}"] }), e })(); function ok(e, n) { if (1 & e) { const t = lr(); v(0, "div", 19)(1, "img", 20), Z("click", function () { const i = Kt(t).$implicit; return Zt(Ot().sideImage(i.img)) }), w()() } if (2 & e) { const t = n.$implicit; P(1), Q("src", t.img, Hr) } } function ik(e, n) { if (1 & e && (v(0, "b"), E(1), w()), 2 & e) { const t = Ot(); P(1), sn("", t.selectedMemory, "GB") } } function sk(e, n) { if (1 & e) { const t = lr(); v(0, "button", 21), Z("click", function () { const i = Kt(t).$implicit; return Zt(Ot().selectPhoneMemory(i)) }), E(1), w() } if (2 & e) { const t = n.$implicit; P(1), sn("", t.size, "GB ") } } const ak = function (e) { return { background: e } }; function lk(e, n) { if (1 & e) { const t = lr(); v(0, "button", 22), Z("click", function () { const i = Kt(t).$implicit; return Zt(Ot().selectedPhoneColor(i)) }), w() } if (2 & e) { const t = n.$implicit; Q("ngStyle", function Ey(e, n, t, r) { return Sy(C(), Xe(), e, n, t, r) }(2, ak, t.color))("title", t.phoneColor) } } let uk = (() => { class e { constructor(t, r, o) { this.router = t, this.DataService = r, this.route = o, this.selectedMemory = [], this.sideImages = [], this.id = null } ngOnInit() { let t = this.router.snapshot.paramMap.get("id"); this.load_product(t) } load_product(t) { this.DataService.get(`/products/${t}`).then(r => { this.product = r.data, this.img = this.product.image[0].path[0].img, this.sideImages = this.product.image[0].path, this.selectedColor = this.product.image[0].phoneColor, this.selectedMemory = this.product.memory[0].size, this.selectedPrice = this.product.memory[0].price }) } sideImage(t) { this.img = t } addToCart() { this.DataService.post("/cart", { productId: this.product.id, name: this.product.name, color: this.selectedColor, memory: this.selectedMemory, price: this.selectedPrice, image: this.sideImages[0].img, quantity: 1 }) } selectedPhoneColor(t) { this.img = t.path[0].img, this.selectedColor = t.phoneColor, this.sideImages = t.path } selectPhoneMemory(t) { this.selectedMemory = t.size, this.selectedPrice = t.price } } return e.\u0275fac = function (t) { return new (t || e)(y(yr), y(_r), y(Fe)) }, e.\u0275cmp = Wt({ type: e, selectors: [["app-product-detail"]], decls: 51, vars: 20, consts: [[1, "container"], [1, "col-md-12", "mt-5"], [1, "row"], [1, "card-body", "col-lg-1"], ["class", "col-lg-1", 4, "ngFor", "ngForOf"], [1, "col-md-4", "col-lg-4"], [1, "img-fluid", 3, "src"], [1, "mt-3", "col-md-8", "col-lg-7"], [1, "mt-4"], [1, "title-description"], [2, "font-size", "16px", "color", "darkred"], [4, "ngIf"], [1, "mt-2", 2, "margin-left", "-3px"], ["type", "button", "class", "btn ml-1", "style", "border-color: grey; font-weight: bold", 3, "click", 4, "ngFor", "ngForOf"], ["class", "card ml-1", "style", "height: 30px; width: 30px; display: inline-block", 3, "ngStyle", "title", "click", 4, "ngFor", "ngForOf"], [1, "description"], [1, "mt-2"], [1, "btn", "btn-success", 3, "disabled", "click"], [1, "fa", "fa-shopping-cart"], [1, "col-lg-1"], [1, "mt-1", "middle", 3, "src", "click"], ["type", "button", 1, "btn", "ml-1", 2, "border-color", "grey", "font-weight", "bold", 3, "click"], [1, "card", "ml-1", 2, "height", "30px", "width", "30px", "display", "inline-block", 3, "ngStyle", "title", "click"]], template: function (t, r) { 1 & t && (v(0, "div", 0)(1, "div", 1)(2, "div", 2)(3, "div", 3), ut(4, ok, 2, 1, "div", 4), w(), v(5, "div", 5), Ke(6, "img", 6), w(), v(7, "div", 7)(8, "h5"), E(9), w(), v(10, "div", 8)(11, "span", 9), E(12, "Price:"), w(), v(13, "span", 10), E(14), dr(15, "currency"), w()(), v(16, "div")(17, "span", 9), E(18, "Selected size: "), w(), ut(19, ik, 2, 1, "b", 11), w(), v(20, "div", 12), ut(21, sk, 2, 1, "button", 13), w(), v(22, "div")(23, "span", 9), E(24, "Selected color: "), v(25, "b"), E(26), w()()(), v(27, "div"), ut(28, lk, 1, 4, "button", 14), w(), v(29, "div")(30, "span", 9), E(31, "Specification:"), w(), v(32, "ul", 15)(33, "li"), E(34), w(), v(35, "li"), E(36), w(), v(37, "li"), E(38), w(), v(39, "li"), E(40), w(), v(41, "li"), E(42), w(), v(43, "li"), E(44), w(), v(45, "li"), E(46), w()(), v(47, "div", 16)(48, "button", 17), Z("click", function () { return r.addToCart() }), Ke(49, "i", 18), E(50, " Add to cart "), w()()()()()()()), 2 & t && (P(4), Q("ngForOf", r.sideImages), P(2), Q("src", r.img, Hr), P(3), uc("", null == r.product ? null : r.product.name, " (", r.selectedMemory, "GB) - ", r.selectedColor, ""), P(5), sn(" ", hi(15, 18, r.selectedPrice), ""), P(5), Q("ngIf", r.selectedMemory), P(2), Q("ngForOf", null == r.product ? null : r.product.memory), P(5), Be(r.selectedColor), P(2), Q("ngForOf", null == r.product ? null : r.product.image), P(6), Be(null == r.product ? null : r.product.display), P(2), Be(null == r.product ? null : r.product.waterResistant), P(2), Be(null == r.product ? null : r.product.camera), P(2), Be(null == r.product ? null : r.product.frontCamera), P(2), Be(null == r.product ? null : r.product.futures), P(2), Be(null == r.product ? null : r.product.processor), P(2), Be(null == r.product ? null : r.product.charging), P(2), Q("disabled", !r.selectedMemory)) }, dependencies: [Di, Ci, e_, wa], styles: [".title-description[_ngcontent-%COMP%]{font-size:13px}.middle[_ngcontent-%COMP%]{display:block;margin-left:auto;margin-right:auto;height:65px}.img-fluid[_ngcontent-%COMP%]{max-height:450px;display:block;margin:auto;vertical-align:middle}ul[_ngcontent-%COMP%]{font-size:13px;list-style-position:outside}ul[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]{margin-left:-24px!important}.gold[_ngcontent-%COMP%]{background-color:#eee8aa}.darkslategrey[_ngcontent-%COMP%]{background-color:#2f4f4f}.grey[_ngcontent-%COMP%]{background-color:gray}.silver[_ngcontent-%COMP%]{background-color:silver}"] }), e })(), bf = (() => { class e { isLoggedIn() { return !!localStorage.getItem("token") } } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); function ck(e, n) { if (1 & e) { const t = lr(); v(0, "div", 25)(1, "div", 26), Ke(2, "img", 27), w(), v(3, "div", 28)(4, "h6", 29), E(5), w(), v(6, "h6", 30), E(7), w()(), v(8, "div", 31)(9, "input", 32), Z("ngModelChange", function (o) { return Zt(Kt(t).$implicit.quantity = o) })("change", function () { const i = Kt(t).$implicit; return Zt(Ot().change_cart(i.id, i.quantity)) }), w()(), v(10, "div", 33)(11, "h6", 14), E(12), dr(13, "currency"), w()(), v(14, "div", 34)(15, "a", 35), Ke(16, "i", 36), w()()() } if (2 & e) { const t = n.$implicit; P(2), Q("src", t.image, Hr), P(3), lc("", t.memory, "GB -- ", t.color, ""), P(2), Be(t.name), P(2), Q("ngModel", t.quantity), P(3), Be(hi(13, 6, t.price * t.quantity)) } } function dk(e, n) { 1 & e && (v(0, "a", 37), E(1, "Register"), w()) } function fk(e, n) { 1 & e && (v(0, "a", 38), E(1, "Payment"), w()) } let hk = (() => { class e { constructor(t, r) { this.DataService = t, this.AuthService = r, this.listCart = [], this.totail = 0, this.check = !1 } ngOnInit() { this.load_Cart(), this.check = this.AuthService.isLoggedIn() } load_Cart() { this.DataService.get("/cart").then(t => { this.listCart = t }) } change_cart(t, r) { this.listCart.forEach(o => { o.id == t && (o.quantity = r, (0 == r || o.quantity * o.price == 0) && this.listCart.splice(this.listCart.indexOf(o), 1), this.DataService.patch(`/cart/${t}`, { quantity: r })) }), this.totail = this.listCart.reduce((o, i) => o.price * o.quantity + i.price * i.quantity) } } return e.\u0275fac = function (t) { return new (t || e)(y(_r), y(bf)) }, e.\u0275cmp = Wt({ type: e, selectors: [["app-cart"]], decls: 37, vars: 8, consts: [[1, "h-100", "h-custom", 2, "background-color", "#d2c9ff"], [1, "container", "py-5", "h-100"], [1, "row", "d-flex", "justify-content-center", "align-items-center", "h-100"], [1, "col-12"], [1, "card", "card-registration", "card-registration-2", 2, "border-radius", "15px"], [1, "card-body", "p-0"], [1, "row", "g-0"], [1, "col-lg-8"], [1, "p-5"], [1, "d-flex", "justify-content-between", "align-items-center", "mb-5"], [1, "fw-bold", "mb-0", "text-black"], [1, "mb-0", "text-muted"], ["class", "row mb-4 d-flex justify-content-between align-items-center", 4, "ngFor", "ngForOf"], [1, "pt-5"], [1, "mb-0"], ["href", "#!", 1, "text-body"], [1, "fas", "fa-long-arrow-alt-left", "me-2"], [1, "col-lg-4", "bg-grey"], [1, "fw-bold", "mb-5", "mt-2", "pt-1"], [1, "my-4"], [1, "d-flex", "justify-content-between", "mb-4"], [1, "text-uppercase"], [1, "d-flex", "justify-content-between", "mb-5"], ["routerLink", "/register", "type", "button", "class", "btn btn-dark btn-block btn-lg", "data-mdb-ripple-color", "dark", 4, "ngIf"], ["routerLink", "/order", "type", "button", "class", "btn btn-dark btn-block btn-lg", "data-mdb-ripple-color", "dark", 4, "ngIf"], [1, "row", "mb-4", "d-flex", "justify-content-between", "align-items-center"], [1, "col-md-2", "col-lg-2", "col-xl-2"], ["alt", "Cotton T-shirt", 1, "img-fluid", "rounded-3", 3, "src"], [1, "col-md-3", "col-lg-3", "col-xl-3"], [1, "text-muted"], [1, "text-black", "mb-0"], [1, "col-md-3", "col-lg-3", "col-xl-2", "d-flex"], ["id", "form1", "min", "0", "name", "quantity", "type", "number", 1, "form-control", "form-control-sm", 3, "ngModel", "ngModelChange", "change"], [1, "col-md-3", "col-lg-2", "col-xl-2", "offset-lg-1"], [1, "col-md-1", "col-lg-1", "col-xl-1", "text-end"], ["href", "#!", 1, "text-muted"], [1, "fas", "fa-times"], ["routerLink", "/register", "type", "button", "data-mdb-ripple-color", "dark", 1, "btn", "btn-dark", "btn-block", "btn-lg"], ["routerLink", "/order", "type", "button", "data-mdb-ripple-color", "dark", 1, "btn", "btn-dark", "btn-block", "btn-lg"]], template: function (t, r) { 1 & t && (v(0, "section", 0)(1, "div", 1)(2, "div", 2)(3, "div", 3)(4, "div", 4)(5, "div", 5)(6, "div", 6)(7, "div", 7)(8, "div", 8)(9, "div", 9)(10, "h1", 10), E(11, "Shopping Cart"), w(), v(12, "h6", 11), E(13), w()(), ut(14, ck, 17, 8, "div", 12), v(15, "div", 13)(16, "h6", 14)(17, "a", 15), Ke(18, "i", 16), E(19, "Back to shop"), w()()()()(), v(20, "div", 17)(21, "div", 8)(22, "h3", 18), E(23, "Summary"), w(), Ke(24, "hr", 19), v(25, "div", 20)(26, "h5", 21), E(27), w()(), Ke(28, "hr", 19), v(29, "div", 22)(30, "h5", 21), E(31, "Total price:"), w(), v(32, "h5"), E(33), dr(34, "currency"), w()(), ut(35, dk, 2, 0, "a", 23), ut(36, fk, 2, 0, "a", 24), w()()()()()()()()()), 2 & t && (P(13), sn("", r.listCart.length, " items"), P(1), Q("ngForOf", r.listCart), P(13), sn("items ", r.listCart.length, ""), P(6), Be(hi(34, 6, r.totail)), P(2), Q("ngIf", !r.check), P(1), Q("ngIf", r.check)) }, dependencies: [Di, Ci, vr, Nn, yf, Cr, wf, Zn, wa], styles: ["@media (min-width: 1025px){.h-custom[_ngcontent-%COMP%]{height:100vh!important}}.card-registration[_ngcontent-%COMP%]   .select-input.form-control[readonly][_ngcontent-%COMP%]:not([disabled]){font-size:1rem;line-height:2.15;padding-left:.75em;padding-right:.75em}.card-registration[_ngcontent-%COMP%]   .select-arrow[_ngcontent-%COMP%]{top:13px}.bg-grey[_ngcontent-%COMP%]{background-color:#eae8e8}@media (min-width: 992px){.card-registration-2[_ngcontent-%COMP%]   .bg-grey[_ngcontent-%COMP%]{border-top-right-radius:16px;border-bottom-right-radius:16px}}@media (max-width: 991px){.card-registration-2[_ngcontent-%COMP%]   .bg-grey[_ngcontent-%COMP%]{border-bottom-left-radius:16px;border-bottom-right-radius:16px}}"] }), e })(), pk = (() => { class e { constructor(t, r) { this.DataService = t, this.router = r, this.Username = "", this.Password = "", this.Email = "", this.Phone = "" } onSubmit() { 0 != this.Username.length && 0 != this.Password.length && 0 != this.Email.length && 0 != this.Phone.length ? this.DataService.post("/register", { phonenumber: this.Phone, email: this.Email, fullname: this.Username, password: this.Password }).then(t => { alert("Registration successful"), this.router.navigate(["/login"]) }).catch(t => { alert("Email or phone number exists ") }) : alert("Please fill all fields") } } return e.\u0275fac = function (t) { return new (t || e)(y(_r), y(Fe)) }, e.\u0275cmp = Wt({ type: e, selectors: [["app-register"]], decls: 30, vars: 4, consts: [[1, "container"], [1, "was-validated", 3, "ngSubmit"], [1, "mb-3", "mt-3"], ["for", "uname", 1, "form-label"], ["type", "text", "id", "uname", "placeholder", "Enter username", "name", "uname", "required", "", 1, "form-control", 3, "ngModel", "ngModelChange"], [1, "invalid-feedback"], ["for", "email", 1, "form-label"], ["type", "email", "id", "email", "placeholder", "Enter your email address", "name", "email", "required", "", 1, "form-control", 3, "ngModel", "ngModelChange"], ["for", "phone", 1, "form-label"], ["type", "text", "id", "phone", "placeholder", "Enter your phone number", "name", "phone", "required", "", 1, "form-control", 3, "ngModel", "ngModelChange"], [1, "mb-3"], ["for", "pwd", 1, "form-label"], ["type", "password", "id", "pwd", "placeholder", "Enter password", "name", "pswd", "required", "", 1, "form-control", 3, "ngModel", "ngModelChange"], ["type", "submit", 1, "btn", "btn-primary"], ["routerLink", "/login", 1, "btn", "btn-success"]], template: function (t, r) { 1 & t && (v(0, "div", 0)(1, "form", 1), Z("ngSubmit", function () { return r.onSubmit() }), v(2, "div", 2)(3, "label", 3), E(4, "Username:"), w(), v(5, "input", 4), Z("ngModelChange", function (i) { return r.Username = i }), w(), v(6, "div", 5), E(7, "Please fill out this field."), w()(), v(8, "div", 2)(9, "label", 6), E(10, "Email:"), w(), v(11, "input", 7), Z("ngModelChange", function (i) { return r.Email = i }), w(), v(12, "div", 5), E(13, "Please fill out this field."), w()(), v(14, "div", 2)(15, "label", 8), E(16, "Phone number:"), w(), v(17, "input", 9), Z("ngModelChange", function (i) { return r.Phone = i }), w(), v(18, "div", 5), E(19, "Please fill out this field."), w()(), v(20, "div", 10)(21, "label", 11), E(22, "Password:"), w(), v(23, "input", 12), Z("ngModelChange", function (i) { return r.Password = i }), w(), v(24, "div", 5), E(25, "Please fill out this field."), w()(), v(26, "button", 13), E(27, "Register"), w(), v(28, "a", 14), E(29, "I already have an account"), w()()()), 2 & t && (P(5), Q("ngModel", r.Username), P(6), Q("ngModel", r.Email), P(6), Q("ngModel", r.Phone), P(6), Q("ngModel", r.Password)) }, dependencies: [vr, Zi, Nn, Cr, zi, Yi, Zn, wr] }), e })(), gk = (() => { class e { constructor(t, r) { this.DataService = t, this.Router = r, this.phone = "", this.password = "" } onSubmit() { this.phone.length > 0 && this.password.length > 0 && this.DataService.login(this.phone, this.password).then(t => { alert("Login successful"), this.Router.navigate(["/account"]) }).catch(() => { alert("Login failed") }) } } return e.\u0275fac = function (t) { return new (t || e)(y(_r), y(Fe)) }, e.\u0275cmp = Wt({ type: e, selectors: [["app-login"]], decls: 18, vars: 2, consts: [[1, "container"], [1, "was-validated", 3, "submit"], [1, "mb-3", "mt-3"], ["for", "phone", 1, "form-label"], ["type", "text", "id", "phone", "placeholder", "Enter Phone number", "name", "phone", "required", "", 1, "form-control", 3, "ngModel", "ngModelChange"], [1, "invalid-feedback"], [1, "mb-3"], ["for", "pwd", 1, "form-label"], ["type", "password", "id", "pwd", "placeholder", "Enter password", "name", "pswd", "required", "", 1, "form-control", 3, "ngModel", "ngModelChange"], ["type", "submit", 1, "btn", "btn-primary"], ["routerLink", "/register", 1, "btn", "btn-success"]], template: function (t, r) { 1 & t && (v(0, "div", 0)(1, "form", 1), Z("submit", function () { return r.onSubmit() }), v(2, "div", 2)(3, "label", 3), E(4, "Phone number:"), w(), v(5, "input", 4), Z("ngModelChange", function (i) { return r.phone = i }), w(), v(6, "div", 5), E(7, "Please fill out this field."), w()(), v(8, "div", 6)(9, "label", 7), E(10, "Password:"), w(), v(11, "input", 8), Z("ngModelChange", function (i) { return r.password = i }), w(), v(12, "div", 5), E(13, "Please fill out this field."), w()(), v(14, "button", 9), E(15, "Login"), w(), v(16, "a", 10), E(17, "I do not have account"), w()()()), 2 & t && (P(5), Q("ngModel", r.phone), P(6), Q("ngModel", r.password)) }, dependencies: [vr, Zi, Nn, Cr, zi, Yi, Zn, wr] }), e })(); function mk(e, n) { if (1 & e && (v(0, "tr")(1, "td"), E(2), w(), v(3, "td"), E(4), w(), v(5, "td")(6, "span", 15), E(7, "Shipped"), w()()()), 2 & e) { const t = n.$implicit; P(2), Be(t.id), P(2), Be(t.date_created) } } let yk = (() => { class e { constructor(t) { this.DataService = t } ngOnInit() { this.load_profile(), this.load_order() } load_profile() { this.DataService.post("/account/profile", { phonenumber: localStorage.getItem("phone") }).then(t => { this.profile = t.result }) } change_email() { /^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,3})+$/.test(this.profile.email) && this.DataService.patch("/account/verify-email", { newEmail: this.profile.email, phonenumber: localStorage.getItem("phone") }).then(r => { this.profile = r.user }).catch(r => { console.log(r) }) } load_order() { this.DataService.get("/account/orders").then(t => { this.orders = t.data }) } } return e.\u0275fac = function (t) { return new (t || e)(y(_r)) }, e.\u0275cmp = Wt({ type: e, selectors: [["app-acount"]], decls: 33, vars: 4, consts: [[1, "container", "mt-5"], [1, "row"], [1, "col-md-4"], [1, "card"], ["src", "https://via.placeholder.com/300x300.png?text=Profile+Image", "alt", "...", 1, "card-img-top"], [1, "card-body"], [1, "card-title"], [1, "card-text"], [1, "list-group", "list-group-flush"], [1, "list-group-item"], [1, "was-validated"], ["type", "email", "name", "email", 1, "form-control", 3, "ngModel", "ngModelChange", "change"], [1, "col-md-8"], [1, "table", "table-striped"], [4, "ngFor", "ngForOf"], [1, "badge", "bg-success"]], template: function (t, r) { 1 & t && (v(0, "div", 0)(1, "div", 1)(2, "div", 2)(3, "div", 3), Ke(4, "img", 4), v(5, "div", 5)(6, "h5", 6), E(7), w(), v(8, "p", 7), E(9, "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua."), w()(), v(10, "ul", 8)(11, "li", 9), E(12, "Email: "), v(13, "form", 10)(14, "input", 11), Z("ngModelChange", function (i) { return r.profile.email = i })("change", function () { return r.change_email() }), w()()(), v(15, "li", 9), E(16), w(), v(17, "li", 9), E(18, "Address: 123 Main St, Anytown USA"), w()()()(), v(19, "div", 12)(20, "h2"), E(21, "My Orders"), w(), v(22, "table", 13)(23, "thead")(24, "tr")(25, "th"), E(26, "Order ID"), w(), v(27, "th"), E(28, "Date"), w(), v(29, "th"), E(30, "Status"), w()()(), v(31, "tbody"), ut(32, mk, 8, 2, "tr", 14), w()()()()()), 2 & t && (P(7), Be(r.profile.fullname), P(7), Q("ngModel", r.profile.email), P(2), sn("Phone: ", r.profile.phonenumber, ""), P(16), Q("ngForOf", r.orders)) }, dependencies: [Di, Zi, Nn, Cr, zi, Zn, wr] }), e })(), cw = (() => { class e { constructor(t, r) { this.authService = t, this.router = r } canActivate() { return !this.authService.isLoggedIn() || (this.router.navigate(["account"]), !1) } } return e.\u0275fac = function (t) { return new (t || e)(T(bf), T(Fe)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); const vk = [{ path: "home", component: rk }, { path: "products/:id", component: uk }, { path: "cart", component: hk }, { path: "register", component: pk, canActivate: [cw] }, { path: "login", component: gk, canActivate: [cw] }, { path: "account", component: yk }, { path: "order", component: (() => { class e { constructor(t, r) { this.DataService = t, this.route = r, this.buyerName = "", this.email = "", this.address = "", this.phone = "", this.paymentType = "" } onSubmit() { 0 != this.buyerName.length && 0 != this.email.length && 0 != this.address.length && 0 != this.phone.length && 0 != this.paymentType.length ? this.DataService.post("/checkout", { email: this.email, phonenumber: this.phone, payment: this.paymentType, address: this.address, fullname: this.buyerName }).then(() => { alert("Payment received successfully"), this.route.navigate(["/account"]) }).catch(() => { alert("Payment failed") }) : alert("Please fill all fields") } } return e.\u0275fac = function (t) { return new (t || e)(y(_r), y(Fe)) }, e.\u0275cmp = Wt({ type: e, selectors: [["app-order"]], decls: 34, vars: 5, consts: [[1, "container", "mt-5"], [3, "submit"], [1, "mb-3"], ["for", "buyerName", 1, "form-label"], ["name", "buyername", "type", "text", "id", "buyerName", "placeholder", "Enter your name", 1, "form-control", 3, "ngModel", "ngModelChange"], ["for", "email", 1, "form-label"], ["name", "email", "type", "email", "id", "email", "placeholder", "name@example.com", 1, "form-control", 3, "ngModel", "ngModelChange"], ["for", "address", 1, "form-label"], ["name", "address", "type", "text", "id", "address", "placeholder", "1234 Main St", 1, "form-control", 3, "ngModel", "ngModelChange"], ["for", "zip", 1, "form-label"], ["type", "text", "id", "zip", "placeholder", "Enter Phone number", "name", "zip", 1, "form-control", 3, "ngModel", "ngModelChange"], ["for", "paymentMethod", 1, "form-label"], ["id", "paymentMethod", "name", "paymentType", 1, "form-select", 3, "ngModel", "ngModelChange"], ["selected", ""], ["value", "creditCard"], ["value", "debitCard"], ["value", "paypal"], ["type", "submit", 1, "btn", "btn-primary"]], template: function (t, r) { 1 & t && (v(0, "div", 0)(1, "h2"), E(2, "Domestic Goods Purchase Information"), w(), v(3, "form", 1), Z("submit", function () { return r.onSubmit() }), v(4, "div", 2)(5, "label", 3), E(6, "Buyer Name"), w(), v(7, "input", 4), Z("ngModelChange", function (i) { return r.buyerName = i }), w()(), v(8, "div", 2)(9, "label", 5), E(10, "Email address"), w(), v(11, "input", 6), Z("ngModelChange", function (i) { return r.email = i }), w()(), v(12, "div", 2)(13, "label", 7), E(14, "Shipping Address"), w(), v(15, "input", 8), Z("ngModelChange", function (i) { return r.address = i }), w()(), v(16, "div", 2)(17, "label", 9), E(18, "Phone number"), w(), v(19, "input", 10), Z("ngModelChange", function (i) { return r.phone = i }), w()(), v(20, "div", 2)(21, "label", 11), E(22, "Payment Method"), w(), v(23, "select", 12), Z("ngModelChange", function (i) { return r.paymentType = i }), v(24, "option", 13), E(25, "Choose..."), w(), v(26, "option", 14), E(27, "Credit Card"), w(), v(28, "option", 15), E(29, "Debit Card"), w(), v(30, "option", 16), E(31, "PayPal"), w()()(), v(32, "button", 17), E(33, "Submit"), w()()()), 2 & t && (P(7), Q("ngModel", r.buyerName), P(4), Q("ngModel", r.email), P(4), Q("ngModel", r.address), P(4), Q("ngModel", r.phone), P(4), Q("ngModel", r.paymentType)) }, dependencies: [Zi, XC, ew, Nn, ul, Cr, zi, Zn, wr] }), e })() }, { path: "", redirectTo: "home", pathMatch: "full" }, { path: "**", redirectTo: "home", pathMatch: "full" }]; let _k = (() => { class e { } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275mod = ft({ type: e }), e.\u0275inj = ot({ imports: [zD.forRoot(vk), zD] }), e })(); function Dk(e, n) { 1 & e && (v(0, "li", 8)(1, "a", 12), E(2, "Login"), w()()) } function Ck(e, n) { 1 & e && (v(0, "li", 8)(1, "a", 13), E(2, "Profile"), w()()) } let wk = (() => { class e { constructor(t) { this.AuthService = t, this.check = !1 } ngOnInit() { this.check = this.AuthService.isLoggedIn() } } return e.\u0275fac = function (t) { return new (t || e)(y(bf)) }, e.\u0275cmp = Wt({ type: e, selectors: [["app-root"]], decls: 18, vars: 2, consts: [["rel", "stylesheet", "href", "https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css"], [1, "navbar", "navbar-expand-sm", "navbar-dark", "bg-dark"], [1, "container-fluid"], ["href", "/", 1, "navbar-brand"], ["type", "button", "data-bs-toggle", "collapse", "data-bs-target", "#mynavbar", 1, "navbar-toggler"], [1, "navbar-toggler-icon"], ["id", "mynavbar", 1, "collapse", "navbar-collapse"], [1, "navbar-nav", "me-auto"], [1, "nav-item"], ["routerLink", "/home", "routerLinkActive", "active", 1, "nav-link"], ["routerLink", "/cart", "routerLinkActive", "active", 1, "nav-link"], ["class", "nav-item", 4, "ngIf"], ["routerLink", "/login", "routerLinkActive", "active", 1, "nav-link"], ["routerLink", "/account", "routerLinkActive", "active", 1, "nav-link"]], template: function (t, r) { 1 & t && (Ke(0, "link", 0), v(1, "nav", 1)(2, "div", 2)(3, "a", 3), E(4, "Logo"), w(), v(5, "button", 4), Ke(6, "span", 5), w(), v(7, "div", 6)(8, "ul", 7)(9, "li", 8)(10, "a", 9), E(11, "Home"), w()(), v(12, "li", 8)(13, "a", 10), E(14, "Cart"), w()(), ut(15, Dk, 3, 0, "li", 11), ut(16, Ck, 3, 0, "li", 11), w()()()(), Ke(17, "router-outlet")), 2 & t && (P(15), Q("ngIf", !r.check), P(1), Q("ngIf", r.check)) }, dependencies: [Ci, Vd, vr, kD] }), e })(), bk = (() => { class e { } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275mod = ft({ type: e, bootstrap: [wk] }), e.\u0275inj = ot({ imports: [xP, _k, jF, VO, QO, JO] }), e })(); TP().bootstrapModule(bk).catch(e => console.error(e)) } }, se => { se(se.s = 112) }]);